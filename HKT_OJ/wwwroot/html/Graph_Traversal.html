<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Graph Traversal</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet">
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']]
            }
        };
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-weight: 600;
            line-height: 1.7;
            color: #2c3e50;
            background: white;
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 40px 20px;
            animation: fadeInUp 0.8s ease-out;
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        h1 {
            font-size: 3.5rem;
            font-weight: 800;
            color: #2c3e50;
            text-align: center;
            margin-bottom: 50px;
            position: relative;
            animation: slideInDown 1s ease-out;
        }

        @keyframes slideInDown {
            from {
                opacity: 0;
                transform: translateY(-50px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        h1::after {
            content: '';
            display: block;
            width: 170px;
            height: 4px;
            background: linear-gradient(90deg, #8e44ad, #9b59b6);
            margin: 20px auto;
            border-radius: 2px;
            animation: expandLine 1.2s ease-out 0.5s both;
        }

        @keyframes expandLine {
            from {
                width: 0;
            }
            to {
                width: 170px;
            }
        }

        h2 {
            font-size: 2.4rem;
            font-weight: 700;
            color: #34495e;
            margin-top: 60px;
            margin-bottom: 25px;
            border-left: 5px solid #8e44ad;
            padding-left: 20px;
            animation: slideInLeft 0.6s ease-out;
        }

        @keyframes slideInLeft {
            from {
                opacity: 0;
                transform: translateX(-30px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        h3 {
            font-size: 1.9rem;
            font-weight: 700;
            color: #2c3e50;
            margin-top: 40px;
            margin-bottom: 20px;
            position: relative;
        }

        h3::before {
            content: 'üåê';
            margin-right: 10px;
            font-size: 0.9em;
        }

        p {
            font-size: 1.15rem;
            font-weight: 600;
            margin-bottom: 25px;
            text-align: justify;
            line-height: 1.8;
        }

        ul {
            margin: 25px 0;
            padding-left: 0;
        }

        li {
            font-size: 1.15rem;
            font-weight: 600;
            margin-bottom: 15px;
            line-height: 1.8;
            list-style: none;
            position: relative;
            padding-left: 30px;
        }

        li::before {
            content: 'üîó';
            position: absolute;
            left: 0;
            top: 0;
        }

        .code-container {
            background: #1e1e1e;
            border-radius: 12px;
            margin: 30px 0;
            overflow: hidden;
            box-shadow: 0 8px 25px rgba(0,0,0,0.15);
            border: 1px solid #333;
            animation: fadeIn 0.8s ease-out;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }

        .code-header {
            background: linear-gradient(90deg, #2c3e50, #34495e);
            color: white;
            padding: 12px 20px;
            font-weight: 700;
            font-size: 0.9rem;
            border-bottom: 1px solid #444;
        }

        pre {
            margin: 0 !important;
            background: #1e1e1e !important;
            border-radius: 0 !important;
        }

        code {
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace !important;
            font-size: 0.95rem !important;
            line-height: 1.6 !important;
            font-weight: 500 !important;
        }

        .line-numbers-rows {
            border-right: 1px solid #444 !important;
            padding-right: 10px !important;
            margin-right: 15px !important;
        }

        .complexity {
            background: linear-gradient(135deg, #f3e5f5, #e1bee7);
            padding: 20px 25px;
            border-radius: 12px;
            border-left: 4px solid #8e44ad;
            margin: 25px 0;
            font-weight: 700;
            box-shadow: 0 4px 15px rgba(142, 68, 173, 0.1);
        }

        .warning {
            background: linear-gradient(135deg, #fff3cd, #ffeaa7);
            padding: 20px 25px;
            border-radius: 12px;
            border-left: 4px solid #ffc107;
            margin: 25px 0;
            font-weight: 700;
            box-shadow: 0 4px 15px rgba(255, 193, 7, 0.1);
        }

        .warning::before {
            content: '‚ö†Ô∏è ';
            font-size: 1.2em;
        }

        .section {
            margin-bottom: 50px;
            padding: 35px;
            background: #fafbfc;
            border-radius: 15px;
            border: 1px solid #e1e8ed;
            animation: slideInUp 0.6s ease-out;
        }

        @keyframes slideInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .focus-problem {
            background: linear-gradient(135deg, #f3e5f5, #e1bee7);
            padding: 25px;
            border-radius: 15px;
            margin: 30px 0;
            border: 2px solid #8e44ad;
            text-align: center;
            font-weight: 700;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% {
                box-shadow: 0 0 0 0 rgba(142, 68, 173, 0.4);
            }
            70% {
                box-shadow: 0 0 0 10px rgba(142, 68, 173, 0);
            }
            100% {
                box-shadow: 0 0 0 0 rgba(142, 68, 173, 0);
            }
        }

        .highlight {
            background: linear-gradient(120deg, #d1c4e9 0%, #b39ddb 100%);
            padding: 3px 8px;
            border-radius: 6px;
            font-weight: 800;
        }

        .hover-effect {
            transition: all 0.3s ease;
        }

        .hover-effect:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 35px rgba(0,0,0,0.15);
        }

        .algorithm-comparison {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 25px;
            margin: 30px 0;
        }

        .algorithm-card {
            background: white;
            border-radius: 12px;
            padding: 25px;
            border-left: 4px solid #8e44ad;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            transition: transform 0.3s ease;
        }

        .algorithm-card:hover {
            transform: translateY(-5px);
        }

        .algorithm-title {
            font-weight: 800;
            color: #8e44ad;
            margin-bottom: 15px;
            font-size: 1.3rem;
        }

        .dfs-specific {
            border-left-color: #e74c3c;
        }

        .dfs-specific .algorithm-title {
            color: #e74c3c;
        }

        .bfs-specific {
            border-left-color: #3498db;
        }

        .bfs-specific .algorithm-title {
            color: #3498db;
        }

        .graph-visual {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 25px;
            margin: 25px 0;
            border: 2px solid #8e44ad;
            text-align: center;
        }

        .node {
            display: inline-block;
            width: 40px;
            height: 40px;
            background: #ecf0f1;
            border: 2px solid #bdc3c7;
            border-radius: 50%;
            text-align: center;
            line-height: 36px;
            margin: 5px;
            font-weight: 700;
            font-size: 1rem;
            position: relative;
        }

        .visited-node {
            background: #d1c4e9 !important;
            border-color: #8e44ad !important;
            color: #4a148c !important;
        }

        .current-node {
            background: #ffeb3b !important;
            border-color: #f57f17 !important;
            color: #e65100 !important;
        }

        .application-box {
            background: linear-gradient(135deg, #e3f2fd, #bbdefb);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 4px solid #2196f3;
            font-weight: 700;
        }

        .application-box::before {
            content: 'üéØ Application: ';
            font-weight: 800;
            color: #1976d2;
        }

        .solution-header {
            color: #8e44ad;
            font-weight: 800;
            border-bottom: 3px solid #8e44ad;
            padding-bottom: 8px;
            display: inline-block;
            margin-bottom: 20px;
        }

        .data-structure-box {
            background: linear-gradient(135deg, #fff8e1, #ffecb3);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 4px solid #ff9800;
            font-weight: 700;
        }

        .data-structure-box::before {
            content: 'üìä Data Structure: ';
            font-weight: 800;
            color: #f57c00;
        }

        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            margin: 25px 0;
            background: white;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }

        .comparison-table th, .comparison-table td {
            padding: 15px;
            text-align: left;
            font-weight: 700;
            border: 1px solid #e1e8ed;
        }

        .comparison-table th {
            background: linear-gradient(90deg, #8e44ad, #9b59b6);
            color: white;
            font-size: 1.1rem;
        }

        .comparison-table td {
            background: #f8f9fa;
            font-size: 1.05rem;
        }

        .recursion-warning {
            background: linear-gradient(135deg, #ffebee, #ffcdd2);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 4px solid #f44336;
            font-weight: 700;
        }

        .recursion-warning::before {
            content: 'üö® Deep Recursion Issue: ';
            font-weight: 800;
            color: #c62828;
        }

        .traversal-steps {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin: 25px 0;
        }

        .step {
            background: white;
            border-radius: 8px;
            padding: 15px 20px;
            border-left: 4px solid #8e44ad;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .step-number {
            font-weight: 800;
            color: #8e44ad;
            margin-right: 10px;
        }

        .resources-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin: 30px 0;
        }

        .resource-card {
            background: white;
            border-radius: 10px;
            padding: 20px;
            border-left: 4px solid #8e44ad;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            transition: transform 0.3s ease;
        }

        .resource-card:hover {
            transform: translateY(-3px);
        }

        .resource-title {
            font-weight: 800;
            color: #8e44ad;
            margin-bottom: 10px;
            font-size: 1.1rem;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Graph Traversal</h1>
        
        <div class="section hover-effect">
            <h2>Introduction to Graph Traversal</h2>
            
            <p><span class="highlight">Graph traversal algorithms</span> visit all nodes within a graph in a certain order and can compute some information along the way. Two common algorithms for doing this are <strong>depth first search (DFS)</strong> and <strong>breadth first search (BFS)</strong>.</p>

            <div class="algorithm-comparison">
                <div class="algorithm-card dfs-specific">
                    <div class="algorithm-title">Depth First Search (DFS)</div>
                    <ul>
                        <li>Explores as far as possible along each branch before backtracking</li>
                        <li>Uses a stack (often implemented with recursion)</li>
                        <li>Memory efficient for sparse graphs</li>
                        <li>Good for detecting cycles and path finding</li>
                    </ul>
                </div>
                <div class="algorithm-card bfs-specific">
                    <div class="algorithm-title">Breadth First Search (BFS)</div>
                    <ul>
                        <li>Explores all neighbors at current depth before moving deeper</li>
                        <li>Uses a queue data structure</li>
                        <li>Finds shortest path in unweighted graphs</li>
                        <li>Level-by-level exploration pattern</li>
                    </ul>
                </div>
            </div>

            <div class="complexity">
                <strong>Time and Space Complexity:</strong><br>
                ‚Ä¢ Time Complexity: $\mathcal{O}(V + E)$ where V = vertices, E = edges<br>
                ‚Ä¢ Space Complexity: $\mathcal{O}(V)$ for visited array and data structures<br>
                ‚Ä¢ Both algorithms visit each vertex and edge exactly once
            </div>
        </div>

        <div class="section hover-effect">
            <h2>Applications of Graph Traversal</h2>

            <h3>Connected Components</h3>
            
            <div class="focus-problem">
                <strong>üéØ Focus Problem:</strong> Building Roads (CSES - Easy)<br>
                Try your best to solve this problem before continuing!
            </div>

            <div class="application-box">
                A <strong>connected component</strong> is a maximal set of connected nodes in an undirected graph. In other words, two nodes are in the same connected component if and only if they can reach each other via edges in the graph.
            </div>

            <p>In the above focus problem, the goal is to add the minimum possible number of edges such that the entire graph forms a single connected component.</p>

            <h3>Graph Two-Coloring</h3>
            
            <div class="focus-problem">
                <strong>üéØ Focus Problem:</strong> Building Teams (CSES - Easy)<br>
                Try your best to solve this problem before continuing!
            </div>

            <div class="application-box">
                <strong>Graph two-coloring</strong> refers to assigning a boolean value to each node of the graph, dictated by the edge configuration. The most common example of a two-colored graph is a bipartite graph, in which each edge connects two nodes of opposite colors.
            </div>

            <p>In the above focus problem, the goal is to assign each node (friend) of the graph to one of two colors (teams), subject to the constraint that edges (friendships) connect two nodes of opposite colors. In other words, we need to check whether the input is a bipartite graph and output a valid coloring if it is.</p>
        </div>

        <div class="section hover-effect">
            <h2>Depth First Search (DFS)</h2>

            <div class="resources-grid">
                <div class="resource-card">
                    <div class="resource-title">CSA</div>
                    <p>Depth First Search - up to but not including "More about DFS"</p>
                </div>
                <div class="resource-card">
                    <div class="resource-title">CPH</div>
                    <p>12.1 - DFS example diagram + code</p>
                </div>
            </div>

            <p>From the resources above:</p>

            <blockquote style="font-style: italic; border-left: 4px solid #8e44ad; padding-left: 20px; margin: 20px 0;">
                Depth-first search (DFS) is a straightforward graph traversal technique. The algorithm begins at a starting node, and proceeds to all other nodes that are reachable from the starting node using the edges of the graph. Depth-first search always follows a single path in the graph as long as it finds new nodes. After this, it returns to previous nodes and begins to explore other parts of the graph. The algorithm keeps track of visited nodes, so that it processes each node only once.
            </blockquote>

            <h3>DFS Algorithm Steps</h3>
            <div class="traversal-steps">
                <div class="step">
                    <span class="step-number">1.</span>
                    <strong>Mark current node as visited</strong>
                </div>
                <div class="step">
                    <span class="step-number">2.</span>
                    <strong>Process current node</strong> (perform required operations)
                </div>
                <div class="step">
                    <span class="step-number">3.</span>
                    <strong>Recursively visit all unvisited neighbors</strong>
                </div>
                <div class="step">
                    <span class="step-number">4.</span>
                    <strong>Backtrack</strong> when no more unvisited neighbors exist
                </div>
            </div>

            <p>When implementing DFS, we often use a recursive function to visit the vertices and an array to store whether we've seen a vertex before.</p>

            <div class="code-container">
                <div class="code-header">C++ - DFS Implementation</div>
                <pre class="line-numbers"><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;

int n = 6;
vector&lt;vector&lt;int&gt;&gt; adj(n);
vector&lt;bool&gt; visited(n);

void dfs(int current_node) {
    if (visited[current_node]) { 
        return; 
    }
    visited[current_node] = true;
    
    // Process current node here
    cout &lt;&lt; "Visiting node: " &lt;&lt; current_node &lt;&lt; endl;
    
    for (int neighbor : adj[current_node]) { 
        dfs(neighbor); 
    }
}

int main() {
    /*
     * Define adjacency list and read in problem-specific input
     *
     * In this example, we've provided "dummy input" that's
     * reflected in the algorithm visualization above to help illustrate the
     * order of the recursive calls.
     */
    adj[0] = {1, 2, 4};
    adj[1] = {3, 4};
    adj[2] = {5};
    
    for (int i = 0; i &lt; n; i++) {
        // iterate over all connected components in the graph
        if (!visited[i]) { 
            dfs(i); 
        }
    }
    
    return 0;
}</code></pre>
            </div>

            <div class="recursion-warning">
                <strong>Stack Overflow Issue:</strong> If you run DFS on a very deep graph (like a long chain), you might get a segmentation fault due to stack overflow. This occurs because every recursive call contributes to the call stack, which is limited. To fix this, you can either increase stack size or use iterative DFS with an explicit stack.
            </div>
        </div>

        <div class="section hover-effect">
            <h2>Breadth First Search (BFS)</h2>

            <div class="resources-grid">
                <div class="resource-card">
                    <div class="resource-title">CSA</div>
                    <p>BFS - interactive, implementation</p>
                </div>
                <div class="resource-card">
                    <div class="resource-title">PAPS</div>
                    <p>12.1 - BFS grid, 8-puzzle examples</p>
                </div>
                <div class="resource-card">
                    <div class="resource-title">cp-algo</div>
                    <p>BFS - common applications</p>
                </div>
                <div class="resource-card">
                    <div class="resource-title">KA</div>
                    <p>BFS and its uses</p>
                </div>
            </div>

            <p><em>In a breadth-first search, we travel through the vertices in order of their distance from the starting vertex.</em></p>

            <h3>Prerequisite - Queues & Deques</h3>

            <div class="data-structure-box">
                A <strong>queue</strong> is a First In First Out (FIFO) data structure that supports three operations, all in $\mathcal{O}(1)$ time.
            </div>

            <table class="comparison-table">
                <tr>
                    <th>Operation</th>
                    <th>Description</th>
                    <th>C++ Method</th>
                </tr>
                <tr>
                    <td><strong>push</strong></td>
                    <td>Inserts at the back of the queue</td>
                    <td><code>q.push(x)</code></td>
                </tr>
                <tr>
                    <td><strong>pop</strong></td>
                    <td>Deletes from the front of the queue</td>
                    <td><code>q.pop()</code></td>
                </tr>
                <tr>
                    <td><strong>front</strong></td>
                    <td>Retrieves the element at the front without removing it</td>
                    <td><code>q.front()</code></td>
                </tr>
            </table>

            <div class="code-container">
                <div class="code-header">C++ - Queue Example</div>
                <pre class="line-numbers"><code class="language-cpp">queue&lt;int&gt; q;
q.push(1);                  // [1]
q.push(3);                  // [3, 1]
q.push(4);                  // [4, 3, 1]
q.pop();                    // [4, 3]
cout &lt;&lt; q.front() &lt;&lt; endl;  // 3</code></pre>
            </div>

            <h3>Deques</h3>
            <p>A <span class="highlight">deque</span> (usually pronounced "deck") stands for double ended queue and is a combination of a stack and a queue, in that it supports $\mathcal{O}(1)$ insertions and deletions from both the front and the back of the deque. Not very common in Bronze / Silver.</p>

            <div class="data-structure-box">
                The four methods for adding and removing are <code>push_back</code>, <code>pop_back</code>, <code>push_front</code>, and <code>pop_front</code>.
            </div>

            <div class="code-container">
                <div class="code-header">C++ - Deque Example</div>
                <pre class="line-numbers"><code class="language-cpp">deque&lt;int&gt; d;
d.push_front(3);  // [3]
d.push_front(4);  // [4, 3]
d.push_back(7);   // [4, 3, 7]
d.pop_front();    // [3, 7]
d.push_front(1);  // [1, 3, 7]
d.pop_back();     // [1, 3]

// You can also access deques like an array in constant time
cout &lt;&lt; d[0] &lt;&lt; endl;  // Access i-th element</code></pre>
            </div>

            <h3>BFS Implementation</h3>
            <p>When implementing BFS, we often use a queue to track the next vertex to visit. Like DFS, we'll also keep an array to store whether we've seen a vertex before.</p>

            <div class="code-container">
                <div class="code-header">C++ - BFS Implementation</div>
                <pre class="line-numbers"><code class="language-cpp">#include &lt;queue&gt;
#include &lt;vector&gt;

using std::queue;
using std::vector;

int main() {
    int n = 6;
    vector&lt;vector&lt;int&gt;&gt; adj(n);
    vector&lt;bool&gt; visited(n);
    
    /*
     * Define adjacency list and read in problem-specific input
     *
     * In this example, we've provided "dummy input" that's
     * reflected in the algorithm visualization above to help illustrate the
     * order of the recursive calls.
     */
    adj[0] = {1, 2, 4};
    adj[1] = {3, 4};
    adj[2] = {5};
    
    for (int i = 0; i &lt; n; i++) {
        // iterate over all connected components in the graph
        if (!visited[i]) {
            queue&lt;int&gt; q;
            q.push(i);
            visited[i] = true;
            
            while (!q.empty()) {
                int current_node = q.front();
                q.pop();
                
                // Process current node here
                cout &lt;&lt; "Visiting node: " &lt;&lt; current_node &lt;&lt; endl;
                
                for (int neighbor : adj[current_node]) {
                    if (!visited[neighbor]) {
                        visited[neighbor] = true;
                        q.push(neighbor);
                    }
                }
            }
        }
    }
    
    return 0;
}</code></pre>
            </div>

            <div class="algorithm-comparison">
                <div class="algorithm-card">
                    <div class="algorithm-title">BFS Key Properties</div>
                    <ul>
                        <li>Finds shortest path in unweighted graphs</li>
                        <li>Explores nodes level by level</li>
                        <li>Uses more memory than DFS (stores entire frontier)</li>
                        <li>No recursion depth issues</li>
                    </ul>
                </div>
                <div class="algorithm-card">
                    <div class="algorithm-title">When to Use BFS</div>
                    <ul>
                        <li>Finding shortest paths</li>
                        <li>Level-order traversal</li>
                        <li>Minimum spanning tree algorithms</li>
                        <li>Connected component analysis</li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="section hover-effect">
            <h2>Solution - Building Roads</h2>

            <p>Note that each edge decreases the number of connected components by either zero or one. So you must add at least $C-1$ edges, where $C$ is the number of connected components in the input graph.</p>

            <p>To compute $C$, iterate through each node. If it has not been visited, visit it and all other nodes in its connected component using DFS or BFS. Then $C$ equals the number of times we perform the visiting operation.</p>

            <p>There are many valid ways to pick $C-1$ new roads to build. One way is to choose a single representative from each of the $C$ components and link them together in a line.</p>

            <h3 class="solution-header">DFS Solution</h3>

            <div class="code-container">
                <div class="code-header">C++ - Building Roads (DFS Solution)</div>
                <pre class="line-numbers"><code class="language-cpp">#include &lt;deque&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

vector&lt;vector&lt;int&gt;&gt; adj;
vector&lt;bool&gt; visited;

void dfs(int node) {
    for (int n : adj[node]) {
        if (!visited[n]) {
            visited[n] = true;
            dfs(n);
        }
    }
}

int main() {
    int n;
    int m;
    cin &gt;&gt; n &gt;&gt; m;
    adj = vector&lt;vector&lt;int&gt;&gt;(n);
    
    for (int i = 0; i &lt; m; i++) {
        int a, b;
        cin &gt;&gt; a &gt;&gt; b;
        adj[--a].push_back(--b);
        adj[b].push_back(a);
    }
    
    visited = vector&lt;bool&gt;(n);
    vector&lt;int&gt; city_reps;
    
    for (int i = 0; i &lt; n; i++) {
        if (visited[i]) { 
            continue; 
        }
        
        visited[i] = true;
        city_reps.push_back(i);
        dfs(i);
    }
    
    cout &lt;&lt; city_reps.size() - 1 &lt;&lt; '\n';
    for (int i = 0; i &lt; city_reps.size() - 1; i++) {
        cout &lt;&lt; city_reps[i] + 1 &lt;&lt; ' ' &lt;&lt; city_reps[i + 1] + 1 &lt;&lt; '\n';
    }
    
    return 0;
}</code></pre>
            </div>

            <div class="recursion-warning">
                <strong>An Issue With Deep Recursion:</strong> If you run the solution code locally on a line graph with 100,000 nodes, you might get a segmentation fault even though your code passes on the online judge. This occurs because every recursive call contributes to the size of the call stack, which is limited to a few megabytes by default.<br><br>
                <strong>Solution:</strong> If you would normally compile your code with <code>g++ sol.cpp</code>, then compile it with <code>g++ -Wl,-stack_size,0xF0000000 sol.cpp</code> instead.
            </div>

            <h3 class="solution-header">BFS Solution</h3>

            <div class="code-container">
                <div class="code-header">C++ - Building Roads (BFS Solution)</div>
                <pre class="line-numbers"><code class="language-cpp">#include &lt;deque&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
    int n;
    int m;
    cin &gt;&gt; n &gt;&gt; m;
    vector&lt;vector&lt;int&gt;&gt; adj(n);
    
    for (int i = 0; i &lt; m; i++) {
        int a, b;
        cin &gt;&gt; a &gt;&gt; b;
        adj[--a].push_back(--b);
        adj[b].push_back(a);
    }
    
    vector&lt;bool&gt; visited(n);
    vector&lt;int&gt; city_reps;
    
    for (int i = 0; i &lt; n; i++) {
        if (visited[i]) { 
            continue; 
        }
        
        visited[i] = true;
        city_reps.push_back(i);
        deque&lt;int&gt; todo{i};
        
        while (!todo.empty()) {
            int curr = todo.front();
            todo.pop_front();
            
            for (int next : adj[curr]) {
                if (!visited[next]) {
                    visited[next] = true;
                    todo.push_back(next);
                }
            }
        }
    }
    
    cout &lt;&lt; city_reps.size() - 1 &lt;&lt; '\n';
    for (int i = 0; i &lt; city_reps.size() - 1; i++) {
        cout &lt;&lt; city_reps[i] + 1 &lt;&lt; ' ' &lt;&lt; city_reps[i + 1] + 1 &lt;&lt; '\n';
    }
    
    return 0;
}</code></pre>
            </div>

            <div class="algorithm-comparison">
                <div class="algorithm-card">
                    <div class="algorithm-title">DFS vs BFS for Connected Components</div>
                    <ul>
                        <li><strong>Both have same time complexity:</strong> $\mathcal{O}(V + E)$</li>
                        <li><strong>DFS:</strong> Simpler to implement, uses less memory</li>
                        <li><strong>BFS:</strong> No stack overflow issues, iterative approach</li>
                        <li><strong>Choice:</strong> Either works fine for this problem</li>
                    </ul>
                </div>
                <div class="algorithm-card">
                    <div class="algorithm-title">Solution Strategy</div>
                    <ul>
                        <li>Count connected components by running DFS/BFS from unvisited nodes</li>
                        <li>Store one representative from each component</li>
                        <li>Connect representatives with $C-1$ edges</li>
                        <li>Output the minimum number of roads needed</li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="section hover-effect">
            <h2>Comparison and Best Practices</h2>

            <table class="comparison-table">
                <tr>
                    <th>Aspect</th>
                    <th>Depth First Search (DFS)</th>
                    <th>Breadth First Search (BFS)</th>
                </tr>
                <tr>
                    <td><strong>Data Structure</strong></td>
                    <td>Stack (recursion or explicit)</td>
                    <td>Queue</td>
                </tr>
                <tr>
                    <td><strong>Memory Usage</strong></td>
                    <td>$\mathcal{O}(h)$ where h is max depth</td>
                    <td>$\mathcal{O}(w)$ where w is max width</td>
                </tr>
                <tr>
                    <td><strong>Shortest Path</strong></td>
                    <td>Not guaranteed</td>
                    <td>Yes (unweighted graphs)</td>
                </tr>
                <tr>
                    <td><strong>Implementation</strong></td>
                    <td>Simpler (recursive)</td>
                    <td>Iterative with queue</td>
                </tr>
                <tr>
                    <td><strong>Stack Overflow</strong></td>
                    <td>Possible with deep recursion</td>
                    <td>Not an issue</td>
                </tr>
                <tr>
                    <td><strong>Use Cases</strong></td>
                    <td>Topological sort, cycle detection</td>
                    <td>Shortest path, level traversal</td>
                </tr>
            </table>

            <div class="algorithm-comparison">
                <div class="algorithm-card">
                    <div class="algorithm-title">When to Choose DFS</div>
                    <ul>
                        <li>Finding connected components</li>
                        <li>Detecting cycles in graphs</li>
                        <li>Topological sorting</li>
                        <li>Path finding (not necessarily shortest)</li>
                        <li>Memory is limited</li>
                        <li>Simple recursive implementation preferred</li>
                    </ul>
                </div>
                <div class="algorithm-card">
                    <div class="algorithm-title">When to Choose BFS</div>
                    <ul>
                        <li>Finding shortest paths in unweighted graphs</li>
                        <li>Level-order traversal</li>
                        <li>Finding all nodes at distance k</li>
                        <li>Minimum spanning tree (Prim's algorithm)</li>
                        <li>Deep graphs (avoid stack overflow)</li>
                        <li>Web crawling (level by level)</li>
                    </ul>
                </div>
            </div>

            <div class="complexity">
                <strong>Implementation Tips:</strong><br>
                ‚Ä¢ Always mark nodes as visited when adding to queue/stack, not when processing<br>
                ‚Ä¢ Use adjacency lists for sparse graphs, adjacency matrix for dense graphs<br>
                ‚Ä¢ Consider iterative DFS if recursion depth is a concern<br>
                ‚Ä¢ BFS guarantees shortest path only in unweighted graphs<br>
                ‚Ä¢ Both algorithms can be adapted for weighted graphs with modifications
            </div>

            <div class="warning">
                <strong>Common Mistakes to Avoid:</strong><br>
                ‚Ä¢ Forgetting to mark nodes as visited<br>
                ‚Ä¢ Marking nodes as visited too late (leads to duplicate processing)<br>
                ‚Ä¢ Not handling disconnected components<br>
                ‚Ä¢ Stack overflow in DFS with deep recursion<br>
                ‚Ä¢ Using wrong data structure (stack vs queue)
            </div>
        </div>

        <div class="section hover-effect">
            <h2>Advanced Applications and Variations</h2>

            <div class="application-box">
                <strong>Graph Traversal</strong> forms the foundation for many advanced graph algorithms including shortest path algorithms, minimum spanning trees, and network flow algorithms.
            </div>

            <div class="algorithm-comparison">
                <div class="algorithm-card">
                    <div class="algorithm-title">DFS Applications</div>
                    <ul>
                        <li><strong>Strongly Connected Components:</strong> Kosaraju's and Tarjan's algorithms</li>
                        <li><strong>Articulation Points:</strong> Finding critical nodes in networks</li>
                        <li><strong>Bridge Finding:</strong> Critical edges in connectivity</li>
                        <li><strong>Maze Solving:</strong> Finding any path through a maze</li>
                        <li><strong>Sudoku Solving:</strong> Backtracking with DFS</li>
                    </ul>
                </div>
                <div class="algorithm-card">
                    <div class="algorithm-title">BFS Applications</div>
                    <ul>
                        <li><strong>Shortest Path:</strong> Dijkstra's algorithm extension</li>
                        <li><strong>Level Order:</strong> Tree and graph level processing</li>
                        <li><strong>Bipartite Testing:</strong> Two-coloring with BFS</li>
                        <li><strong>Peer-to-Peer Networks:</strong> Finding nearest neighbors</li>
                        <li><strong>Social Networks:</strong> Finding degrees of separation</li>
                    </ul>
                </div>
            </div>

            <div class="data-structure-box">
                <strong>Optimization Techniques:</strong><br>
                ‚Ä¢ <strong>Bidirectional Search:</strong> Search from both start and end<br>
                ‚Ä¢ <strong>A* Algorithm:</strong> BFS with heuristic guidance<br>
                ‚Ä¢ <strong>Iterative Deepening:</strong> Combining DFS and BFS benefits<br>
                ‚Ä¢ <strong>Parallel Traversal:</strong> Multi-threaded graph exploration
            </div>

            <div class="complexity">
                <strong>Space-Time Tradeoffs:</strong><br>
                ‚Ä¢ DFS: Less memory, may not find optimal path<br>
                ‚Ä¢ BFS: More memory, guarantees shortest path in unweighted graphs<br>
                ‚Ä¢ Iterative DFS: Avoids recursion overhead, more complex implementation<br>
                ‚Ä¢ Bidirectional BFS: Reduces search space significantly for shortest paths
            </div>
        </div>

        <div class="section hover-effect">
            <h2>Practice Problems and Next Steps</h2>

            <div class="algorithm-comparison">
                <div class="algorithm-card">
                    <div class="algorithm-title">Beginner Problems</div>
                    <ul>
                        <li>Count connected components</li>
                        <li>Check if graph is bipartite</li>
                        <li>Find path between two nodes</li>
                        <li>Detect cycles in undirected graphs</li>
                        <li>Tree traversal problems</li>
                    </ul>
                </div>
                <div class="algorithm-card">
                    <div class="algorithm-title">Intermediate Problems</div>
                    <ul>
                        <li>Shortest path in unweighted graphs</li>
                        <li>Topological sorting</li>
                        <li>Finding bridges and articulation points</li>
                        <li>Strongly connected components</li>
                        <li>Graph coloring variations</li>
                    </ul>
                </div>
            </div>

            <div class="application-box">
                <strong>Learning Path:</strong> Master basic DFS and BFS first, then move to specialized algorithms like Dijkstra's, Floyd-Warshall, and advanced graph theory concepts. Practice with real-world problems to build intuition.
            </div>

            <div class="complexity">
                <strong>Key Takeaways:</strong><br>
                ‚Ä¢ Graph traversal is fundamental to most graph algorithms<br>
                ‚Ä¢ Choose DFS for simplicity and memory efficiency<br>
                ‚Ä¢ Choose BFS for shortest paths and level-wise processing<br>
                ‚Ä¢ Always consider the graph's structure and problem requirements<br>
                ‚Ä¢ Practice implementing both algorithms until they become second nature
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
</body>
</html>