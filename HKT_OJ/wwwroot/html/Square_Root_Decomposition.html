<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Square Root Decomposition</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet">
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']]
            }
        };
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-weight: 600;
            line-height: 1.7;
            color: #2c3e50;
            background: white;
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 40px 20px;
            animation: fadeInUp 0.8s ease-out;
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        h1 {
            font-size: 3.5rem;
            font-weight: 800;
            color: #2c3e50;
            text-align: center;
            margin-bottom: 50px;
            position: relative;
            animation: slideInDown 1s ease-out;
        }

        @keyframes slideInDown {
            from {
                opacity: 0;
                transform: translateY(-50px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        h1::after {
            content: '';
            display: block;
            width: 380px;
            height: 4px;
            background: linear-gradient(90deg, #3498db, #2980b9);
            margin: 20px auto;
            border-radius: 2px;
            animation: expandLine 1.2s ease-out 0.5s both;
        }

        @keyframes expandLine {
            from {
                width: 0;
            }
            to {
                width: 380px;
            }
        }

        h2 {
            font-size: 2.4rem;
            font-weight: 700;
            color: #34495e;
            margin-top: 60px;
            margin-bottom: 25px;
            border-left: 5px solid #3498db;
            padding-left: 20px;
            animation: slideInLeft 0.6s ease-out;
        }

        @keyframes slideInLeft {
            from {
                opacity: 0;
                transform: translateX(-30px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        h3 {
            font-size: 1.9rem;
            font-weight: 700;
            color: #2c3e50;
            margin-top: 40px;
            margin-bottom: 20px;
            position: relative;
        }

        h3::before {
            content: '‚ö°';
            margin-right: 10px;
            font-size: 0.9em;
        }

        p {
            font-size: 1.15rem;
            font-weight: 600;
            margin-bottom: 25px;
            text-align: justify;
            line-height: 1.8;
        }

        ul {
            margin: 25px 0;
            padding-left: 0;
        }

        li {
            font-size: 1.15rem;
            font-weight: 600;
            margin-bottom: 15px;
            line-height: 1.8;
            list-style: none;
            position: relative;
            padding-left: 30px;
        }

        li::before {
            content: 'üí°';
            position: absolute;
            left: 0;
            top: 0;
        }

        .code-container {
            background: #1e1e1e;
            border-radius: 12px;
            margin: 30px 0;
            overflow: hidden;
            box-shadow: 0 8px 25px rgba(0,0,0,0.15);
            border: 1px solid #333;
            animation: fadeIn 0.8s ease-out;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }

        .code-header {
            background: linear-gradient(90deg, #2c3e50, #34495e);
            color: white;
            padding: 12px 20px;
            font-weight: 700;
            font-size: 0.9rem;
            border-bottom: 1px solid #444;
        }

        pre {
            margin: 0 !important;
            background: #1e1e1e !important;
            border-radius: 0 !important;
        }

        code {
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace !important;
            font-size: 0.95rem !important;
            line-height: 1.6 !important;
            font-weight: 500 !important;
        }

        .line-numbers-rows {
            border-right: 1px solid #444 !important;
            padding-right: 10px !important;
            margin-right: 15px !important;
        }

        .complexity {
            background: linear-gradient(135deg, #e8f4fd, #d6eaff);
            padding: 20px 25px;
            border-radius: 12px;
            border-left: 4px solid #3498db;
            margin: 25px 0;
            font-weight: 700;
            box-shadow: 0 4px 15px rgba(52, 152, 219, 0.1);
        }

        .warning {
            background: linear-gradient(135deg, #fff3cd, #ffeaa7);
            padding: 20px 25px;
            border-radius: 12px;
            border-left: 4px solid #ffc107;
            margin: 25px 0;
            font-weight: 700;
            box-shadow: 0 4px 15px rgba(255, 193, 7, 0.1);
        }

        .warning::before {
            content: '‚ö†Ô∏è ';
            font-size: 1.2em;
        }

        .section {
            margin-bottom: 50px;
            padding: 35px;
            background: #fafbfc;
            border-radius: 15px;
            border: 1px solid #e1e8ed;
            animation: slideInUp 0.6s ease-out;
        }

        @keyframes slideInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .focus-problem {
            background: linear-gradient(135deg, #e8f4fd, #d6eaff);
            padding: 25px;
            border-radius: 15px;
            margin: 30px 0;
            border: 2px solid #3498db;
            text-align: center;
            font-weight: 700;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% {
                box-shadow: 0 0 0 0 rgba(52, 152, 219, 0.4);
            }
            70% {
                box-shadow: 0 0 0 10px rgba(52, 152, 219, 0);
            }
            100% {
                box-shadow: 0 0 0 0 rgba(52, 152, 219, 0);
            }
        }

        .highlight {
            background: linear-gradient(120deg, #d6eaff 0%, #74b9ff 100%);
            padding: 3px 8px;
            border-radius: 6px;
            font-weight: 800;
        }

        .hover-effect {
            transition: all 0.3s ease;
        }

        .hover-effect:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 35px rgba(0,0,0,0.15);
        }

        .definition-box {
            background: linear-gradient(135deg, #e8f4fd, #d6eaff);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 4px solid #3498db;
            font-weight: 700;
        }

        .definition-box::before {
            content: 'üìö Definition: ';
            font-weight: 800;
            color: #2980b9;
        }

        .algorithm-box {
            background: linear-gradient(135deg, #e8f5e8, #d4edda);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 4px solid #28a745;
            font-weight: 700;
        }

        .algorithm-box::before {
            content: '‚ö° Key Insight: ';
            font-weight: 800;
            color: #155724;
        }

        .technique-box {
            background: linear-gradient(135deg, #fff0e6, #ffe4cc);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 4px solid #e67e22;
            font-weight: 700;
        }

        .technique-box::before {
            content: 'üß† Technique: ';
            font-weight: 800;
            color: #c0392b;
        }

        .optimization-box {
            background: linear-gradient(135deg, #fef3c7, #fbbf24);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 4px solid #f59e0b;
            font-weight: 700;
        }

        .optimization-box::before {
            content: '‚ö° Optimization: ';
            font-weight: 800;
            color: #92400e;
        }

        .applications-box {
            background: linear-gradient(135deg, #f0f4f8, #ddd6fe);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 4px solid #8b5cf6;
            font-weight: 700;
        }

        .applications-box::before {
            content: 'üìñ Applications: ';
            font-weight: 800;
            color: #7c3aed;
        }

        .math-display {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            margin: 25px 0;
            text-align: center;
            border: 2px solid #e9ecef;
            font-size: 1.2rem;
        }

        .solution-header {
            color: #3498db;
            font-weight: 800;
            border-bottom: 3px solid #3498db;
            padding-bottom: 8px;
            display: inline-block;
            margin-bottom: 20px;
        }

        .problem-patterns {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 20px;
            margin: 30px 0;
        }

        .pattern-card {
            background: white;
            border-radius: 12px;
            padding: 25px;
            border-left: 4px solid #3498db;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            transition: transform 0.3s ease;
        }

        .pattern-card:hover {
            transform: translateY(-5px);
        }

        .pattern-card:nth-child(1) {
            border-left-color: #e74c3c;
        }

        .pattern-card:nth-child(2) {
            border-left-color: #3498db;
        }

        .pattern-card:nth-child(3) {
            border-left-color: #2ecc71;
        }

        .pattern-title {
            font-weight: 800;
            color: #3498db;
            margin-bottom: 15px;
            font-size: 1.3rem;
        }

        .pattern-card:nth-child(1) .pattern-title {
            color: #e74c3c;
        }

        .pattern-card:nth-child(2) .pattern-title {
            color: #3498db;
        }

        .pattern-card:nth-child(3) .pattern-title {
            color: #2ecc71;
        }

        .step-by-step {
            background: linear-gradient(135deg, #fef7ff, #f3e8ff);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 4px solid #a855f7;
            font-weight: 700;
        }

        .step-by-step::before {
            content: 'üìù Algorithm Steps: ';
            font-weight: 800;
            color: #7c2d12;
        }

        .combining-box {
            background: linear-gradient(135deg, #e0f2fe, #b3e5fc);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 4px solid #0288d1;
            font-weight: 700;
        }

        .combining-box::before {
            content: 'üîß Combining Algorithms: ';
            font-weight: 800;
            color: #01579b;
        }

        .batching-box {
            background: linear-gradient(135deg, #f3e5f5, #e1bee7);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 4px solid #9c27b0;
            font-weight: 700;
        }

        .batching-box::before {
            content: 'üì¶ Batching: ';
            font-weight: 800;
            color: #6a1b9a;
        }

        .mo-algorithm-box {
            background: linear-gradient(135deg, #ffebee, #ffcdd2);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 4px solid #f44336;
            font-weight: 700;
        }

        .mo-algorithm-box::before {
            content: 'üîÑ Mo\'s Algorithm: ';
            font-weight: 800;
            color: #d32f2f;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Square Root Decomposition</h1>
        
        <div class="section hover-effect">
            <h2>Introduction to Square Root Decomposition</h2>
            
            <p>Square Root Decomposition is a powerful technique for solving range query problems efficiently. It strikes a balance between simplicity and performance by partitioning data into blocks of size approximately ‚àöN, allowing us to answer queries and perform updates in O(‚àöN) time complexity.</p>

            <div class="definition-box">
                Square Root Decomposition is a data structure optimization technique that divides an array into ‚àöN blocks of size ‚àöN each. This partitioning enables efficient range queries and updates by combining block-level operations with element-level operations.
            </div>

            <div class="applications-box">
                <strong>Primary Applications:</strong><br>
                ‚Ä¢ <strong>Range Sum Queries:</strong> Calculate sum of elements in any range [L,R]<br>
                ‚Ä¢ <strong>Range Maximum/Minimum:</strong> Find extrema in ranges efficiently<br>
                ‚Ä¢ <strong>Point Updates:</strong> Modify individual elements in O(1) time<br>
                ‚Ä¢ <strong>Frequency Queries:</strong> Count occurrences within ranges<br>
                ‚Ä¢ <strong>Offline Query Processing:</strong> Optimize query ordering for better performance
            </div>

            <div class="algorithm-box">
                <strong>Why Square Root Decomposition?</strong> This technique provides an excellent middle ground between naive O(N) approaches and complex data structures like segment trees. It's particularly useful when you need a simple, intuitive solution that still performs well on competitive programming problems.
            </div>
        </div>

        <div class="section hover-effect">
            <h2>Blocking Technique</h2>
            
            <p>The core idea behind square root decomposition is to partition the array into blocks of size $\texttt{block\_size}=\lceil \sqrt{N} \rceil$. Each block stores the sum of elements within it, enabling efficient update and query operations.</p>

            <div class="technique-box">
                <strong>Block Structure:</strong> We divide array of size N into approximately ‚àöN blocks, each containing ‚àöN elements. Each block maintains a summary value (like sum, maximum, or minimum) for quick access to aggregate information.
            </div>

            <h3>Update Queries</h3>
            <div class="complexity">Time Complexity: $\mathcal{O}(1)$</div>
            <p>To update an element at location $x$, we first find the corresponding block using the formula $\frac{x}{\texttt{block\_size}}$. Then, we apply the difference between the current element and the new value to both the array and the block sum.</p>

            <div class="step-by-step">
                <strong>Update Algorithm:</strong><br>
                <strong>1.</strong> Find the block containing position x: block_id = x / block_size<br>
                <strong>2.</strong> Update the block sum: blocks[block_id] -= old_value<br>
                <strong>3.</strong> Update the array element: nums[x] = new_value<br>
                <strong>4.</strong> Update the block sum: blocks[block_id] += new_value
            </div>

            <h3>Sum Queries</h3>
            <div class="complexity">Time Complexity: $\mathcal{O}(\sqrt{N})$</div>
            <p>To perform a sum query from $[0\ldots r]$, we calculate:</p>
            
            <div class="math-display">
                $$\sum_{i = 0}^{R-1} \texttt{blocks}[i] + \sum_{R \cdot \texttt{block\_size}}^r \texttt{nums}[i]$$
            </div>

            <p>where $\texttt{blocks}[i]$ represents the total sum of the $i$-th block, and $R=\left\lceil \frac{r}{\texttt{block\_size}} \right\rceil$.</p>

            <div class="algorithm-box">
                <strong>Query Strategy:</strong> For range queries, we sum complete blocks in the middle and handle partial blocks at the ends element by element. This gives us the optimal ‚àöN complexity by minimizing the number of operations.
            </div>

            <h3 class="solution-header">Square Root Decomposition Implementation</h3>

            <div class="code-container">
                <div class="code-header">C++ - Square Root Decomposition</div>
                <pre class="line-numbers"><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;

struct Sqrt {
    int block_size;
    vector&lt;int&gt; nums;
    vector&lt;long long&gt; blocks;
    
    Sqrt(int sqrtn, vector&lt;int&gt; &arr) : block_size(sqrtn), blocks(sqrtn, 0) {
        nums = arr;
        for (int i = 0; i &lt; nums.size(); i++) { 
            blocks[i / block_size] += nums[i]; 
        }
    }

    /** O(1) update to set nums[x] to v */
    void update(int x, int v) {
        blocks[x / block_size] -= nums[x];
        nums[x] = v;
        blocks[x / block_size] += nums[x];
    }

    /** O(sqrt(n)) query for sum of [0, r) */
    long long query(int r) {
        long long res = 0;
        for (int i = 0; i &lt; r / block_size; i++) { 
            res += blocks[i]; 
        }
        for (int i = (r / block_size) * block_size; i &lt; r; i++) { 
            res += nums[i]; 
        }
        return res;
    }

    /** O(sqrt(n)) query for sum of [l, r) */
    long long query(int l, int r) { 
        return query(r) - query(l); 
    }
};

int main() {
    int n, q;
    cin &gt;&gt; n &gt;&gt; q;

    vector&lt;int&gt; arr(n);
    for (int i = 0; i &lt; n; i++) { 
        cin &gt;&gt; arr[i]; 
    }
    Sqrt sq((int)ceil(sqrt(n)), arr);

    for (int i = 0; i &lt; q; i++) {
        int t, l, r;
        cin &gt;&gt; t &gt;&gt; l &gt;&gt; r;
        if (t == 1) {
            sq.update(l - 1, r);
        } else {
            cout &lt;&lt; sq.query(l, r) &lt;&lt; "\n";
        }
    }
}</code></pre>
            </div>
        </div>

        <div class="section hover-effect">
            <h2>Combining Algorithms</h2>
            
            <div class="focus-problem">
                <strong>üéØ Focus Problem:</strong> Hop Sugoroku (AtCoder - Medium)<br>
                Optimize DP with square root decomposition techniques!
            </div>

            <p>This problem demonstrates how square root decomposition can be combined with other techniques to optimize time complexity from $\mathcal{O}(N^2)$ to $\mathcal{O}(N\sqrt{N})$.</p>

            <div class="combining-box">
                <strong>Hybrid Approach:</strong> By strategically applying different algorithms based on the size of operations, we can achieve better overall complexity. Use DP for large jumps and prefix sums for small jumps.
            </div>

            <h3>Naive DP Approach</h3>
            <div class="complexity">Time Complexity: $\mathcal{O}(N^2)$</div>

            <div class="code-container">
                <div class="code-header">C++ - Naive DP (Too Slow)</div>
                <pre class="line-numbers"><code class="language-cpp">vector&lt;int&gt; dp(n, 1);
for (int i = n - 1; i &gt;= 0; i--) {
    for (int x = i + a[i]; x &lt;= n; x += a[i]) { 
        dp[i] = (dp[i] + dp[x]) % MOD; 
    }
}</code></pre>
            </div>

            <h3>Optimized Combined Approach</h3>
            <div class="complexity">Time Complexity: $\mathcal{O}(N\sqrt{N})$</div>

            <div class="optimization-box">
                <strong>Key Optimization:</strong> Split the algorithm based on jump size. For large jumps (‚â• ‚àöN), use DP since few iterations are needed. For small jumps (< ‚àöN), use prefix sums to avoid repeated calculations.
            </div>

            <div class="step-by-step">
                <strong>Algorithm Steps:</strong><br>
                <strong>1.</strong> Set threshold x = ‚àöN<br>
                <strong>2.</strong> For positions with a[i] > x: Use DP (large jumps, few iterations)<br>
                <strong>3.</strong> For positions with a[i] ‚â§ x: Use prefix sum optimization<br>
                <strong>4.</strong> Maintain prefix sums for all jump sizes ‚â§ x<br>
                <strong>5.</strong> Update prefix sums as we process each position
            </div>

            <div class="code-container">
                <div class="code-header">C++ - Optimized Combined Approach</div>
                <pre class="line-numbers"><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;

const int MOD = 998244353;

int main() {
    int n;
    cin &gt;&gt; n;
    vector&lt;int&gt; a(n);
    for (int i = 0; i &lt; n; i++) { 
        cin &gt;&gt; a[i]; 
    }

    int x = (int)sqrt(n);
    vector&lt;int&gt; dp(n, 1);
    vector&lt;vector&lt;int&gt;&gt; s(x + 1, vector&lt;int&gt;(x + 1));
    
    for (int i = n - 1; i &gt;= 0; i--) {
        if (a[i] &gt; x) {
            // Use DP for large jumps
            for (int j = i + a[i]; j &lt; n; j += a[i]) {
                dp[i] += dp[j];
                dp[i] %= MOD;
            }
        } else {
            // Use prefix sums for small jumps
            dp[i] += s[a[i]][i % a[i]];
            dp[i] %= MOD;
        }
        
        // Update prefix sums for all small jump sizes
        for (int j = 1; j &lt;= x; j++) {
            s[j][i % j] += dp[i];
            s[j][i % j] %= MOD;
        }
    }

    cout &lt;&lt; dp[0] &lt;&lt; endl;
}</code></pre>
            </div>

            <div class="algorithm-box">
                <strong>Why This Works:</strong> Large jumps result in fewer total iterations across all positions, while small jumps benefit from prefix sum optimization. The ‚àöN threshold perfectly balances these two approaches.
            </div>
        </div>

        <div class="section hover-effect">
            <h2>Batching Technique</h2>

            <p>Batching is another square root decomposition technique that maintains a "buffer" of recent updates. This approach is particularly effective for problems with mixed update and query operations.</p>

            <div class="batching-box">
                <strong>Batching Strategy:</strong> Instead of immediately applying every update, we buffer them and only rebuild our data structure when the buffer gets too large (‚â• ‚àöN). This amortizes the rebuilding cost across multiple operations.
            </div>

            <div class="step-by-step">
                <strong>Batching Algorithm:</strong><br>
                <strong>1.</strong> Maintain a buffer of recent updates (up to ‚àöN)<br>
                <strong>2.</strong> For queries: Use precomputed data + scan through buffer<br>
                <strong>3.</strong> For updates: Add to buffer<br>
                <strong>4.</strong> When buffer reaches ‚àöN: Apply all updates and rebuild<br>
                <strong>5.</strong> Clear buffer and continue
            </div>

            <div class="complexity">
                <strong>Amortized Complexity: $\mathcal{O}(\sqrt{N})$ per operation</strong><br>
                Each operation takes O(‚àöN) time, but rebuilding cost is amortized.
            </div>

            <div class="code-container">
                <div class="code-header">C++ - Batching Implementation</div>
                <pre class="line-numbers"><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;

int n, q;
vector&lt;int&gt; arr;
vector&lt;long long&gt; prefix;

/** Build the prefix array for arr */
void build() {
    prefix[0] = 0;
    for (int i = 1; i &lt;= n; i++) { 
        prefix[i] = prefix[i - 1] + arr[i - 1]; 
    }
}

int main() {
    cin &gt;&gt; n &gt;&gt; q;
    arr.resize(n);
    for (int i = 0; i &lt; n; i++) { 
        cin &gt;&gt; arr[i]; 
    }
    prefix.assign(n + 1, 0);
    build();

    vector&lt;pair&lt;int, int&gt;&gt; updates;
    
    for (int i = 0; i &lt; q; i++) {
        int type, a, b;
        cin &gt;&gt; type &gt;&gt; a &gt;&gt; b;
        
        if (type == 1) {
            // Update operation
            a--;
            updates.push_back({a, b - arr[a]});
            arr[a] = b;
        } else {
            // Query operation
            long long ans = prefix[b] - prefix[a - 1];
            a--, b--;
            
            // Apply buffered updates
            for (const auto &[idx, val] : updates) {
                if (a &lt;= idx && idx &lt;= b) { 
                    ans += val; 
                }
            }
            cout &lt;&lt; ans &lt;&lt; "\n";
        }

        // Rebuild when buffer gets too large
        if (updates.size() * updates.size() &gt;= n) {
            updates.clear();
            build();
        }
    }
}</code></pre>
            </div>

            <div class="optimization-box">
                <strong>Performance Insight:</strong> The key insight is that scanning ‚àöN buffered updates is acceptable since it only happens ‚àöN times before we rebuild. This gives us the best of both worlds: fast queries most of the time, with periodic cleanup.
            </div>
        </div>

        <div class="section hover-effect">
            <h2>Mo's Algorithm</h2>

            <p>Mo's Algorithm is an elegant offline query processing technique that uses square root decomposition to answer range queries efficiently. It's particularly powerful for problems where we can incrementally add or remove elements from our current range.</p>

            <div class="focus-problem">
                <strong>üéØ Focus Problem:</strong> D-query (SPOJ - Hard)<br>
                Count distinct elements in range queries efficiently!
            </div>

            <div class="mo-algorithm-box">
                <strong>Mo's Algorithm Core Idea:</strong> Instead of processing queries in order, we sort them in a special way that minimizes the total movement of our sliding window. This transforms many difficult range query problems into manageable ones.
            </div>

            <h3>Algorithm Strategy</h3>

            <div class="step-by-step">
                <strong>Mo's Algorithm Steps:</strong><br>
                <strong>1.</strong> Divide array into ‚àöN blocks<br>
                <strong>2.</strong> Sort queries by (left_block, right_endpoint)<br>
                <strong>3.</strong> Process queries in sorted order<br>
                <strong>4.</strong> Maintain sliding window [curr_left, curr_right]<br>
                <strong>5.</strong> Expand/contract window to match each query<br>
                <strong>6.</strong> Use add() and remove() functions for incremental updates
            </div>

            <div class="complexity">
                <strong>Time Complexity: $\mathcal{O}((N + Q)\sqrt{N})$</strong><br>
                The special sorting ensures total window movement is bounded by O((N + Q)‚àöN).
            </div>

            <div class="algorithm-box">
                <strong>Why Mo's Works:</strong> The clever query sorting ensures that our sliding window doesn't move too far overall. Within each block, right endpoints are sorted, and between blocks, left endpoints increase by at most ‚àöN.
            </div>

            <h3 class="solution-header">Mo's Algorithm Implementation</h3>

            <div class="code-container">
                <div class="code-header">C++ - Mo's Algorithm for D-query</div>
                <pre class="line-numbers"><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;

struct Query {
    int l, r, idx;
};

int main() {
    int n;
    cin &gt;&gt; n;
    vector&lt;int&gt; v(n);
    for (int i = 0; i &lt; n; i++) { 
        cin &gt;&gt; v[i]; 
    }

    int q;
    cin &gt;&gt; q;
    vector&lt;Query&gt; queries;
    for (int i = 0; i &lt; q; i++) {
        int x, y;
        cin &gt;&gt; x &gt;&gt; y;
        queries.push_back({--x, --y, i});
    }

    // Sort queries by Mo's comparator
    int block_size = (int)sqrt(n);
    auto mo_cmp = [&](Query a, Query b) {
        int block_a = a.l / block_size;
        int block_b = b.l / block_size;
        if (block_a == block_b) { 
            return a.r &lt; b.r; 
        }
        return block_a &lt; block_b;
    };
    sort(queries.begin(), queries.end(), mo_cmp);

    // Mo's algorithm state
    int different_values = 0;
    vector&lt;int&gt; values(1000001);
    
    auto remove = [&](int idx) {
        values[v[idx]]--;
        if (values[v[idx]] == 0) { 
            different_values--; 
        }
    };
    
    auto add = [&](int idx) {
        values[v[idx]]++;
        if (values[v[idx]] == 1) { 
            different_values++; 
        }
    };

    int mo_left = -1;
    int mo_right = -1;
    vector&lt;int&gt; ans(q);
    
    for (int i = 0; i &lt; q; i++) {
        int left = queries[i].l;
        int right = queries[i].r;

        // Expand/contract the window
        while (mo_left &lt; left) { remove(mo_left++); }
        while (mo_left &gt; left) { add(--mo_left); }
        while (mo_right &lt; right) { add(++mo_right); }
        while (mo_right &gt; right) { remove(mo_right--); }

        ans[queries[i].idx] = different_values;
    }

    for (int i = 0; i &lt; q; i++) { 
        cout &lt;&lt; ans[i] &lt;&lt; '\n'; 
    }
}</code></pre>
            </div>

            <div class="optimization-box">
                <strong>Implementation Details:</strong> Notice how we store the original query indices to output answers in the correct order. The add/remove lambda functions maintain our problem-specific state (distinct count) incrementally.
            </div>
        </div>

        <div class="section hover-effect">
            <h2>Advanced Applications and Optimizations</h2>

            <h3>Problem Recognition Patterns</h3>

            <div class="problem-patterns">
                <div class="pattern-card">
                    <div class="pattern-title">üéØ Blocking Problems</div>
                    <p><strong>Pattern:</strong> Range queries with point updates<br>
                    <strong>Signals:</strong> Simple operations, moderate constraints<br>
                    <strong>Examples:</strong> Range sum, range maximum, frequency queries</p>
                </div>
                
                <div class="pattern-card">
                    <div class="pattern-title">üìä Mo's Algorithm Problems</div>
                    <p><strong>Pattern:</strong> Offline range queries, incremental state<br>
                    <strong>Signals:</strong> Can add/remove elements efficiently<br>
                    <strong>Examples:</strong> Distinct elements, GCD queries, color counting</p>
                </div>
                
                <div class="pattern-card">
                    <div class="pattern-title">üîß Hybrid Techniques</div>
                    <p><strong>Pattern:</strong> Combine multiple algorithms<br>
                    <strong>Signals:</strong> Different optimal strategies for different cases<br>
                    <strong>Examples:</strong> DP + prefix sums, large vs small parameters</p>
                </div>
            </div>

            <h3>Parameter Optimization</h3>

            <div class="optimization-box">
                <strong>Block Size Tuning:</strong> While ‚àöN is theoretically optimal, practical performance may benefit from different block sizes. Consider factors like cache size, memory access patterns, and specific operation costs.
            </div>

            <div class="warning">
                <strong>Common Pitfalls:</strong><br>
                ‚Ä¢ Don't forget to handle edge cases in Mo's algorithm (empty ranges)<br>
                ‚Ä¢ Be careful with integer overflow in sum queries<br>
                ‚Ä¢ Consider memory constraints when using large frequency arrays<br>
                ‚Ä¢ Test both small and large block sizes for optimal performance<br>
                ‚Ä¢ Remember that Mo's algorithm requires offline processing
            </div>

            <h3>Advanced Optimizations</h3>

            <div class="technique-box">
                <strong>Mo's Algorithm Optimizations:</strong><br>
                ‚Ä¢ <strong>Hilbert Order:</strong> Use space-filling curves for better cache locality<br>
                ‚Ä¢ <strong>Block Size Tuning:</strong> Adjust block size based on add/remove costs<br>
                ‚Ä¢ <strong>Rollback Mo's:</strong> Handle updates that are hard to reverse<br>
                ‚Ä¢ <strong>Tree Mo's:</strong> Extend to tree path queries<br>
                ‚Ä¢ <strong>Parallel Processing:</strong> Process independent blocks simultaneously
            </div>

            <div class="applications-box">
                <strong>Real-World Applications:</strong><br>
                ‚Ä¢ <strong>Database Systems:</strong> Range queries with infrequent updates<br>
                ‚Ä¢ <strong>Analytics Platforms:</strong> Aggregation queries over time windows<br>
                ‚Ä¢ <strong>Game Development:</strong> Spatial queries in game worlds<br>
                ‚Ä¢ <strong>Scientific Computing:</strong> Statistical queries over large datasets<br>
                ‚Ä¢ <strong>Network Monitoring:</strong> Traffic analysis over time ranges
            </div>

            <h3>When to Use Square Root Decomposition</h3>

            <div class="algorithm-box">
                <strong>Decision Guidelines:</strong><br>
                ‚Ä¢ <strong>Use Blocking when:</strong> Simple queries/updates, want easy implementation<br>
                ‚Ä¢ <strong>Use Mo's when:</strong> Offline queries, incremental state updates possible<br>
                ‚Ä¢ <strong>Use Batching when:</strong> Mixed operations, update frequency varies<br>
                ‚Ä¢ <strong>Consider alternatives when:</strong> Need online queries, very high performance requirements
            </div>
        </div>

        <div class="section hover-effect">
            <h2>Additional Notes & Best Practices</h2>
            
            <div class="warning">
                <strong>Constraint Recognition:</strong> Low constraints (e.g., n = 5√ó10‚Å¥) and/or high time limits (greater than 2s) can be signs that square root decomposition is the intended solution approach.
            </div>

            <h3>Implementation Best Practices</h3>

            <div class="technique-box">
                <strong>Code Organization Tips:</strong><br>
                ‚Ä¢ <strong>Modular Design:</strong> Separate update and query logic clearly<br>
                ‚Ä¢ <strong>Template Classes:</strong> Make your implementations reusable<br>
                ‚Ä¢ <strong>Debug Functions:</strong> Include verification methods for testing<br>
                ‚Ä¢ <strong>Const Correctness:</strong> Use const for read-only operations<br>
                ‚Ä¢ <strong>Memory Management:</strong> Consider memory usage for large problems
            </div>

            <div class="optimization-box">
                <strong>Performance Considerations:</strong><br>
                In practice, it's not necessary to use the exact value of ‚àön as a parameter. Instead, we may use parameters k and n/k where k differs from ‚àön. The optimal parameter depends on the specific problem and input characteristics.
            </div>

            <div class="step-by-step">
                <strong>Parameter Selection Guidelines:</strong><br>
                <strong>1.</strong> If operations frequently process blocks but rarely inspect individual elements: Use k < ‚àön<br>
                <strong>2.</strong> If updates take O(n/k) time and queries take O(k log n) time: Set k ‚âà ‚àö(n/log n)<br>
                <strong>3.</strong> For memory-constrained environments: Consider smaller block sizes<br>
                <strong>4.</strong> For cache optimization: Align block size with cache line size<br>
                <strong>5.</strong> Always benchmark different values for critical applications
            </div>

            <h3>Complexity Analysis Insights</h3>

            <div class="complexity">
                <strong>Reality Check:</strong> Solutions with worse theoretical complexities are not necessarily slower in practice (at least for problems with reasonable input sizes, e.g., n ‚â§ 5√ó10‚Åµ). Constant factors are important!
            </div>

            <div class="algorithm-box">
                <strong>Performance Paradox:</strong> Sometimes a fast O(n‚àön log n) solution passes (where log n comes from a Binary Indexed Tree) while a theoretically better O(n‚àön) solution does not. This highlights the importance of implementation efficiency and constant factors.
            </div>

            <div class="code-container">
                <div class="code-header">C++ - Template for Testing Different Block Sizes</div>
                <pre class="line-numbers"><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;

class BenchmarkSqrt {
private:
    vector&lt;int&gt; data;
    int n;
    
public:
    BenchmarkSqrt(vector&lt;int&gt;&amp; arr) : data(arr), n(arr.size()) {}
    
    void test_block_size(int block_size) {
        auto start = chrono::high_resolution_clock::now();
        
        // Run your square root decomposition with this block size
        vector&lt;long long&gt; blocks(n / block_size + 1, 0);
        for (int i = 0; i &lt; n; i++) {
            blocks[i / block_size] += data[i];
        }
        
        // Simulate some queries
        long long total = 0;
        for (int i = 0; i &lt; 1000; i++) {
            int l = rand() % n;
            int r = rand() % n;
            if (l &gt; r) swap(l, r);
            
            // Query [l, r]
            long long result = 0;
            for (int j = l / block_size + 1; j &lt; r / block_size; j++) {
                result += blocks[j];
            }
            for (int j = l; j &lt; min(r + 1, (l / block_size + 1) * block_size); j++) {
                result += data[j];
            }
            for (int j = max(l, (r / block_size) * block_size); j &lt;= r; j++) {
                result += data[j];
            }
            total += result;
        }
        
        auto end = chrono::high_resolution_clock::now();
        auto duration = chrono::duration_cast&lt;chrono::microseconds&gt;(end - start);
        
        cout &lt;&lt; "Block size " &lt;&lt; block_size &lt;&lt; ": " &lt;&lt; duration.count() &lt;&lt; " Œºs" &lt;&lt; endl;
    }
    
    void benchmark() {
        vector&lt;int&gt; block_sizes = {
            (int)sqrt(n) / 2,
            (int)sqrt(n),
            (int)sqrt(n) * 2,
            (int)sqrt(n * log(n)),
            100, 500, 1000  // Fixed sizes for comparison
        };
        
        for (int bs : block_sizes) {
            if (bs &gt; 0 && bs &lt;= n) {
                test_block_size(bs);
            }
        }
    }
};</code></pre>
            </div>
        </div>

        <div class="section hover-effect">
            <h2>Summary and Key Takeaways</h2>

            <div class="definition-box">
                Square Root Decomposition provides an elegant balance between implementation simplicity and algorithmic efficiency. By partitioning data into ‚àöN blocks, we achieve O(‚àöN) complexity for most operations while maintaining intuitive, easy-to-implement solutions.
            </div>

            <div class="problem-patterns">
                <div class="pattern-card">
                    <div class="pattern-title">What You've Mastered</div>
                    <ul style="padding-left: 20px; list-style: disc;">
                        <li>Basic blocking for range queries and point updates</li>
                        <li>Algorithm combination techniques for optimization</li>
                        <li>Batching strategies for mixed operation workloads</li>
                        <li>Mo's algorithm for offline query processing</li>
                        <li>Parameter tuning and performance optimization</li>
                    </ul>
                </div>
                <div class="pattern-card">
                    <div class="pattern-title">Advanced Applications</div>
                    <ul style="padding-left: 20px; list-style: disc;">
                        <li>Hybrid DP + prefix sum optimizations</li>
                        <li>Complex query sorting and processing</li>
                        <li>Real-world performance considerations</li>
                        <li>Memory-efficient implementations</li>
                        <li>Debugging and verification techniques</li>
                    </ul>
                </div>
            </div>

            <div class="focus-problem">
                <strong>üéØ Practice Challenge:</strong><br>
                Now that you understand square root decomposition, try solving "Range Updates and Sums," "Powerful Array," or "Tree and Queries" to practice these fundamental techniques in more complex scenarios!
            </div>

            <div class="applications-box">
                <strong>Real-World Impact:</strong> Square root decomposition techniques are fundamental in database query optimization, scientific computing applications, real-time analytics systems, and any domain requiring efficient range processing with moderate update frequencies.
            </div>

            <div class="algorithm-box">
                <strong>Key Insight:</strong> The beauty of square root decomposition lies in its simplicity and versatility. While segment trees and other advanced structures might offer better theoretical complexity, ‚àöN techniques often provide the best practical solution for competitive programming and real-world applications.
            </div>

            <div class="complexity">
                <strong>Final Complexity Summary:</strong><br>
                ‚Ä¢ <strong>Basic Blocking:</strong> O(1) updates, O(‚àöN) queries<br>
                ‚Ä¢ <strong>Mo's Algorithm:</strong> O((N+Q)‚àöN) total for Q offline queries<br>
                ‚Ä¢ <strong>Batching:</strong> O(‚àöN) amortized per operation<br>
                ‚Ä¢ <strong>Hybrid Techniques:</strong> Often O(N‚àöN) for complex problems
            </div>

            <div class="technique-box">
                <strong>Remember:</strong> Square root decomposition isn't just about the ‚àöN factor‚Äîit's about recognizing when to combine simple techniques for complex problems. The ability to break down algorithmic challenges into manageable ‚àöN-sized pieces is a fundamental skill for competitive programming success!
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
</body>
</html>