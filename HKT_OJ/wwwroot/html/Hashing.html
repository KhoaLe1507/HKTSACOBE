<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hashing</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet">
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']]
            }
        };
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-weight: 600;
            line-height: 1.7;
            color: #2c3e50;
            background: white;
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 40px 20px;
            animation: fadeInUp 0.8s ease-out;
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        h1 {
            font-size: 3.5rem;
            font-weight: 800;
            color: #2c3e50;
            text-align: center;
            margin-bottom: 50px;
            position: relative;
            animation: slideInDown 1s ease-out;
        }

        @keyframes slideInDown {
            from {
                opacity: 0;
                transform: translateY(-50px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        h1::after {
            content: '';
            display: block;
            width: 200px;
            height: 4px;
            background: linear-gradient(90deg, #f39c12, #f1c40f);
            margin: 20px auto;
            border-radius: 2px;
            animation: expandLine 1.2s ease-out 0.5s both;
        }

        @keyframes expandLine {
            from {
                width: 0;
            }
            to {
                width: 200px;
            }
        }

        h2 {
            font-size: 2.4rem;
            font-weight: 700;
            color: #34495e;
            margin-top: 60px;
            margin-bottom: 25px;
            border-left: 5px solid #f39c12;
            padding-left: 20px;
            animation: slideInLeft 0.6s ease-out;
        }

        @keyframes slideInLeft {
            from {
                opacity: 0;
                transform: translateX(-30px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        h3 {
            font-size: 1.9rem;
            font-weight: 700;
            color: #2c3e50;
            margin-top: 40px;
            margin-bottom: 20px;
            position: relative;
        }

        h3::before {
            content: 'üß†';
            margin-right: 10px;
            font-size: 0.9em;
        }

        p {
            font-size: 1.15rem;
            font-weight: 600;
            margin-bottom: 25px;
            text-align: justify;
            line-height: 1.8;
        }

        ul {
            margin: 25px 0;
            padding-left: 0;
        }

        li {
            font-size: 1.15rem;
            font-weight: 600;
            margin-bottom: 15px;
            line-height: 1.8;
            list-style: none;
            position: relative;
            padding-left: 30px;
        }

        li::before {
            content: 'üí°';
            position: absolute;
            left: 0;
            top: 0;
        }

        .code-container {
            background: #1e1e1e;
            border-radius: 12px;
            margin: 30px 0;
            overflow: hidden;
            box-shadow: 0 8px 25px rgba(0,0,0,0.15);
            border: 1px solid #333;
            animation: fadeIn 0.8s ease-out;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }

        .code-header {
            background: linear-gradient(90deg, #2c3e50, #34495e);
            color: white;
            padding: 12px 20px;
            font-weight: 700;
            font-size: 0.9rem;
            border-bottom: 1px solid #444;
        }

        pre {
            margin: 0 !important;
            background: #1e1e1e !important;
            border-radius: 0 !important;
        }

        code {
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace !important;
            font-size: 0.95rem !important;
            line-height: 1.6 !important;
            font-weight: 500 !important;
        }

        .line-numbers-rows {
            border-right: 1px solid #444 !important;
            padding-right: 10px !important;
            margin-right: 15px !important;
        }

        .complexity {
            background: linear-gradient(135deg, #fef9e7, #f9e79f);
            padding: 20px 25px;
            border-radius: 12px;
            border-left: 4px solid #f39c12;
            margin: 25px 0;
            font-weight: 700;
            box-shadow: 0 4px 15px rgba(243, 156, 18, 0.1);
        }

        .warning {
            background: linear-gradient(135deg, #fff3cd, #ffeaa7);
            padding: 20px 25px;
            border-radius: 12px;
            border-left: 4px solid #ffc107;
            margin: 25px 0;
            font-weight: 700;
            box-shadow: 0 4px 15px rgba(255, 193, 7, 0.1);
        }

        .warning::before {
            content: '‚ö†Ô∏è ';
            font-size: 1.2em;
        }

        .section {
            margin-bottom: 50px;
            padding: 35px;
            background: #fafbfc;
            border-radius: 15px;
            border: 1px solid #e1e8ed;
            animation: slideInUp 0.6s ease-out;
        }

        @keyframes slideInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .focus-problem {
            background: linear-gradient(135deg, #fef9e7, #f9e79f);
            padding: 25px;
            border-radius: 15px;
            margin: 30px 0;
            border: 2px solid #f39c12;
            text-align: center;
            font-weight: 700;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% {
                box-shadow: 0 0 0 0 rgba(243, 156, 18, 0.4);
            }
            70% {
                box-shadow: 0 0 0 10px rgba(243, 156, 18, 0);
            }
            100% {
                box-shadow: 0 0 0 0 rgba(243, 156, 18, 0);
            }
        }

        .highlight {
            background: linear-gradient(120deg, #f9e79f 0%, #74b9ff 100%);
            padding: 3px 8px;
            border-radius: 6px;
            font-weight: 800;
        }

        .hover-effect {
            transition: all 0.3s ease;
        }

        .hover-effect:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 35px rgba(0,0,0,0.15);
        }

        .definition-box {
            background: linear-gradient(135deg, #fef9e7, #f9e79f);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 4px solid #f39c12;
            font-weight: 700;
        }

        .definition-box::before {
            content: 'üìö Definition: ';
            font-weight: 800;
            color: #e67e22;
        }

        .algorithm-box {
            background: linear-gradient(135deg, #e8f5e8, #d4edda);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 4px solid #28a745;
            font-weight: 700;
        }

        .algorithm-box::before {
            content: '‚ö° Key Insight: ';
            font-weight: 800;
            color: #155724;
        }

        .solution-header {
            color: #f39c12;
            font-weight: 800;
            border-bottom: 3px solid #f39c12;
            padding-bottom: 8px;
            display: inline-block;
            margin-bottom: 20px;
        }

        .math-display {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            margin: 25px 0;
            text-align: center;
            border: 2px solid #e9ecef;
            font-size: 1.2rem;
        }

        .hashing-box {
            background: linear-gradient(135deg, #fef9e7, #f9e79f);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 4px solid #f39c12;
            font-weight: 700;
        }

        .hashing-box::before {
            content: 'üîê Hashing: ';
            font-weight: 800;
            color: #e67e22;
        }

        .step-by-step {
            background: linear-gradient(135deg, #fef7ff, #f3e8ff);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 4px solid #a855f7;
            font-weight: 700;
        }

        .step-by-step::before {
            content: 'üìù Algorithm Steps: ';
            font-weight: 800;
            color: #7c2d12;
        }

        .optimization-box {
            background: linear-gradient(135deg, #fef3c7, #fbbf24);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 4px solid #f59e0b;
            font-weight: 700;
        }

        .optimization-box::before {
            content: '‚ö° Optimization: ';
            font-weight: 800;
            color: #92400e;
        }

        .hash-visualization {
            background: #f8f9fa;
            padding: 30px;
            border-radius: 12px;
            margin: 30px 0;
            text-align: center;
            border: 2px solid #e9ecef;
        }

        .applications-box {
            background: linear-gradient(135deg, #f0f4f8, #ddd6fe);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 4px solid #8b5cf6;
            font-weight: 700;
        }

        .applications-box::before {
            content: 'üìñ Applications: ';
            font-weight: 800;
            color: #7c3aed;
        }

        .problem-patterns {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 20px;
            margin: 30px 0;
        }

        .pattern-card {
            background: white;
            border-radius: 12px;
            padding: 25px;
            border-left: 4px solid #f39c12;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            transition: transform 0.3s ease;
        }

        .pattern-card:hover {
            transform: translateY(-5px);
        }

        .pattern-card:nth-child(1) {
            border-left-color: #e74c3c;
        }

        .pattern-card:nth-child(2) {
            border-left-color: #3498db;
        }

        .pattern-card:nth-child(3) {
            border-left-color: #2ecc71;
        }

        .pattern-title {
            font-weight: 800;
            color: #f39c12;
            margin-bottom: 15px;
            font-size: 1.3rem;
        }

        .pattern-card:nth-child(1) .pattern-title {
            color: #e74c3c;
        }

        .pattern-card:nth-child(2) .pattern-title {
            color: #3498db;
        }

        .pattern-card:nth-child(3) .pattern-title {
            color: #2ecc71;
        }

        .polynomial-hash-box {
            background: linear-gradient(135deg, #e3f2fd, #bbdefb);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 4px solid #2196f3;
            font-weight: 700;
        }

        .polynomial-hash-box::before {
            content: 'üìê Polynomial Hash: ';
            font-weight: 800;
            color: #1976d2;
        }

        .collision-probability-box {
            background: linear-gradient(135deg, #ffebee, #ffcdd2);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 4px solid #f44336;
            font-weight: 700;
        }

        .collision-probability-box::before {
            content: 'üìä Collision Analysis: ';
            font-weight: 800;
            color: #d32f2f;
        }

        .string-matching-box {
            background: linear-gradient(135deg, #e8f5e8, #d4edda);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 4px solid #28a745;
            font-weight: 700;
        }

        .string-matching-box::before {
            content: 'üîç String Matching: ';
            font-weight: 800;
            color: #155724;
        }

        .random-base-box {
            background: linear-gradient(135deg, #fff3e0, #ffe0b2);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 4px solid #ff9800;
            font-weight: 700;
        }

        .random-base-box::before {
            content: 'üé≤ Random Base: ';
            font-weight: 800;
            color: #f57c00;
        }

        .sliding-window-box {
            background: linear-gradient(135deg, #f3e5f5, #e1bee7);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 4px solid #9c27b0;
            font-weight: 700;
        }

        .sliding-window-box::before {
            content: 'ü™ü Sliding Window: ';
            font-weight: 800;
            color: #7b1fa2;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Hashing</h1>
        
        <div class="section hover-effect">
            <h2>Introduction to Hashing</h2>
            
            <p><span class="highlight">Hashing</span> is a fundamental technique in computer science that maps data of arbitrary size to fixed-size values. In competitive programming, hashing is primarily used for efficient string processing, substring comparisons, and pattern matching problems.</p>

            <div class="definition-box">
                Hashing transforms input data into a hash value (or hash code) using a hash function. The key property is that identical inputs always produce identical outputs, while different inputs should produce different outputs with high probability.
            </div>

            <div class="hashing-box">
                <strong>Core Concept:</strong> In string algorithms, we use polynomial hashing to convert strings into integers, enabling fast substring comparisons, pattern searching, and duplicate detection in O(1) time after O(n) preprocessing.
            </div>

            <div class="applications-box">
                <strong>Key Applications in CP:</strong><br>
                ‚Ä¢ <strong>String Matching:</strong> Find patterns in text efficiently<br>
                ‚Ä¢ <strong>Substring Comparison:</strong> Compare substrings in O(1) time<br>
                ‚Ä¢ <strong>Duplicate Detection:</strong> Find duplicate substrings or permutations<br>
                ‚Ä¢ <strong>Rolling Hash:</strong> Update hash values in sliding window problems<br>
                ‚Ä¢ <strong>Data Structures:</strong> Hash tables, hash sets for fast lookups
            </div>

            <div class="algorithm-box">
                <strong>Why Hashing Works:</strong> By converting strings to integers, we can perform comparisons in constant time instead of linear time. The trade-off is a small probability of hash collisions, which we minimize through careful choice of hash functions and parameters.
            </div>
        </div>

        <div class="section hover-effect">
            <h2>Polynomial Hashing Template</h2>
            
            <p>The most common hashing technique in competitive programming is <span class="highlight">polynomial hashing</span>. This method treats a string as a polynomial where each character contributes a term with increasing powers of a base.</p>

            <div class="polynomial-hash-box">
                <strong>Polynomial Hash Formula:</strong> For a string S of length n, the hash is computed as:<br>
                hash(S) = (S[0] √ó B^(n-1) + S[1] √ó B^(n-2) + ... + S[n-1] √ó B^0) mod M<br>
                where B is the base and M is the modulus.
            </div>

            <h3 class="solution-header">HashedString Implementation</h3>

            <div class="code-container">
                <div class="code-header">C++ - Polynomial Hashing Template</div>
                <pre class="line-numbers"><code class="language-cpp">class HashedString {
private:
    // change M and B if you want
    static const long long M = 1e9 + 9;
    static const long long B = 9973;

    // pow[i] contains B^i % M
    static vector&lt;long long&gt; pow;

    // p_hash[i] is the hash of the first i characters of the given string
    vector&lt;long long&gt; p_hash;

public:
    HashedString(const string &amp;s) : p_hash(s.size() + 1) {
        while (pow.size() &lt;= s.size()) { 
            pow.push_back((pow.back() * B) % M); 
        }

        p_hash[0] = 0;
        for (int i = 0; i &lt; s.size(); i++) {
            p_hash[i + 1] = ((p_hash[i] * B) % M + s[i]) % M;
        }
    }

    long long get_hash(int start, int end) {
        long long raw_val = (p_hash[end + 1] - (p_hash[start] * pow[end - start + 1]));
        return (raw_val % M + M) % M;
    }
};

vector&lt;long long&gt; HashedString::pow = {1};</code></pre>
            </div>

            <div class="step-by-step">
                <strong>Implementation Breakdown:</strong><br>
                <strong>1.</strong> Precompute powers of base B modulo M<br>
                <strong>2.</strong> Build prefix hash array where p_hash[i] = hash of first i characters<br>
                <strong>3.</strong> Use prefix sums to compute substring hash in O(1)<br>
                <strong>4.</strong> Handle modular arithmetic carefully to avoid negative values
            </div>

            <p>This implementation calculates:</p>

            <div class="math-display">
                $$\texttt{hsh}[i + 1] = \left(\sum_{x = 0}^i B^{i - x} \cdot S[x]\right) \bmod M$$
            </div>

            <p>The hash of any particular substring $S[a : b]$ is then calculated as:</p>

            <div class="math-display">
                $$\left(\sum_{x = a}^b B^{b - x} \cdot S[x] \right) \bmod M = (\texttt{hsh}[b + 1] - \texttt{hsh}[a] \cdot B^{b - a + 1}) \bmod M$$
            </div>

            <div class="algorithm-box">
                <strong>Substring Hash Extraction:</strong> Using prefix sums, we can extract the hash of any substring in O(1) time. This is the key insight that makes polynomial hashing so powerful for substring operations.
            </div>

            <div class="optimization-box">
                <strong>No Modular Inverses Needed:</strong> This implementation cleverly avoids computing modular inverses by ensuring the highest power of B in the substring polynomial is always B^(length-1), making the formula simple and efficient.
            </div>
        </div>

        <div class="section hover-effect">
            <h2>Collision Probability Analysis</h2>

            <p>Understanding the probability of hash collisions is crucial for choosing appropriate parameters and ensuring the reliability of hash-based algorithms.</p>

            <div class="collision-probability-box">
                <strong>Collision Probability Theory:</strong> In general, when using polynomial hashing modulo a prime modulus M, the probability of two distinct strings having equal hashing over all possible choices of the base B can be up to n/M, where n is the length of the longer of the two strings.
            </div>

            <h3>Single Collision Probability</h3>

            <div class="hash-visualization">
                <strong>Schwarz-Zippel Lemma Application</strong>
                <p><strong>For M = 10^9 + 9:</strong></p>
                <p>Collision probability ‚â§ N/(10^9 + 9) &lt; 10^-4</p>
                <p><strong>For strings of length ‚â§ 10^5:</strong></p>
                <p>Expected collision rate is very low for individual comparisons</p>
            </div>

            <p>Since $10^9 + 9$ is prime, the probability of collision when using this hash is at most $\frac{N}{10^9 + 9} < 10^{-4}$, by the Schwarz-Zippel lemma. This means that if you select any two different strings of length at most $N=10^5$ and a random base modulo $10^9 + 9$ (e.g. $9973$ in the code), the probability that they hash to the same value is at most $10^{-4}$.</p>

            <h3>Birthday Paradox Consideration</h3>

            <div class="warning">
                Given a set of the hashes of m distinct strings with length up to n, the probability of two strings having equal hashes can be up to $\frac{m^2n}{M}$ by the birthday paradox. Assuming m and n are on the order of $10^5$, $M=10^9+7$ is nowhere close to large enough to avoid collisions. Use a larger prime modulus such as $2^{61}-1$ (and do multiplications using 128-bit integers).
            </div>

            <div class="collision-probability-box">
                <strong>Birthday Paradox Impact:</strong> When dealing with many strings (like in hash tables), the collision probability increases quadratically. For contest problems involving large numbers of hashes, consider using double hashing or larger moduli.
            </div>

            <h3>Random Base Generation</h3>

            <div class="warning">
                In contests with open hacking (in particular, Codeforces educational rounds), make sure to choose the base of your polynomial hash randomly, as mentioned here.
            </div>

            <div class="random-base-box">
                <strong>Anti-Hack Protection:</strong> In contests where solutions can be hacked, using a fixed base makes your solution vulnerable to adversarial test cases. Generate the base randomly to prevent such attacks.
            </div>

            <div class="code-container">
                <div class="code-header">C++ - Random Base Generation</div>
                <pre class="line-numbers"><code class="language-cpp">mt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count());
const ll B = uniform_int_distribution&lt;ll&gt;(0, M - 1)(rng);</code></pre>
            </div>

            <div class="algorithm-box">
                <strong>Virtually Unhackable:</strong> Using a random number generator seeded with a high-precision clock makes it extremely difficult for adversaries to predict your hash function, providing strong protection against targeted attacks.
            </div>
        </div>

        <div class="section hover-effect">
            <h2>String Search Problem: Searching For Strings</h2>

            <p>Let's explore a practical application of hashing with a classic problem that demonstrates both the power and challenges of hash-based algorithms.</p>

            <div class="focus-problem">
                <strong>üéØ Focus Problem:</strong> Searching For Strings<br>
                Find the number of distinct permutations of string N that appear as substrings in string H!
            </div>

            <div class="string-matching-box">
                <strong>Problem Analysis:</strong> We need to find distinct permutations (anagrams) of pattern N within text H. Since order doesn't matter for permutations, we need a way to identify when two substrings are anagrams of each other.
            </div>

            <h3>Solution 1: Frequency Tables + Hashing</h3>

            <div class="sliding-window-box">
                <strong>Sliding Window Strategy:</strong> We'll use a sliding window over H to find the "matches" with N. Since we don't care about relative order when comparing two substrings, we can store frequency tables of the characters in the current window and in N.
            </div>

            <div class="step-by-step">
                <strong>Algorithm Steps:</strong><br>
                <strong>1.</strong> Maintain frequency tables for pattern N and current window<br>
                <strong>2.</strong> Slide window over H, updating frequencies as characters enter/leave<br>
                <strong>3.</strong> When frequency tables match, we found a permutation<br>
                <strong>4.</strong> Store polynomial hash of matching substring to count distinct permutations<br>
                <strong>5.</strong> Answer is the size of the hash set
            </div>

            <div class="code-container">
                <div class="code-header">C++ - Frequency Table + Hashing Solution</div>
                <pre class="line-numbers"><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
using ll = long long;

// HashedString implementation would be included here

int freq_target[26], freq_curr[26];
string n, h;

int main() {
    cin.tie(0)-&gt;sync_with_stdio(0);
    cin &gt;&gt; n &gt;&gt; h;
    if (n.size() &gt; h.size()) {
        cout &lt;&lt; 0 &lt;&lt; '\n';
        return 0;
    }
    HashedString hs(h);

    set&lt;ll&gt; good;
    for (int i = 0; i &lt; n.size(); i++) {
        // Update frequency table
        freq_target[n[i] - 'a']++;
        freq_curr[h[i] - 'a']++;
    }
    
    for (int i = n.size() - 1; i &lt; h.size(); i++) {
        if (i &gt;= n.size()) {
            // Update frequency table
            freq_curr[h[i] - 'a']++;
            freq_curr[h[i - n.size()] - 'a']--;
        }
        
        bool match = true;
        for (int j = 0; j &lt; 26; j++) { 
            match &amp;= freq_curr[j] == freq_target[j]; 
        }
        
        if (match) { 
            good.insert(hs.get_hash(i + 1 - n.size(), i)); 
        }
    }

    cout &lt;&lt; good.size() &lt;&lt; endl;
}</code></pre>
            </div>

            <div class="complexity">
                <strong>Time Complexity: $\mathcal{O}((|N| + |H|) \cdot \Sigma)$</strong><br>
                Where Œ£ is the size of the alphabet (26 for lowercase letters).<br>
                <strong>Failure Probability: $\mathcal{O}\left(\frac{|N||H|^2}{M}\right)$</strong>
            </div>

            <h3>Solution 2: Product Hashing</h3>

            <div class="polynomial-hash-box">
                <strong>Product Hash Innovation:</strong> An alternative solution without frequency tables would be to hash the substrings that we're trying to match. Since order doesn't matter, we need to modify our hash function slightly to be commutative.
            </div>

            <p>In particular, instead of computing the polynomial hash of the substrings, compute the product $(B + s_1)(B + s_2) \dots (B + s_k) \bmod M$ as the hash (again, using two modulos). This hash is nice because the relative order of the letters doesn't matter, as multiplication is commutative.</p>

            <div class="algorithm-box">
                <strong>Commutative Property:</strong> Since multiplication is commutative, strings with the same character frequencies will produce the same product hash, regardless of character order. This eliminates the need for explicit frequency table comparisons.
            </div>

            <div class="optimization-box">
                <strong>Mathematical Guarantee:</strong> As any two strings with different frequency tables map to different polynomials in B, they hash to the same value with probability at most |N|/M over the choice of B.
            </div>

            <div class="code-container">
                <div class="code-header">C++ - Product Hashing Solution</div>
                <pre class="line-numbers"><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
typedef long long ll;
using namespace std;

// HashedString implementation would be included here

const auto M = HashedString::M;
const auto B = HashedString::B;
const auto mul = HashedString::mul;
const auto mod_mul = HashedString::mod_mul;

ll inv(ll base, ll MOD) {
    ll ans = 1, expo = MOD - 2;
    while (expo) {
        if (expo &amp; 1) { ans = mod_mul(ans, base); }
        expo &gt;&gt;= 1;
        base = mod_mul(base, base);
    }
    return ans;
}

string n, h;

int main() {
    cin.tie(0)-&gt;sync_with_stdio(0);
    cin &gt;&gt; n &gt;&gt; h;
    if (n.size() &gt; h.size()) return cout &lt;&lt; 0, 0;
    HashedString hs(h);

    set&lt;ll&gt; good;
    ll h_hsh = 1, n_hsh = 1;
    for (int i = 0; i &lt; n.size(); i++) {
        // Compute product hashes
        h_hsh = mod_mul(h_hsh, B + h[i] - 'a');
        n_hsh = mod_mul(n_hsh, B + n[i] - 'a');
    }

    for (int i = n.size() - 1; i &lt; h.size(); i++) {
        if (i &gt;= n.size()) {
            // Update product hashes using modular inverse
            h_hsh = mod_mul(h_hsh, inv(B + h[i - n.size()] - 'a', M));
            h_hsh = mod_mul(h_hsh, B + h[i] - 'a');
        }
        if (n_hsh == h_hsh) { 
            good.insert(hs.get_hash(i + 1 - n.size(), i)); 
        }
    }

    cout &lt;&lt; good.size() &lt;&lt; '\n';
}</code></pre>
            </div>

            <div class="complexity">
                <strong>Time Complexity: $\mathcal{O}((|N| + |H|) \log M)$</strong><br>
                The extra log M factor comes from computing modular inverses.<br>
                <strong>Failure Probability: $\mathcal{O}\left(\frac{|N||H|^2}{M}\right)$</strong>
            </div>

            <div class="warning">
                Since this hash requires the modular inverse, there's an extra log M factor in the time complexity. However, it eliminates the need for frequency table comparisons.
            </div>
        </div>

        <div class="section hover-effect">
            <h2>Advanced Hashing Techniques</h2>

            <h3>Double Hashing</h3>

            <div class="optimization-box">
                <strong>Double Hashing Strategy:</strong> To further reduce collision probability, use two different hash functions with different moduli. A collision occurs only when both hashes collide simultaneously, which is much less likely.
            </div>

            <div class="code-container">
                <div class="code-header">C++ - Double Hashing Template</div>
                <pre class="line-numbers"><code class="language-cpp">class DoubleHashedString {
private:
    static const long long M1 = 1e9 + 7;
    static const long long M2 = 1e9 + 9;
    static const long long B1 = 9973;
    static const long long B2 = 9929;
    
    static vector&lt;long long&gt; pow1, pow2;
    vector&lt;long long&gt; p_hash1, p_hash2;

public:
    DoubleHashedString(const string &amp;s) : p_hash1(s.size() + 1), p_hash2(s.size() + 1) {
        while (pow1.size() &lt;= s.size()) {
            pow1.push_back((pow1.back() * B1) % M1);
            pow2.push_back((pow2.back() * B2) % M2);
        }

        p_hash1[0] = p_hash2[0] = 0;
        for (int i = 0; i &lt; s.size(); i++) {
            p_hash1[i + 1] = ((p_hash1[i] * B1) % M1 + s[i]) % M1;
            p_hash2[i + 1] = ((p_hash2[i] * B2) % M2 + s[i]) % M2;
        }
    }

    pair&lt;long long, long long&gt; get_hash(int start, int end) {
        long long raw_val1 = (p_hash1[end + 1] - (p_hash1[start] * pow1[end - start + 1]));
        long long raw_val2 = (p_hash2[end + 1] - (p_hash2[start] * pow2[end - start + 1]));
        return {(raw_val1 % M1 + M1) % M1, (raw_val2 % M2 + M2) % M2};
    }
};

vector&lt;long long&gt; DoubleHashedString::pow1 = {1};
vector&lt;long long&gt; DoubleHashedString::pow2 = {1};</code></pre>
            </div>

            <h3>Rolling Hash Applications</h3>

            <div class="sliding-window-box">
                <strong>Rolling Hash Benefits:</strong> In sliding window problems, we can update hash values incrementally as elements enter and leave the window, maintaining O(1) update time while preserving the ability to compare windows efficiently.
            </div>

            <div class="problem-patterns">
                <div class="pattern-card">
                    <div class="pattern-title">üîç Pattern Matching</div>
                    <p><strong>Applications:</strong> KMP alternative, multiple pattern search<br>
                    <strong>Technique:</strong> Precompute pattern hash, roll through text<br>
                    <strong>Examples:</strong> Rabin-Karp algorithm, substring search</p>
                </div>
                
                <div class="pattern-card">
                    <div class="pattern-title">üîÑ Palindrome Detection</div>
                    <p><strong>Applications:</strong> Check if substring is palindrome in O(1)<br>
                    <strong>Technique:</strong> Forward and reverse hashing<br>
                    <strong>Examples:</strong> Longest palindromic substring, palindrome queries</p>
                </div>
                
                <div class="pattern-card">
                    <div class="pattern-title">üìä Duplicate Finding</div>
                    <p><strong>Applications:</strong> Find repeated substrings, longest common substring<br>
                    <strong>Technique:</strong> Hash all substrings, use hash table<br>
                    <strong>Examples:</strong> Longest repeated substring, plagiarism detection</p>
                </div>
            </div>

            <h3>Hash-Based Data Structures</h3>

            <div class="applications-box">
                <strong>Advanced Applications:</strong><br>
                ‚Ä¢ <strong>Trie Compression:</strong> Use hashes to compress trie nodes<br>
                ‚Ä¢ <strong>Suffix Array:</strong> Hash-based suffix array construction<br>
                ‚Ä¢ <strong>String Matching Automata:</strong> Hash-based state transitions<br>
                ‚Ä¢ <strong>Approximate Matching:</strong> Locality-sensitive hashing for fuzzy search<br>
                ‚Ä¢ <strong>Data Deduplication:</strong> Content-based chunking with rolling hash
            </div>
        </div>

        <div class="section hover-effect">
            <h2>Implementation Tips and Best Practices</h2>

            <h3>Parameter Selection Guidelines</h3>

            <div class="hashing-box">
                <strong>Choosing Good Parameters:</strong><br>
                ‚Ä¢ <strong>Modulus:</strong> Use large primes like 10^9+7, 10^9+9, or 2^61-1<br>
                ‚Ä¢ <strong>Base:</strong> Choose randomly or use primes like 9973, 9929<br>
                ‚Ä¢ <strong>Multiple Hashes:</strong> Use 2-3 different hash functions for critical applications<br>
                ‚Ä¢ <strong>Bit Operations:</strong> Consider using 2^k moduli for faster arithmetic
            </div>

            <h3>Common Hashing Mistakes</h3>

            <div class="warning">
                <strong>Pitfall Prevention:</strong><br>
                ‚Ä¢ Don't use small moduli like 10^6 - collision probability too high<br>
                ‚Ä¢ Always handle negative values in modular arithmetic ((val % M + M) % M)<br>
                ‚Ä¢ Be careful with integer overflow - use long long or proper modular arithmetic<br>
                ‚Ä¢ Don't forget to randomize base in contests with open hacking<br>
                ‚Ä¢ Consider birthday paradox when dealing with many hashes
            </div>

            <h3>Performance Optimization</h3>

            <div class="optimization-box">
                <strong>Speed Optimizations:</strong><br>
                ‚Ä¢ <strong>Precompute Powers:</strong> Store powers of base to avoid repeated computation<br>
                ‚Ä¢ <strong>Modular Arithmetic:</strong> Use Barrett reduction or Montgomery multiplication for speed<br>
                ‚Ä¢ <strong>Memory Layout:</strong> Store hash values contiguously for better cache performance<br>
                ‚Ä¢ <strong>SIMD Instructions:</strong> Vectorize hash computations when possible
            </div>

            <div class="code-container">
                <div class="code-header">C++ - Hashing Debug Helpers</div>
                <pre class="line-numbers"><code class="language-cpp">// Debug functions for hashing
void test_hash_function() {
    string test_strings[] = {"abc", "bca", "cab", "abcd", "dcba"};
    HashedString hs("abcdefghijklmnopqrstuvwxyz");
    
    cout &lt;&lt; "Testing hash function:\n";
    for (string s : test_strings) {
        // Create a HashedString for each test string
        HashedString test_hs(s);
        cout &lt;&lt; "String: " &lt;&lt; s &lt;&lt; " Hash: " &lt;&lt; test_hs.get_hash(0, s.length() - 1) &lt;&lt; "\n";
    }
}

void verify_substring_hashes(const string&amp; s) {
    HashedString hs(s);
    cout &lt;&lt; "Verifying substring hashes for: " &lt;&lt; s &lt;&lt; "\n";
    
    for (int i = 0; i &lt; s.length(); i++) {
        for (int j = i; j &lt; s.length(); j++) {
            string substr = s.substr(i, j - i + 1);
            HashedString substr_hs(substr);
            long long direct_hash = substr_hs.get_hash(0, substr.length() - 1);
            long long extracted_hash = hs.get_hash(i, j);
            
            if (direct_hash != extracted_hash) {
                cout &lt;&lt; "MISMATCH: " &lt;&lt; substr &lt;&lt; " at [" &lt;&lt; i &lt;&lt; "," &lt;&lt; j &lt;&lt; "]\n";
                cout &lt;&lt; "Direct: " &lt;&lt; direct_hash &lt;&lt; " Extracted: " &lt;&lt; extracted_hash &lt;&lt; "\n";
            }
        }
    }
    cout &lt;&lt; "Verification complete.\n";
}</code></pre>
            </div>

            <h3>Testing and Validation</h3>

            <div class="algorithm-box">
                <strong>Validation Strategy:</strong> Always test your hash function with known inputs, verify that identical strings produce identical hashes, and check that substring extraction works correctly. Use stress testing to detect collision issues.
            </div>
        </div>

        <div class="section hover-effect">
            <h2>Summary and Key Takeaways</h2>

            <div class="definition-box">
                Hashing is a powerful technique that enables efficient string processing by converting strings to integers. Polynomial hashing with careful parameter selection provides excellent performance with low collision probability.
            </div>

            <div class="problem-patterns">
                <div class="pattern-card">
                    <div class="pattern-title">What You've Mastered</div>
                    <ul style="padding-left: 20px; list-style: disc;">
                        <li>Polynomial hashing fundamentals and implementation</li>
                        <li>Collision probability analysis and parameter selection</li>
                        <li>Practical applications: string matching and permutation finding</li>
                        <li>Advanced techniques: double hashing and rolling hash</li>
                        <li>Performance optimization and debugging strategies</li>
                    </ul>
                </div>
                <div class="pattern-card">
                    <div class="pattern-title">Next Learning Goals</div>
                    <ul style="padding-left: 20px; list-style: disc;">
                        <li>Suffix arrays and suffix trees with hashing</li>
                        <li>Advanced string algorithms: Z-algorithm, Manacher's</li>
                        <li>Locality-sensitive hashing for approximate matching</li>
                        <li>Cryptographic hash functions and their properties</li>
                        <li>Hash-based probabilistic data structures</li>
                    </ul>
                </div>
            </div>

            <div class="focus-problem">
                <strong>üéØ Practice Challenge:</strong><br>
                Now that you understand hashing fundamentals, try solving "Longest Palindromic Substring," "Find All Anagrams," or "Repeated DNA Sequences" to practice different hashing applications and build your string processing skills!
            </div>

            <div class="hashing-box">
                <strong>Real-World Impact:</strong> Hashing techniques are fundamental in databases, file systems, version control systems, content delivery networks, plagiarism detection, bioinformatics, and cybersecurity applications.
            </div>

            <div class="algorithm-box">
                <strong>Key Insight:</strong> The power of hashing lies in transforming complex string operations into simple integer operations. With careful implementation and parameter selection, hashing provides both speed and reliability.
            </div>

            <div class="complexity">
                <strong>Performance Summary:</strong> Hashing enables O(1) substring comparisons after O(n) preprocessing, transforming many O(n¬≤) string algorithms into O(n) or O(n log n) solutions. The trade-off is a small collision probability that can be made arbitrarily small.
            </div>

            <div class="optimization-box">
                <strong>Final Reminder:</strong> Always consider the specific requirements of your problem when choosing hash parameters. For contest problems, focus on simplicity and correctness. For production systems, prioritize collision resistance and security. Hashing is a tool - use it wisely!
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
</body>
</html>