<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>More Applications of Segment Tree</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet">
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']]
            }
        };
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-weight: 600;
            line-height: 1.7;
            color: #2c3e50;
            background: white;
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 40px 20px;
            animation: fadeInUp 0.8s ease-out;
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        h1 {
            font-size: 3.5rem;
            font-weight: 800;
            color: #2c3e50;
            text-align: center;
            margin-bottom: 50px;
            position: relative;
            animation: slideInDown 1s ease-out;
        }

        @keyframes slideInDown {
            from {
                opacity: 0;
                transform: translateY(-50px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        h1::after {
            content: '';
            display: block;
            width: 380px;
            height: 4px;
            background: linear-gradient(90deg, #9b59b6, #8e44ad);
            margin: 20px auto;
            border-radius: 2px;
            animation: expandLine 1.2s ease-out 0.5s both;
        }

        @keyframes expandLine {
            from {
                width: 0;
            }
            to {
                width: 380px;
            }
        }

        h2 {
            font-size: 2.4rem;
            font-weight: 700;
            color: #34495e;
            margin-top: 60px;
            margin-bottom: 25px;
            border-left: 5px solid #9b59b6;
            padding-left: 20px;
            animation: slideInLeft 0.6s ease-out;
        }

        @keyframes slideInLeft {
            from {
                opacity: 0;
                transform: translateX(-30px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        h3 {
            font-size: 1.9rem;
            font-weight: 700;
            color: #2c3e50;
            margin-top: 40px;
            margin-bottom: 20px;
            position: relative;
        }

        h3::before {
            content: 'üß†';
            margin-right: 10px;
            font-size: 0.9em;
        }

        p {
            font-size: 1.15rem;
            font-weight: 600;
            margin-bottom: 25px;
            text-align: justify;
            line-height: 1.8;
        }

        ul {
            margin: 25px 0;
            padding-left: 0;
        }

        li {
            font-size: 1.15rem;
            font-weight: 600;
            margin-bottom: 15px;
            line-height: 1.8;
            list-style: none;
            position: relative;
            padding-left: 30px;
        }

        li::before {
            content: 'üí°';
            position: absolute;
            left: 0;
            top: 0;
        }

        .code-container {
            background: #1e1e1e;
            border-radius: 12px;
            margin: 30px 0;
            overflow: hidden;
            box-shadow: 0 8px 25px rgba(0,0,0,0.15);
            border: 1px solid #333;
            animation: fadeIn 0.8s ease-out;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }

        .code-header {
            background: linear-gradient(90deg, #2c3e50, #34495e);
            color: white;
            padding: 12px 20px;
            font-weight: 700;
            font-size: 0.9rem;
            border-bottom: 1px solid #444;
        }

        pre {
            margin: 0 !important;
            background: #1e1e1e !important;
            border-radius: 0 !important;
        }

        code {
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace !important;
            font-size: 0.95rem !important;
            line-height: 1.6 !important;
            font-weight: 500 !important;
        }

        .line-numbers-rows {
            border-right: 1px solid #444 !important;
            padding-right: 10px !important;
            margin-right: 15px !important;
        }

        .complexity {
            background: linear-gradient(135deg, #f4ecf7, #e1bee7);
            padding: 20px 25px;
            border-radius: 12px;
            border-left: 4px solid #9b59b6;
            margin: 25px 0;
            font-weight: 700;
            box-shadow: 0 4px 15px rgba(155, 89, 182, 0.1);
        }

        .warning {
            background: linear-gradient(135deg, #fff3cd, #ffeaa7);
            padding: 20px 25px;
            border-radius: 12px;
            border-left: 4px solid #ffc107;
            margin: 25px 0;
            font-weight: 700;
            box-shadow: 0 4px 15px rgba(255, 193, 7, 0.1);
        }

        .warning::before {
            content: '‚ö†Ô∏è ';
            font-size: 1.2em;
        }

        .section {
            margin-bottom: 50px;
            padding: 35px;
            background: #fafbfc;
            border-radius: 15px;
            border: 1px solid #e1e8ed;
            animation: slideInUp 0.6s ease-out;
        }

        @keyframes slideInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .focus-problem {
            background: linear-gradient(135deg, #f4ecf7, #e1bee7);
            padding: 25px;
            border-radius: 15px;
            margin: 30px 0;
            border: 2px solid #9b59b6;
            text-align: center;
            font-weight: 700;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% {
                box-shadow: 0 0 0 0 rgba(155, 89, 182, 0.4);
            }
            70% {
                box-shadow: 0 0 0 10px rgba(155, 89, 182, 0);
            }
            100% {
                box-shadow: 0 0 0 0 rgba(155, 89, 182, 0);
            }
        }

        .highlight {
            background: linear-gradient(120deg, #e1bee7 0%, #74b9ff 100%);
            padding: 3px 8px;
            border-radius: 6px;
            font-weight: 800;
        }

        .hover-effect {
            transition: all 0.3s ease;
        }

        .hover-effect:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 35px rgba(0,0,0,0.15);
        }

        .definition-box {
            background: linear-gradient(135deg, #f4ecf7, #e1bee7);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 4px solid #9b59b6;
            font-weight: 700;
        }

        .definition-box::before {
            content: 'üìö Definition: ';
            font-weight: 800;
            color: #7d3c98;
        }

        .algorithm-box {
            background: linear-gradient(135deg, #e8f5e8, #d4edda);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 4px solid #28a745;
            font-weight: 700;
        }

        .algorithm-box::before {
            content: '‚ö° Key Insight: ';
            font-weight: 800;
            color: #155724;
        }

        .solution-header {
            color: #9b59b6;
            font-weight: 800;
            border-bottom: 3px solid #9b59b6;
            padding-bottom: 8px;
            display: inline-block;
            margin-bottom: 20px;
        }

        .math-display {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            margin: 25px 0;
            text-align: center;
            border: 2px solid #e9ecef;
            font-size: 1.2rem;
        }

        .segtree-box {
            background: linear-gradient(135deg, #f4ecf7, #e1bee7);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 4px solid #9b59b6;
            font-weight: 700;
        }

        .segtree-box::before {
            content: 'üå≥ Segment Tree: ';
            font-weight: 800;
            color: #7d3c98;
        }

        .step-by-step {
            background: linear-gradient(135deg, #fef7ff, #f3e8ff);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 4px solid #a855f7;
            font-weight: 700;
        }

        .step-by-step::before {
            content: 'üìù Algorithm Steps: ';
            font-weight: 800;
            color: #7c2d12;
        }

        .optimization-box {
            background: linear-gradient(135deg, #fef3c7, #fbbf24);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 4px solid #f59e0b;
            font-weight: 700;
        }

        .optimization-box::before {
            content: '‚ö° Optimization: ';
            font-weight: 800;
            color: #92400e;
        }

        .tree-walking-box {
            background: linear-gradient(135deg, #e3f2fd, #bbdefb);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 4px solid #2196f3;
            font-weight: 700;
        }

        .tree-walking-box::before {
            content: 'üö∂ Tree Walking: ';
            font-weight: 800;
            color: #1976d2;
        }

        .applications-box {
            background: linear-gradient(135deg, #f0f4f8, #ddd6fe);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 4px solid #8b5cf6;
            font-weight: 700;
        }

        .applications-box::before {
            content: 'üìñ Applications: ';
            font-weight: 800;
            color: #7c3aed;
        }

        .problem-patterns {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 20px;
            margin: 30px 0;
        }

        .pattern-card {
            background: white;
            border-radius: 12px;
            padding: 25px;
            border-left: 4px solid #9b59b6;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            transition: transform 0.3s ease;
        }

        .pattern-card:hover {
            transform: translateY(-5px);
        }

        .pattern-card:nth-child(1) {
            border-left-color: #e74c3c;
        }

        .pattern-card:nth-child(2) {
            border-left-color: #3498db;
        }

        .pattern-card:nth-child(3) {
            border-left-color: #2ecc71;
        }

        .pattern-title {
            font-weight: 800;
            color: #9b59b6;
            margin-bottom: 15px;
            font-size: 1.3rem;
        }

        .pattern-card:nth-child(1) .pattern-title {
            color: #e74c3c;
        }

        .pattern-card:nth-child(2) .pattern-title {
            color: #3498db;
        }

        .pattern-card:nth-child(3) .pattern-title {
            color: #2ecc71;
        }

        .coordinate-compression-box {
            background: linear-gradient(135deg, #fff3e0, #ffe0b2);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 4px solid #ff9800;
            font-weight: 700;
        }

        .coordinate-compression-box::before {
            content: 'üìê Coordinate Compression: ';
            font-weight: 800;
            color: #f57c00;
        }

        .decision-tree-box {
            background: linear-gradient(135deg, #e8f5e8, #d4edda);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 4px solid #28a745;
            font-weight: 700;
        }

        .decision-tree-box::before {
            content: 'üå≤ Decision Tree: ';
            font-weight: 800;
            color: #155724;
        }

        .prefix-sum-box {
            background: linear-gradient(135deg, #fff8e1, #ffecb3);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 4px solid #ffc107;
            font-weight: 700;
        }

        .prefix-sum-box::before {
            content: 'üìä Prefix Sum Walking: ';
            font-weight: 800;
            color: #f57c00;
        }

        .ordered-set-box {
            background: linear-gradient(135deg, #ffebee, #ffcdd2);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 4px solid #f44336;
            font-weight: 700;
        }

        .ordered-set-box::before {
            content: 'üìã Ordered Set: ';
            font-weight: 800;
            color: #d32f2f;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>More Applications of Segment Tree</h1>
        
        <div class="section hover-effect">
            <h2>Introduction to Advanced Segment Tree Techniques</h2>
            
            <p>While basic segment trees handle range queries and point updates efficiently, <span class="highlight">advanced segment tree applications</span> go beyond simple operations. These techniques include tree walking, coordinate compression, and combining segment trees with other data structures to solve complex problems.</p>

            <div class="definition-box">
                Advanced Segment Tree Applications involve techniques like walking on the tree structure to find specific elements, combining binary search with tree traversal, and using segment trees as building blocks for more sophisticated data structures.
            </div>

            <div class="segtree-box">
                <strong>Core Advanced Concepts:</strong><br>
                ‚Ä¢ <strong>Tree Walking:</strong> Traversing the segment tree as a decision tree<br>
                ‚Ä¢ <strong>Combined Operations:</strong> Merging queries with updates in single traversal<br>
                ‚Ä¢ <strong>Coordinate Compression:</strong> Handling large value ranges efficiently<br>
                ‚Ä¢ <strong>Ordered Sets:</strong> Supporting dynamic order statistics<br>
                ‚Ä¢ <strong>Custom Traversals:</strong> Non-standard tree navigation patterns
            </div>

            <div class="applications-box">
                <strong>Advanced Applications:</strong><br>
                ‚Ä¢ <strong>First Element Queries:</strong> Find first element satisfying condition<br>
                ‚Ä¢ <strong>Kth Order Statistics:</strong> Dynamic rank and selection queries<br>
                ‚Ä¢ <strong>Range Minimum with Position:</strong> Find value and index simultaneously<br>
                ‚Ä¢ <strong>Persistent Segment Trees:</strong> Maintaining multiple versions<br>
                ‚Ä¢ <strong>Lazy Propagation Extensions:</strong> Complex range update patterns
            </div>

            <div class="algorithm-box">
                <strong>Why Advanced Techniques Matter:</strong> These methods often reduce time complexity by eliminating separate binary search phases, enable new types of queries that weren't possible with basic segment trees, and provide building blocks for complex competitive programming problems.
            </div>
        </div>

        <div class="section hover-effect">
            <h2>Walking on a Segment Tree</h2>
            
            <p>One of the most powerful advanced techniques is <span class="highlight">walking on a segment tree</span> - treating the tree as a decision tree and navigating it intelligently to find specific elements or positions.</p>

            <div class="focus-problem">
                <strong>üéØ Focus Problem:</strong> Hotel Queries<br>
                Find the first i such that a[i] ‚â• x, with point updates!
            </div>

            <h3>Problem Analysis</h3>

            <p>You want to support queries of the following form on an array $a_1,\ldots,a_N$ (along with point updates):</p>

            <div class="math-display">
                <strong>Query:</strong> Find the first $i$ such that $a_i \geq x$
            </div>

            <div class="tree-walking-box">
                <strong>Naive Approach:</strong> Of course, you can do this in O(log¬≤N) time with a max segment tree and binary searching on the first i such that max(a‚ÇÅ,...,a·µ¢) ‚â• x. But we can do better!
            </div>

            <div class="optimization-box">
                <strong>Tree Walking Optimization:</strong> Instead of binary searching and querying the segment tree separately, let's do them together! This reduces complexity from O(log¬≤N) to O(log N) per query.
            </div>

            <h3>Tree Walking Algorithm</h3>

            <div class="decision-tree-box">
                <strong>Decision Tree Concept:</strong> Imagine that the segment tree is a decision tree. We start at the root and move down. When we're at some node that contains max(a‚Çó,...,a·µ£) and we know that the answer is in the range [l, r], we move to the left child if max(a‚Çó,...,a‚Çò·µ¢d) ‚â• x; otherwise, we move to the right child.
            </div>

            <div class="step-by-step">
                <strong>Walking Algorithm Steps:</strong><br>
                <strong>1.</strong> Start at root node covering entire array<br>
                <strong>2.</strong> If current node's max < x, no answer exists<br>
                <strong>3.</strong> If at leaf node, return the index<br>
                <strong>4.</strong> Check left child's maximum value<br>
                <strong>5.</strong> If left max ‚â• x, recurse left; otherwise recurse right<br>
                <strong>6.</strong> Continue until reaching a leaf node
            </div>

            <div class="algorithm-box">
                <strong>Efficiency Key:</strong> This is convenient because max(a‚Çó,...,a‚Çò·µ¢d) is already stored in the left child, so we can find it in O(1) time. No separate queries needed!
            </div>

            <h3 class="solution-header">Hotel Queries Implementation</h3>

            <div class="code-container">
                <div class="code-header">C++ - Tree Walking Solution</div>
                <pre class="line-numbers"><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;

const int MAXN = 200001;
int n;
int segtree[4 * MAXN], a[MAXN];

void build(int l = 1, int r = n, int node = 1) {
    if (l == r) {
        segtree[node] = a[l];
    } else {
        int mid = (l + r) / 2;
        build(l, mid, node * 2);
        build(mid + 1, r, node * 2 + 1);
        segtree[node] = max(segtree[node * 2], segtree[node * 2 + 1]);
    }
}

void queryupdate(int val, int l = 1, int r = n, int node = 1) {
    if (l == r) {
        segtree[node] -= val;
        cout &lt;&lt; l &lt;&lt; ' ';
    } else {
        int mid = (l + r) / 2;
        if (segtree[node * 2] &gt;= val) {
            queryupdate(val, l, mid, node * 2);
        } else {
            queryupdate(val, mid + 1, r, node * 2 + 1);
        }
        segtree[node] = max(segtree[node * 2], segtree[node * 2 + 1]);
    }
}

int main() {
    iostream::sync_with_stdio(false);
    cin.tie(0);
    int q;
    cin &gt;&gt; n &gt;&gt; q;
    for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i];
    build();

    while (q--) {
        int x;
        cin &gt;&gt; x;
        if (segtree[1] &lt; x) {
            cout &lt;&lt; "0 ";
        } else {
            queryupdate(x);
        }
    }
    return 0;
}</code></pre>
            </div>

            <div class="complexity">
                <strong>Time Complexity: $\mathcal{O}(N + Q \log N)$</strong><br>
                Building the tree takes O(N), and each query with update takes O(log N).
            </div>

            <div class="algorithm-box">
                <strong>Combined Query-Update:</strong> Notice how the function queryupdate combines finding the first suitable element with updating it. This is a common pattern in competitive programming where we need to "consume" resources as we find them.
            </div>
        </div>

        <div class="section hover-effect">
            <h2>Ordered Set with Segment Trees</h2>

            <p>Another powerful application is implementing an <span class="highlight">Ordered Set</span> using segment trees with coordinate compression. This supports dynamic order statistics efficiently.</p>

            <div class="focus-problem">
                <strong>üéØ Focus Problem:</strong> Ordered Set<br>
                Support INSERT, DELETE, COUNT, and K-TH queries on a dynamic set!
            </div>

            <h3>Problem Requirements</h3>

            <div class="ordered-set-box">
                <strong>Required Operations:</strong><br>
                ‚Ä¢ <strong>INSERT(x):</strong> Add element x to the set<br>
                ‚Ä¢ <strong>DELETE(x):</strong> Remove element x from the set<br>
                ‚Ä¢ <strong>COUNT(x):</strong> Count elements smaller than x<br>
                ‚Ä¢ <strong>K-TH(k):</strong> Find the k-th smallest element<br>
                All operations should run in O(log N) time.
            </div>

            <h3>Coordinate Compression Strategy</h3>

            <div class="coordinate-compression-box">
                <strong>Compression Technique:</strong> First, we coordinate compress all the values, and keep track of the frequency of each value in the array we build our segment tree on. This handles arbitrarily large values by mapping them to a smaller range [0, Q-1].
            </div>

            <div class="step-by-step">
                <strong>Implementation Strategy:</strong><br>
                <strong>1.</strong> Collect all values that will appear in queries<br>
                <strong>2.</strong> Sort and remove duplicates (coordinate compression)<br>
                <strong>3.</strong> Build segment tree over compressed coordinates<br>
                <strong>4.</strong> Use tree walking for K-TH queries<br>
                <strong>5.</strong> Use range sum for COUNT queries
            </div>

            <h3>K-th Element with Tree Walking</h3>

            <div class="prefix-sum-box">
                <strong>K-th Query Strategy:</strong> Let freq[i] equal the number of times i occurs in our set. In our array of coordinate compressed values, we want to find the first index x such that Œ£(i=0 to x) freq[i] ‚â• K. This is perfect for tree walking on prefix sums!
            </div>

            <div class="algorithm-box">
                <strong>Prefix Sum Walking:</strong> In the previous problem, we were walking on the prefix maximum of our array. Here, we are walking on the prefix sum of our array. The difference is that we need to track the prefix sum as we traverse.
            </div>

            <div class="tree-walking-box">
                <strong>Tracking Prefix:</strong> To keep track of the prefix [1, l), we first set our prefix result to be a neutral value (0 for addition). Every time we walk right, we add the left child's value to our prefix result.
            </div>

            <h3 class="solution-header">Complete Ordered Set Implementation</h3>

            <div class="code-container">
                <div class="code-header">C++ - Ordered Set with Segment Tree</div>
                <pre class="line-numbers"><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;

template &lt;class T&gt; 
class SumSegmentTree {
private:
    const T DEFAULT = 0;
    int len;
    vector&lt;T&gt; segtree;

    T combine(const T &amp;a, const T &amp;b) { return a + b; }

    void build(const vector&lt;T&gt; &amp;arr, int at, int at_left, int at_right) {
        if (at_left == at_right) {
            segtree[at] = arr[at_left];
            return;
        }
        int mid = (at_left + at_right) / 2;
        build(arr, 2 * at, at_left, mid);
        build(arr, 2 * at + 1, mid + 1, at_right);
        segtree[at] = combine(segtree[2 * at], segtree[2 * at + 1]);
    }

    void set(int ind, T val, int at, int at_left, int at_right) {
        if (at_left == at_right) {
            segtree[at] = val;
            return;
        }
        int mid = (at_left + at_right) / 2;
        if (ind &lt;= mid) {
            set(ind, val, 2 * at, at_left, mid);
        } else {
            set(ind, val, 2 * at + 1, mid + 1, at_right);
        }
        segtree[at] = combine(segtree[2 * at], segtree[2 * at + 1]);
    }

    T range_sum(int start, int end, int at, int at_left, int at_right) {
        if (at_right &lt; start || end &lt; at_left) { return DEFAULT; }
        if (start &lt;= at_left &amp;&amp; at_right &lt;= end) { return segtree[at]; }
        int mid = (at_left + at_right) / 2;
        T left_res = range_sum(start, end, 2 * at, at_left, mid);
        T right_res = range_sum(start, end, 2 * at + 1, mid + 1, at_right);
        return combine(left_res, right_res);
    }

    int walk(int at, int at_left, int at_right, int max_val, int pref_res) {
        if (at_left == at_right) { return at_left; }
        int mid = (at_left + at_right) / 2;
        int sum_left = pref_res + segtree[2 * at];
        if (sum_left &gt;= max_val) {
            return walk(2 * at, at_left, mid, max_val, pref_res);
        }
        return walk(2 * at + 1, mid + 1, at_right, max_val, sum_left);
    }

public:
    SumSegmentTree(int len) : len(len) { 
        segtree = vector&lt;T&gt;(len * 4, DEFAULT); 
    }

    SumSegmentTree(const vector&lt;T&gt; &amp;arr) : len(arr.size()) {
        segtree = vector&lt;T&gt;(len * 4, DEFAULT);
        build(arr, 1, 0, len - 1);
    }

    void set(int ind, T val) { set(ind, val, 1, 0, len - 1); }
    T range_sum(int start, int end) { return range_sum(start, end, 1, 0, len - 1); }
    
    /** @return first i such that the prefix sum up to i &gt;= val */
    int walk(int val) { return walk(1, 0, len - 1, val, 0); }
};

int main() {
    int query_num;
    cin &gt;&gt; query_num;
    vector&lt;int&gt; indices;
    vector&lt;pair&lt;char, int&gt;&gt; updates(query_num);
    
    for (int i = 0; i &lt; query_num; i++) {
        char type;
        int val;
        cin &gt;&gt; type &gt;&gt; val;
        updates[i] = {type, val};
        indices.push_back(val);
    }

    sort(begin(indices), end(indices));
    indices.erase(unique(begin(indices), end(indices)), end(indices));

    /** @return coordinate compressed location of v */
    const auto id = [&amp;](int v) -&gt; int {
        return lower_bound(begin(indices), end(indices), v) - begin(indices);
    };

    vector&lt;int&gt; freq(indices.size());
    SumSegmentTree&lt;int&gt; st(indices.size());
    
    for (const auto [type, val] : updates) {
        int loc = id(val);
        if (type == 'I') {
            if (freq[loc] == 0) {
                freq[loc] = 1;
                st.set(loc, 1);
            }
        } else if (type == 'D') {
            if (freq[loc] == 1) {
                freq[loc] = 0;
                st.set(loc, 0);
            }
        } else if (type == 'K') {
            if (st.range_sum(0, indices.size() - 1) &lt; val) {
                cout &lt;&lt; "invalid" &lt;&lt; '\n';
            } else {
                cout &lt;&lt; indices[st.walk(val)] &lt;&lt; '\n';
            }
        } else if (type == 'C') {
            cout &lt;&lt; st.range_sum(0, loc - 1) &lt;&lt; '\n';
        }
    }
}</code></pre>
            </div>

            <div class="complexity">
                <strong>Time Complexity: $\mathcal{O}(Q \log Q)$</strong><br>
                Coordinate compression takes O(Q log Q), and each query operation takes O(log Q).
            </div>

            <div class="algorithm-box">
                <strong>Key Insight:</strong> The walk function implements tree walking for prefix sums. Notice how pref_res tracks the sum of elements before the current range, enabling us to find the first position where prefix sum ‚â• target.
            </div>
        </div>

        <div class="section hover-effect">
            <h2>Advanced Tree Walking Patterns</h2>

            <h3>Range Minimum with Position</h3>

            <div class="tree-walking-box">
                <strong>Enhanced Queries:</strong> Sometimes we need both the minimum value and its position. Tree walking can be extended to return multiple pieces of information during traversal.
            </div>

            <div class="code-container">
                <div class="code-header">C++ - Range Minimum with Position</div>
                <pre class="line-numbers"><code class="language-cpp">struct Node {
    int min_val;
    int min_pos;
    
    Node(int val = INT_MAX, int pos = -1) : min_val(val), min_pos(pos) {}
    
    Node combine(const Node&amp; other) const {
        if (min_val &lt;= other.min_val) {
            return *this;
        }
        return other;
    }
};

class RMQSegmentTree {
private:
    vector&lt;Node&gt; tree;
    int n;
    
public:
    RMQSegmentTree(const vector&lt;int&gt;&amp; arr) : n(arr.size()) {
        tree.resize(4 * n);
        build(arr, 1, 0, n - 1);
    }
    
    void build(const vector&lt;int&gt;&amp; arr, int node, int start, int end) {
        if (start == end) {
            tree[node] = Node(arr[start], start);
        } else {
            int mid = (start + end) / 2;
            build(arr, 2 * node, start, mid);
            build(arr, 2 * node + 1, mid + 1, end);
            tree[node] = tree[2 * node].combine(tree[2 * node + 1]);
        }
    }
    
    // Find first position where value &lt;= target
    int walk_first_leq(int target, int node = 1, int start = 0, int end = -1) {
        if (end == -1) end = n - 1;
        
        if (tree[node].min_val &gt; target) return -1;
        if (start == end) return start;
        
        int mid = (start + end) / 2;
        int left_result = walk_first_leq(target, 2 * node, start, mid);
        if (left_result != -1) return left_result;
        return walk_first_leq(target, 2 * node + 1, mid + 1, end);
    }
};</code></pre>
            </div>

            <h3>Persistent Segment Trees</h3>

            <div class="segtree-box">
                <strong>Version Control:</strong> Persistent segment trees maintain multiple versions of the tree, allowing queries on historical states. This is achieved through path copying and structural sharing.
            </div>

            <div class="applications-box">
                <strong>Persistent Applications:</strong><br>
                ‚Ä¢ <strong>Range Queries on Subarrays:</strong> Query [L,R] elements in range [a,b]<br>
                ‚Ä¢ <strong>Kth Smallest in Range:</strong> Find kth element in any subarray<br>
                ‚Ä¢ <strong>Dynamic Connectivity:</strong> Maintain graph connectivity over time<br>
                ‚Ä¢ <strong>Functional Programming:</strong> Immutable data structure operations<br>
                ‚Ä¢ <strong>Offline Query Processing:</strong> Answer queries in non-chronological order
            </div>

            <h3>Fractional Cascading</h3>

            <div class="optimization-box">
                <strong>Advanced Technique:</strong> Fractional cascading optimizes repeated binary searches across multiple sorted arrays. When combined with segment trees, it enables complex multi-dimensional queries in optimal time.
            </div>
        </div>

        <div class="section hover-effect">
            <h2>Problem Patterns and Applications</h2>

            <div class="problem-patterns">
                <div class="pattern-card">
                    <div class="pattern-title">üéØ First Element Queries</div>
                    <p><strong>Pattern:</strong> Find first/last element satisfying condition<br>
                    <strong>Technique:</strong> Tree walking with early termination<br>
                    <strong>Examples:</strong> Hotel queries, first fit allocation, resource scheduling</p>
                </div>
                
                <div class="pattern-card">
                    <div class="pattern-title">üìä Order Statistics</div>
                    <p><strong>Pattern:</strong> Dynamic rank and selection queries<br>
                    <strong>Technique:</strong> Coordinate compression + tree walking<br>
                    <strong>Examples:</strong> Kth smallest, rank queries, dynamic median</p>
                </div>
                
                <div class="pattern-card">
                    <div class="pattern-title">üîç Multi-dimensional Queries</div>
                    <p><strong>Pattern:</strong> Queries involving multiple constraints<br>
                    <strong>Technique:</strong> Nested segment trees or persistent structures<br>
                    <strong>Examples:</strong> 2D range queries, rectangle intersection, spatial databases</p>
                </div>
            </div>

            <h3>Rectangle Sum Queries</h3>

            <div class="coordinate-compression-box">
                <strong>2D Range Queries:</strong> For 2D rectangle sum queries, we can use a segment tree where each node contains another segment tree. This gives us O(log¬≤N) queries on a 2D grid.
            </div>

            <div class="code-container">
                <div class="code-header">C++ - 2D Range Sum Template</div>
                <pre class="line-numbers"><code class="language-cpp">class SegmentTree2D {
private:
    struct Node {
        vector&lt;int&gt; y_coords;
        vector&lt;long long&gt; tree;
        
        void build(const vector&lt;pair&lt;int,int&gt;&gt;&amp; points) {
            for (auto&amp; p : points) {
                y_coords.push_back(p.second);
            }
            sort(y_coords.begin(), y_coords.end());
            y_coords.erase(unique(y_coords.begin(), y_coords.end()), y_coords.end());
            
            tree.resize(4 * y_coords.size());
            // Build 1D segment tree for y-coordinates
        }
        
        void update(int y, int val) {
            // Update in the y-dimension segment tree
        }
        
        long long query(int y1, int y2) {
            // Query range [y1, y2] in y-dimension
            return 0; // Placeholder
        }
    };
    
    vector&lt;Node&gt; nodes;
    int n;
    
public:
    SegmentTree2D(int size) : n(size) {
        nodes.resize(4 * n);
    }
    
    void update(int x, int y, int val) {
        update(x, y, val, 1, 0, n - 1);
    }
    
    long long query(int x1, int y1, int x2, int y2) {
        return query(x1, y1, x2, y2, 1, 0, n - 1);
    }
    
private:
    void update(int x, int y, int val, int node, int start, int end) {
        nodes[node].update(y, val);
        if (start != end) {
            int mid = (start + end) / 2;
            if (x &lt;= mid) {
                update(x, y, val, 2 * node, start, mid);
            } else {
                update(x, y, val, 2 * node + 1, mid + 1, end);
            }
        }
    }
    
    long long query(int x1, int y1, int x2, int y2, int node, int start, int end) {
        if (end &lt; x1 || start &gt; x2) return 0;
        if (start &gt;= x1 &amp;&amp; end &lt;= x2) {
            return nodes[node].query(y1, y2);
        }
        int mid = (start + end) / 2;
        return query(x1, y1, x2, y2, 2 * node, start, mid) +
               query(x1, y1, x2, y2, 2 * node + 1, mid + 1, end);
    }
};</code></pre>
            </div>

            <h3>Dynamic Connectivity</h3>

            <div class="algorithm-box">
                <strong>Graph Connectivity:</strong> Using segment trees to maintain dynamic graph connectivity allows us to answer "are vertices u and v connected?" queries efficiently while supporting edge additions and deletions.
            </div>
        </div>

        <div class="section hover-effect">
            <h2>Implementation Tips and Optimizations</h2>

            <h3>Memory Optimization</h3>

            <div class="optimization-box">
                <strong>Space Efficiency:</strong><br>
                ‚Ä¢ <strong>Coordinate Compression:</strong> Use only necessary values, not full range<br>
                ‚Ä¢ <strong>Lazy Allocation:</strong> Create child nodes only when needed<br>
                ‚Ä¢ <strong>Memory Pooling:</strong> Reuse deleted nodes in persistent structures<br>
                ‚Ä¢ <strong>Bit Packing:</strong> Store multiple small values in single integers<br>
                ‚Ä¢ <strong>Path Compression:</strong> Share common subtrees in persistent versions
            </div>

            <h3>Common Implementation Mistakes</h3>

            <div class="warning">
                <strong>Pitfall Prevention:</strong><br>
                ‚Ä¢ Don't forget to handle empty ranges in coordinate compression<br>
                ‚Ä¢ Be careful with 0-based vs 1-based indexing in tree walking<br>
                ‚Ä¢ Always check bounds when walking to prevent infinite loops<br>
                ‚Ä¢ Remember to update parent nodes after modifications<br>
                ‚Ä¢ Handle the case where no valid answer exists in walking queries
            </div>

            <h3>Performance Optimization</h3>

            <div class="segtree-box">
                <strong>Speed Techniques:</strong><br>
                ‚Ä¢ <strong>Iterative Implementation:</strong> Faster than recursive for simple operations<br>
                ‚Ä¢ <strong>Template Specialization:</strong> Optimize for specific data types<br>
                ‚Ä¢ <strong>Cache-Friendly Layout:</strong> Store tree in breadth-first order<br>
                ‚Ä¢ <strong>SIMD Instructions:</strong> Vectorize operations when possible<br>
                ‚Ä¢ <strong>Branch Prediction:</strong> Structure conditionals predictably
            </div>

            <div class="code-container">
                <div class="code-header">C++ - Debugging Advanced Segment Trees</div>
                <pre class="line-numbers"><code class="language-cpp">// Debug utilities for advanced segment trees
class DebugSegmentTree {
public:
    static void print_tree_structure(const vector&lt;int&gt;&amp; tree, int node, int start, int end, int depth = 0) {
        for (int i = 0; i &lt; depth; i++) cout &lt;&lt; "  ";
        cout &lt;&lt; "Node " &lt;&lt; node &lt;&lt; " [" &lt;&lt; start &lt;&lt; "," &lt;&lt; end &lt;&lt; "]: " &lt;&lt; tree[node] &lt;&lt; "\n";
        
        if (start != end) {
            int mid = (start + end) / 2;
            print_tree_structure(tree, 2 * node, start, mid, depth + 1);
            print_tree_structure(tree, 2 * node + 1, mid + 1, end, depth + 1);
        }
    }
    
    static void verify_tree_walking(const vector&lt;int&gt;&amp; arr, int target) {
        cout &lt;&lt; "Verifying tree walking for target: " &lt;&lt; target &lt;&lt; "\n";
        
        // Brute force check
        int brute_result = -1;
        for (int i = 0; i &lt; arr.size(); i++) {
            if (arr[i] &gt;= target) {
                brute_result = i;
                break;
            }
        }
        
        cout &lt;&lt; "Brute force result: " &lt;&lt; brute_result &lt;&lt; "\n";
        // Compare with tree walking result
    }
    
    static void trace_walking_path(int target, const vector&lt;int&gt;&amp; tree, int node, int start, int end) {
        cout &lt;&lt; "Visiting node " &lt;&lt; node &lt;&lt; " [" &lt;&lt; start &lt;&lt; "," &lt;&lt; end &lt;&lt; "] value=" &lt;&lt; tree[node] &lt;&lt; "\n";
        
        if (start == end) {
            cout &lt;&lt; "Reached leaf: " &lt;&lt; start &lt;&lt; "\n";
            return;
        }
        
        int mid = (start + end) / 2;
        if (tree[2 * node] &gt;= target) {
            cout &lt;&lt; "Going left (left_max=" &lt;&lt; tree[2 * node] &lt;&lt; " &gt;= " &lt;&lt; target &lt;&lt; ")\n";
            trace_walking_path(target, tree, 2 * node, start, mid);
        } else {
            cout &lt;&lt; "Going right (left_max=" &lt;&lt; tree[2 * node] &lt;&lt; " &lt; " &lt;&lt; target &lt;&lt; ")\n";
            trace_walking_path(target, tree, 2 * node + 1, mid + 1, end);
        }
    }
};</code></pre>
            </div>
        </div>

        <div class="section hover-effect">
            <h2>Summary and Key Takeaways</h2>

            <div class="definition-box">
                Advanced Segment Tree applications transform basic range query data structures into powerful tools for complex algorithmic problems. Tree walking, coordinate compression, and persistent structures enable solutions to previously intractable problems.
            </div>

            <div class="problem-patterns">
                <div class="pattern-card">
                    <div class="pattern-title">What You've Mastered</div>
                    <ul style="padding-left: 20px; list-style: disc;">
                        <li>Tree walking techniques for O(log N) first-element queries</li>
                        <li>Coordinate compression for handling large value ranges</li>
                        <li>Ordered set implementation with dynamic order statistics</li>
                        <li>Advanced patterns: 2D queries, persistent structures</li>
                        <li>Optimization techniques and debugging strategies</li>
                    </ul>
                </div>
                <div class="pattern-card">
                    <div class="pattern-title">Next Learning Goals</div>
                    <ul style="padding-left: 20px; list-style: disc;">
                        <li>Persistent segment trees and version control</li>
                        <li>Fractional cascading and multi-dimensional queries</li>
                        <li>Segment tree beats and advanced lazy propagation</li>
                        <li>Integration with other advanced data structures</li>
                        <li>Parallel and cache-optimized implementations</li>
                    </ul>
                </div>
            </div>

            <div class="focus-problem">
                <strong>üéØ Practice Challenge:</strong><br>
                Now that you understand advanced segment tree techniques, try solving "Range Queries and Copies," "Kth Smallest in Range," or "Dynamic Rectangle Sum" to practice these advanced applications!
            </div>

            <div class="segtree-box">
                <strong>Real-World Impact:</strong> Advanced segment tree techniques are fundamental in database indexing, computational geometry, computer graphics, real-time systems, and any application requiring efficient dynamic range queries.
            </div>

            <div class="algorithm-box">
                <strong>Key Insight:</strong> The power of advanced segment trees lies in recognizing when tree structure can be exploited for more than just basic queries. Tree walking eliminates binary search overhead, while coordinate compression handles arbitrary value ranges efficiently.
            </div>

            <div class="complexity">
                <strong>Performance Summary:</strong> Advanced techniques often improve complexity from O(log¬≤N) to O(log N) per operation while enabling new types of queries. The trade-off is increased implementation complexity and memory usage.
            </div>

            <div class="tree-walking-box">
                <strong>Final Reminder:</strong> Always consider whether your range query problem can benefit from tree walking or coordinate compression. These techniques often transform difficult problems into standard segment tree applications. Master the walking pattern - it's a fundamental skill for advanced competitive programming!
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
</body>
</html>