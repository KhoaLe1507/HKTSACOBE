<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Topological Sort</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet">
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']]
            }
        };
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-weight: 600;
            line-height: 1.7;
            color: #2c3e50;
            background: white;
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 40px 20px;
            animation: fadeInUp 0.8s ease-out;
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        h1 {
            font-size: 3.5rem;
            font-weight: 800;
            color: #2c3e50;
            text-align: center;
            margin-bottom: 50px;
            position: relative;
            animation: slideInDown 1s ease-out;
        }

        @keyframes slideInDown {
            from {
                opacity: 0;
                transform: translateY(-50px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        h1::after {
            content: '';
            display: block;
            width: 250px;
            height: 4px;
            background: linear-gradient(90deg, #3498db, #2980b9);
            margin: 20px auto;
            border-radius: 2px;
            animation: expandLine 1.2s ease-out 0.5s both;
        }

        @keyframes expandLine {
            from {
                width: 0;
            }
            to {
                width: 250px;
            }
        }

        h2 {
            font-size: 2.4rem;
            font-weight: 700;
            color: #34495e;
            margin-top: 60px;
            margin-bottom: 25px;
            border-left: 5px solid #3498db;
            padding-left: 20px;
            animation: slideInLeft 0.6s ease-out;
        }

        @keyframes slideInLeft {
            from {
                opacity: 0;
                transform: translateX(-30px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        h3 {
            font-size: 1.9rem;
            font-weight: 700;
            color: #2c3e50;
            margin-top: 40px;
            margin-bottom: 20px;
            position: relative;
        }

        h3::before {
            content: 'üß†';
            margin-right: 10px;
            font-size: 0.9em;
        }

        p {
            font-size: 1.15rem;
            font-weight: 600;
            margin-bottom: 25px;
            text-align: justify;
            line-height: 1.8;
        }

        ul {
            margin: 25px 0;
            padding-left: 0;
        }

        li {
            font-size: 1.15rem;
            font-weight: 600;
            margin-bottom: 15px;
            line-height: 1.8;
            list-style: none;
            position: relative;
            padding-left: 30px;
        }

        li::before {
            content: 'üí°';
            position: absolute;
            left: 0;
            top: 0;
        }

        .code-container {
            background: #1e1e1e;
            border-radius: 12px;
            margin: 30px 0;
            overflow: hidden;
            box-shadow: 0 8px 25px rgba(0,0,0,0.15);
            border: 1px solid #333;
            animation: fadeIn 0.8s ease-out;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }

        .code-header {
            background: linear-gradient(90deg, #2c3e50, #34495e);
            color: white;
            padding: 12px 20px;
            font-weight: 700;
            font-size: 0.9rem;
            border-bottom: 1px solid #444;
        }

        pre {
            margin: 0 !important;
            background: #1e1e1e !important;
            border-radius: 0 !important;
        }

        code {
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace !important;
            font-size: 0.95rem !important;
            line-height: 1.6 !important;
            font-weight: 500 !important;
        }

        .line-numbers-rows {
            border-right: 1px solid #444 !important;
            padding-right: 10px !important;
            margin-right: 15px !important;
        }

        .complexity {
            background: linear-gradient(135deg, #fff8e1, #ffecb3);
            padding: 20px 25px;
            border-radius: 12px;
            border-left: 4px solid #3498db;
            margin: 25px 0;
            font-weight: 700;
            box-shadow: 0 4px 15px rgba(52, 152, 219, 0.1);
        }

        .warning {
            background: linear-gradient(135deg, #fff3cd, #ffeaa7);
            padding: 20px 25px;
            border-radius: 12px;
            border-left: 4px solid #ffc107;
            margin: 25px 0;
            font-weight: 700;
            box-shadow: 0 4px 15px rgba(255, 193, 7, 0.1);
        }

        .warning::before {
            content: '‚ö†Ô∏è ';
            font-size: 1.2em;
        }

        .section {
            margin-bottom: 50px;
            padding: 35px;
            background: #fafbfc;
            border-radius: 15px;
            border: 1px solid #e1e8ed;
            animation: slideInUp 0.6s ease-out;
        }

        @keyframes slideInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .focus-problem {
            background: linear-gradient(135deg, #e3f2fd, #bbdefb);
            padding: 25px;
            border-radius: 15px;
            margin: 30px 0;
            border: 2px solid #3498db;
            text-align: center;
            font-weight: 700;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% {
                box-shadow: 0 0 0 0 rgba(52, 152, 219, 0.4);
            }
            70% {
                box-shadow: 0 0 0 10px rgba(52, 152, 219, 0);
            }
            100% {
                box-shadow: 0 0 0 0 rgba(52, 152, 219, 0);
            }
        }

        .highlight {
            background: linear-gradient(120deg, #bbdefb 0%, #81c784 100%);
            padding: 3px 8px;
            border-radius: 6px;
            font-weight: 800;
        }

        .hover-effect {
            transition: all 0.3s ease;
        }

        .hover-effect:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 35px rgba(0,0,0,0.15);
        }

        .definition-box {
            background: linear-gradient(135deg, #e3f2fd, #bbdefb);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 4px solid #2196f3;
            font-weight: 700;
        }

        .definition-box::before {
            content: 'üìö Definition: ';
            font-weight: 800;
            color: #1976d2;
        }

        .algorithm-box {
            background: linear-gradient(135deg, #f3e5f5, #e1bee7);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 4px solid #9c27b0;
            font-weight: 700;
        }

        .algorithm-box::before {
            content: '‚ö° Key Insight: ';
            font-weight: 800;
            color: #7b1fa2;
        }

        .solution-header {
            color: #3498db;
            font-weight: 800;
            border-bottom: 3px solid #3498db;
            padding-bottom: 8px;
            display: inline-block;
            margin-bottom: 20px;
        }

        .math-display {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            margin: 25px 0;
            text-align: center;
            border: 2px solid #e9ecef;
            font-size: 1.2rem;
        }

        .dag-benefits-box {
            background: linear-gradient(135deg, #e8f5e8, #d4edda);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 4px solid #28a745;
            font-weight: 700;
        }

        .dag-benefits-box::before {
            content: 'üéØ DAG Benefits: ';
            font-weight: 800;
            color: #155724;
        }

        .topo-sort-box {
            background: linear-gradient(135deg, #f0f4f8, #ddd6fe);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 4px solid #8b5cf6;
            font-weight: 700;
        }

        .topo-sort-box::before {
            content: 'üîÑ Topological Sort: ';
            font-weight: 800;
            color: #7c3aed;
        }

        .step-by-step {
            background: linear-gradient(135deg, #fef7ff, #f3e8ff);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 4px solid #a855f7;
            font-weight: 700;
        }

        .step-by-step::before {
            content: 'üìù Algorithm Steps: ';
            font-weight: 800;
            color: #7c2d12;
        }

        .optimization-box {
            background: linear-gradient(135deg, #fef3c7, #fbbf24);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 4px solid #f59e0b;
            font-weight: 700;
        }

        .optimization-box::before {
            content: '‚ö° Optimization: ';
            font-weight: 800;
            color: #92400e;
        }

        .topo-visualization {
            background: #f8f9fa;
            padding: 30px;
            border-radius: 12px;
            margin: 30px 0;
            text-align: center;
            border: 2px solid #e9ecef;
        }

        .applications-box {
            background: linear-gradient(135deg, #f0f4f8, #ddd6fe);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 4px solid #8b5cf6;
            font-weight: 700;
        }

        .applications-box::before {
            content: 'üìñ Applications: ';
            font-weight: 800;
            color: #7c3aed;
        }

        .problem-patterns {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 20px;
            margin: 30px 0;
        }

        .pattern-card {
            background: white;
            border-radius: 12px;
            padding: 25px;
            border-left: 4px solid #3498db;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            transition: transform 0.3s ease;
        }

        .pattern-card:hover {
            transform: translateY(-5px);
        }

        .pattern-card:nth-child(1) {
            border-left-color: #e74c3c;
        }

        .pattern-card:nth-child(2) {
            border-left-color: #3498db;
        }

        .pattern-card:nth-child(3) {
            border-left-color: #2ecc71;
        }

        .pattern-title {
            font-weight: 800;
            color: #3498db;
            margin-bottom: 15px;
            font-size: 1.3rem;
        }

        .pattern-card:nth-child(1) .pattern-title {
            color: #e74c3c;
        }

        .pattern-card:nth-child(2) .pattern-title {
            color: #3498db;
        }

        .pattern-card:nth-child(3) .pattern-title {
            color: #2ecc71;
        }

        .dp-applications-box {
            background: linear-gradient(135deg, #ecfdf5, #d1fae5);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 4px solid #10b981;
            font-weight: 700;
        }

        .dp-applications-box::before {
            content: 'üöÄ DP on DAG: ';
            font-weight: 800;
            color: #047857;
        }

        .kahn-algorithm-box {
            background: linear-gradient(135deg, #e0f2fe, #b3e5fc);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 4px solid #0288d1;
            font-weight: 700;
        }

        .kahn-algorithm-box::before {
            content: 'üåä Kahn\'s Algorithm: ';
            font-weight: 800;
            color: #01579b;
        }

        .dfs-approach-box {
            background: linear-gradient(135deg, #fff3e0, #ffe0b2);
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            border-left: 4px solid #ff9800;
            font-weight: 600;
        }

        .dfs-approach-box::before {
            content: 'üå≤ DFS Approach: ';
            font-weight: 800;
            color: #f57c00;
        }

        .cycle-detection-box {
            background: linear-gradient(135deg, #ffebee, #ffcdd2);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 4px solid #f44336;
            font-weight: 700;
        }

        .cycle-detection-box::before {
            content: 'üîç Cycle Detection: ';
            font-weight: 800;
            color: #d32f2f;
        }

        .pro-tip-box {
            background: linear-gradient(135deg, #f0f9ff, #e0f2fe);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 4px solid #0ea5e9;
            font-weight: 700;
        }

        .pro-tip-box::before {
            content: 'üí° Pro Tip: ';
            font-weight: 800;
            color: #0284c7;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Topological Sort</h1>
        
        <div class="section hover-effect">
            <h2>Introduction to Directed Acyclic Graphs</h2>
            
            <p>To review, a <span class="highlight">directed graph</span> consists of edges that can only be traversed in one direction. Additionally, an <span class="highlight">acyclic graph</span> defines a graph which does not contain cycles, meaning you are unable to traverse across one or more edges and return to the node you started on. Putting these definitions together, a <span class="highlight">directed acyclic graph</span>, sometimes abbreviated as <span class="highlight">DAG</span>, is a graph which has edges which can only be traversed in one direction and does not contain cycles.</p>

            <div class="definition-box">
                A directed acyclic graph (DAG) is a directed graph with no directed cycles. It consists of vertices and edges, with each edge directed from one vertex to another, such that there is no way to start at any vertex and follow a consistently-directed sequence of edges that eventually loops back to that vertex.
            </div>

            <div class="dag-benefits-box">
                <strong>Why DAGs Matter:</strong><br>
                ‚Ä¢ <strong>Ordering:</strong> DAGs naturally represent dependency relationships<br>
                ‚Ä¢ <strong>Algorithms:</strong> Many graph algorithms work efficiently on DAGs<br>
                ‚Ä¢ <strong>Applications:</strong> Task scheduling, compilation, data processing pipelines<br>
                ‚Ä¢ <strong>Properties:</strong> Enable topological sorting and dynamic programming
            </div>

            <h3>Topological Sort Definition</h3>

            <div class="topo-sort-box">
                A topological sort of a directed acyclic graph is a linear ordering of its vertices such that for every directed edge u‚Üív from vertex u to vertex v, u comes before v in the ordering.
            </div>

            <div class="algorithm-box">
                <strong>Key Property:</strong> A topological sort is only possible if the graph is a DAG. If the graph contains cycles, no valid topological ordering exists because we cannot satisfy the ordering constraint for all edges in the cycle.
            </div>

            <div class="applications-box">
                <strong>Real-World Applications:</strong><br>
                ‚Ä¢ <strong>Course Prerequisites:</strong> Ordering courses based on prerequisites<br>
                ‚Ä¢ <strong>Build Systems:</strong> Determining compilation order for dependencies<br>
                ‚Ä¢ <strong>Task Scheduling:</strong> Scheduling tasks with dependencies<br>
                ‚Ä¢ <strong>Spreadsheet Calculations:</strong> Cell dependency resolution<br>
                ‚Ä¢ <strong>Package Management:</strong> Installing software packages in correct order
            </div>
        </div>

        <div class="section hover-effect">
            <h2>DFS-Based Topological Sort</h2>
            
            <p>There are two common ways to topologically sort: one involving <span class="highlight">DFS (Depth-First Search)</span> and the other involving <span class="highlight">BFS (Breadth-First Search)</span>. The DFS approach is intuitive and works by performing a depth-first search and adding nodes to the result in reverse order of their completion time.</p>

            <div class="dfs-approach-box">
                <strong>DFS Strategy:</strong> Visit nodes using DFS, and when we finish processing a node (all its descendants are processed), add it to the topological order. Finally, reverse the order to get the correct topological sort.
            </div>

            <div class="step-by-step">
                <strong>DFS Algorithm Steps:</strong><br>
                <strong>1.</strong> Start DFS from any unvisited node<br>
                <strong>2.</strong> For each node, recursively visit all its neighbors<br>
                <strong>3.</strong> Add the current node to result after visiting all neighbors<br>
                <strong>4.</strong> Reverse the final result to get topological order<br>
                <strong>5.</strong> Check if sorting is valid (no back edges found)
            </div>

            <div class="focus-problem">
                <strong>üéØ Focus Problem:</strong> Course Schedule<br>
                Try your best to solve this problem before continuing!
            </div>

            <h3 class="solution-header">DFS Implementation</h3>

            <div class="code-container">
                <div class="code-header">C++ - DFS Topological Sort</div>
                <pre class="line-numbers"><code class="language-cpp">#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

using std::cout;
using std::endl;
using std::vector;

vector&lt;int&gt; top_sort;
vector&lt;vector&lt;int&gt;&gt; graph;
vector&lt;bool&gt; visited;

void dfs(int node) {
    for (int next : graph[node]) {
        if (!visited[next]) {
            visited[next] = true;
            dfs(next);
        }
    }
    top_sort.push_back(node);
}

int main() {
    int n, m;  // The number of nodes and edges respectively
    std::cin &gt;&gt; n &gt;&gt; m;

    graph = vector&lt;vector&lt;int&gt;&gt;(n);
    for (int i = 0; i &lt; m; i++) {
        int a, b;
        std::cin &gt;&gt; a &gt;&gt; b;
        graph[a - 1].push_back(b - 1);
    }

    visited = vector&lt;bool&gt;(n);
    for (int i = 0; i &lt; n; i++) {
        if (!visited[i]) {
            visited[i] = true;
            dfs(i);
        }
    }
    std::reverse(top_sort.begin(), top_sort.end());

    vector&lt;int&gt; ind(n);
    for (int i = 0; i &lt; n; i++) { 
        ind[top_sort[i]] = i; 
    }

    // Check if the topological sort is valid
    bool valid = true;
    for (int i = 0; i &lt; n; i++) {
        for (int j : graph[i]) {
            if (ind[j] &lt;= ind[i]) {
                valid = false;
                goto answer;
            }
        }
    }
answer:;

    if (valid) {
        for (int i = 0; i &lt; n - 1; i++) { 
            cout &lt;&lt; top_sort[i] + 1 &lt;&lt; ' '; 
        }
        cout &lt;&lt; top_sort.back() + 1 &lt;&lt; endl;
    } else {
        cout &lt;&lt; "IMPOSSIBLE" &lt;&lt; endl;
    }
}</code></pre>
            </div>

            <div class="complexity">
                <strong>Time Complexity: $\mathcal{O}(V + E)$</strong><br>
                Where V is the number of vertices and E is the number of edges. Each vertex and edge is visited exactly once during the DFS traversal.
            </div>

            <div class="algorithm-box">
                <strong>Why Reverse?</strong> In DFS, we add nodes to the result after processing all their descendants. This means nodes with no outgoing edges (sinks) are added first. Since we want sources before sinks in topological order, we reverse the result.
            </div>
        </div>

        <div class="section hover-effect">
            <h2>BFS-Based Topological Sort (Kahn's Algorithm)</h2>

            <p>The BFS version is known as <span class="highlight">Kahn's Algorithm</span>. This algorithm works by repeatedly removing nodes with no incoming edges and adding them to the topological ordering. It's more intuitive than the DFS approach and naturally detects cycles.</p>

            <div class="kahn-algorithm-box">
                <strong>Kahn's Strategy:</strong> Start with nodes that have no dependencies (in-degree 0), add them to the result, and remove them from the graph. Repeat until all nodes are processed or a cycle is detected.
            </div>

            <div class="step-by-step">
                <strong>Kahn's Algorithm Steps:</strong><br>
                <strong>1.</strong> Calculate in-degree for each vertex<br>
                <strong>2.</strong> Add all vertices with in-degree 0 to a queue<br>
                <strong>3.</strong> While queue is not empty:<br>
                &nbsp;&nbsp;&nbsp;‚Ä¢ Remove a vertex from queue and add to result<br>
                &nbsp;&nbsp;&nbsp;‚Ä¢ For each neighbor, decrease its in-degree by 1<br>
                &nbsp;&nbsp;&nbsp;‚Ä¢ If neighbor's in-degree becomes 0, add it to queue<br>
                <strong>4.</strong> Check if all vertices are included (cycle detection)
            </div>

            <h3 class="solution-header">Kahn's Algorithm Implementation</h3>

            <div class="code-container">
                <div class="code-header">C++ - Kahn's Algorithm</div>
                <pre class="line-numbers"><code class="language-cpp">#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;queue&gt;
#include &lt;vector&gt;

using std::cout;
using std::endl;
using std::vector;

int main() {
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;

    vector&lt;vector&lt;int&gt;&gt; graph(n);
    for (int i = 0; i &lt; m; i++) {
        int a, b;
        std::cin &gt;&gt; a &gt;&gt; b;
        graph[a - 1].push_back(b - 1);
    }

    vector&lt;int&gt; in_degree(n);
    for (const vector&lt;int&gt; &amp;nodes : graph) {
        for (int node : nodes) { 
            in_degree[node]++; 
        }
    }

    std::queue&lt;int&gt; queue;
    for (int i = 0; i &lt; n; i++) {
        if (in_degree[i] == 0) { 
            queue.push(i); 
        }
    }
    
    vector&lt;int&gt; top_sort;
    while (!queue.empty()) {
        int curr = queue.front();
        queue.pop();
        top_sort.push_back(curr);
        
        for (int next : graph[curr]) {
            if (--in_degree[next] == 0) { 
                queue.push(next); 
            }
        }
    }

    if (top_sort.size() == n) {
        for (int i = 0; i &lt; n - 1; i++) { 
            cout &lt;&lt; top_sort[i] + 1 &lt;&lt; ' '; 
        }
        cout &lt;&lt; top_sort.back() + 1 &lt;&lt; endl;
    } else {
        cout &lt;&lt; "IMPOSSIBLE" &lt;&lt; endl;
    }
}</code></pre>
            </div>

            <div class="pro-tip-box">
                If the length of the array containing the end order does not equal the number of elements that need to be sorted, then there is a cycle in the graph.
            </div>

            <div class="optimization-box">
                <strong>Lexicographical Extension:</strong> We can also use Kahn's algorithm to extract the lexicographically minimum topological sort by breaking ties lexicographically. Simply replace the queue with a priority_queue to implement this extension.
            </div>

            <div class="topo-visualization">
                <strong>Kahn's Algorithm Visualization</strong>
                <p><strong>Step 1:</strong> Calculate in-degrees: [0, 1, 1, 2, 1]</p>
                <p><strong>Step 2:</strong> Queue initially contains: [0] (nodes with in-degree 0)</p>
                <p><strong>Step 3:</strong> Process node 0, reduce neighbors' in-degrees</p>
                <p><strong>Step 4:</strong> Continue until queue is empty or all nodes processed</p>
                <p><strong>Result:</strong> If all nodes processed ‚Üí valid topological sort</p>
            </div>
        </div>

        <div class="section hover-effect">
            <h2>Cycle Detection in Directed Graphs</h2>

            <p>We can modify the DFS algorithm above to return a directed cycle in the case where a topological sort does not exist. To find the cycle, we add each node we visit onto the stack until we detect a node already on the stack.</p>

            <div class="cycle-detection-box">
                <strong>Cycle Detection Strategy:</strong> Use DFS with a "recursion stack" to track the current path. If we encounter a node that's already in the current path, we've found a back edge, indicating a cycle.
            </div>

            <p>For example, suppose that our stack currently consists of $s_1, s_2, \ldots, s_i$ and we then visit $u = s_j$ for some $j \leq i$. If that's the case, then $s_j \to s_{j+1} \to \cdots \to s_i \to s_j$ is a cycle. We can reconstruct the cycle without explicitly storing the stack by marking $u$ as not part of the stack and recursively backtracking until $u$ is reached again.</p>

            <div class="warning">
                This code assumes that there are no self-loops, i.e. no edges from a node to itself.
            </div>

            <h3 class="solution-header">Cycle Detection Implementation</h3>

            <div class="code-container">
                <div class="code-header">C++ - Finding Directed Cycles</div>
                <pre class="line-numbers"><code class="language-cpp">#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

vector&lt;vector&lt;int&gt;&gt; graph;
vector&lt;bool&gt; visited, on_stack;
vector&lt;int&gt; cycle;

bool dfs(int node) {
    visited[node] = on_stack[node] = true;
    for (int next : graph[node]) {
        if (on_stack[next]) {
            cycle.push_back(node);  // start cycle
            on_stack[node] = on_stack[next] = false;
            return true;
        } else if (!visited[next]) {
            if (dfs(next)) {  // continue cycle
                if (on_stack[node]) {
                    cycle.push_back(node);
                    on_stack[node] = false;
                    return true;
                } else {  // found u again
                    cycle.push_back(node);
                    return false;
                }
            }

            if (!cycle.empty()) {
                return false;  // finished with cycle
            }
        }
    }

    on_stack[node] = false;
    return false;
}

int main() {
    int n, m;
    cin &gt;&gt; n &gt;&gt; m;
    graph = vector&lt;vector&lt;int&gt;&gt;(n);
    for (int i = 0; i &lt; m; i++) {
        int a, b;
        cin &gt;&gt; a &gt;&gt; b;
        graph[a - 1].push_back(b - 1);
    }

    visited = vector&lt;bool&gt;(n);
    on_stack = vector&lt;bool&gt;(n);
    for (int i = 0; cycle.empty() &amp;&amp; i &lt; n; i++) { 
        dfs(i); 
    }

    if (cycle.empty()) {
        cout &lt;&lt; "IMPOSSIBLE" &lt;&lt; endl;
    } else {
        reverse(cycle.begin(), cycle.end());
        cout &lt;&lt; cycle.size() + 1 &lt;&lt; "\n";
        for (int node : cycle) { 
            cout &lt;&lt; node + 1 &lt;&lt; " "; 
        }
        cout &lt;&lt; cycle[0] + 1 &lt;&lt; endl;
    }
}</code></pre>
            </div>

            <div class="step-by-step">
                <strong>Cycle Detection Steps:</strong><br>
                <strong>1.</strong> Maintain visited array and recursion stack (on_stack)<br>
                <strong>2.</strong> During DFS, mark current node as on stack<br>
                <strong>3.</strong> If we visit a node already on stack ‚Üí cycle found<br>
                <strong>4.</strong> Reconstruct cycle by backtracking through the path<br>
                <strong>5.</strong> Remove node from stack when backtracking
            </div>

            <div class="algorithm-box">
                <strong>Back Edge Detection:</strong> A back edge in DFS tree indicates a cycle. The on_stack array tracks the current DFS path, allowing us to detect when we encounter a node that's part of the current recursion chain.
            </div>
        </div>

        <div class="section hover-effect">
            <h2>Dynamic Programming on DAGs</h2>

            <p>One useful property of directed acyclic graphs is, as the name suggests, that no cycles exist. If we consider each node in the graph as a state, we can perform dynamic programming on the graph if we process the states in an order that guarantees for every edge $u \to v$ that $u$ is processed before $v$. Fortunately, this is the exact definition of a topological sort!</p>

            <div class="dp-applications-box">
                <strong>DP on DAG Benefits:</strong> Topological ordering ensures that when we compute DP values for a node, all its dependencies have already been computed. This eliminates the need for memoization and guarantees optimal substructure.
            </div>

            <h3>Example: Longest Path in DAG</h3>

            <div class="focus-problem">
                <strong>üéØ Focus Problem:</strong> Longest Flight Route<br>
                Find the longest path in a DAG from source to destination!
            </div>

            <p>In this task, we must find the longest path in a DAG. Let $dp[v]$ denote the length of the longest path ending at the node $v$. Clearly:</p>

            <div class="math-display">
                $dp[v] = \max_{\text{edge } u \to v \text{ exists}} dp[u] + 1$
            </div>

            <p>or $1$ if $v$ is node $1$. If we process the states in topological order, it is guaranteed that $dp[u]$ will already have been computed before computing $dp[v]$.</p>

            <div class="algorithm-box">
                <strong>Topological DP Pattern:</strong> Process nodes in topological order, ensuring all dependencies are resolved before computing each node's DP value. This guarantees correctness and optimal time complexity.
            </div>

            <h3 class="solution-header">Longest Path Solution</h3>

            <div class="code-container">
                <div class="code-header">C++ - Longest Path in DAG using Kahn's Algorithm</div>
                <pre class="line-numbers"><code class="language-cpp">#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;queue&gt;
#include &lt;vector&gt;

using std::cout;
using std::endl;
using std::vector;

int main() {
    int city_num, flight_num;
    std::cin &gt;&gt; city_num &gt;&gt; flight_num;

    vector&lt;vector&lt;int&gt;&gt; flights(city_num);
    vector&lt;vector&lt;int&gt;&gt; back_edge(city_num);
    for (int i = 0; i &lt; flight_num; i++) {
        int a, b;
        std::cin &gt;&gt; a &gt;&gt; b;
        flights[--a].push_back(--b);
        back_edge[b].push_back(a);
    }

    // Use Kahn's algorithm to do a topological sort
    vector&lt;int&gt; in_degree(city_num);
    for (const vector&lt;int&gt; &amp;nodes : flights) {
        for (int node : nodes) { 
            in_degree[node]++; 
        }
    }

    std::queue&lt;int&gt; queue;
    for (int i = 0; i &lt; city_num; i++) {
        if (in_degree[i] == 0) { 
            queue.push(i); 
        }
    }
    
    vector&lt;int&gt; top_sort;
    while (!queue.empty()) {
        int curr = queue.front();
        queue.pop();
        top_sort.push_back(curr);
        for (int next : flights[curr]) {
            if (--in_degree[next] == 0) { 
                queue.push(next); 
            }
        }
    }

    // Compute the dist array in topological order
    vector&lt;int&gt; parent(city_num, -1);
    vector&lt;int&gt; dist(city_num, INT32_MIN);
    dist[0] = 1;
    for (int i = 0; i &lt; top_sort.size(); i++) {
        int b = top_sort[i];
        for (int prev : back_edge[b]) {
            if (dist[prev] + 1 &gt; dist[b]) {
                dist[b] = dist[prev] + 1;
                parent[b] = prev;
            }
        }
    }

    if (dist[city_num - 1] &lt; 0) {
        cout &lt;&lt; "IMPOSSIBLE" &lt;&lt; endl;
    } else {
        // dist[city_num - 1] denotes the length of the longest path
        cout &lt;&lt; dist[city_num - 1] &lt;&lt; endl;

        // Begin from the final city, trace the parent pointer
        // to construct the entire path backward
        int at = city_num - 1;
        vector&lt;int&gt; route;
        while (parent[at] != -1) {
            route.push_back(at);
            at = parent[at];
        }
        route.push_back(0);

        // Print the route in the correct order
        std::reverse(route.begin(), route.end());
        for (int i = 0; i &lt; route.size() - 1; i++) { 
            cout &lt;&lt; route[i] + 1 &lt;&lt; ' '; 
        }
        cout &lt;&lt; route.back() + 1 &lt;&lt; endl;
    }
}</code></pre>
            </div>

            <div class="step-by-step">
                <strong>DP Solution Strategy:</strong><br>
                <strong>1.</strong> Perform topological sort using Kahn's algorithm<br>
                <strong>2.</strong> Initialize DP array with impossible values (except source)<br>
                <strong>3.</strong> Process nodes in topological order<br>
                <strong>4.</strong> For each node, update DP values of its neighbors<br>
                <strong>5.</strong> Reconstruct path using parent pointers
            </div>

            <div class="complexity">
                <strong>Time Complexity: $\mathcal{O}(V + E)$</strong><br>
                The topological sort takes O(V + E) time, and the DP computation also takes O(V + E) time since we process each edge exactly once.
            </div>
        </div>

        <div class="section hover-effect">
            <h2>Common Topological Sort Problem Patterns</h2>

            <div class="problem-patterns">
                <div class="pattern-card">
                    <div class="pattern-title">üìö Course Scheduling</div>
                    <p><strong>Problem:</strong> Determine if all courses can be completed given prerequisites<br>
                    <strong>Approach:</strong> Model as DAG, check if topological sort exists<br>
                    <strong>Examples:</strong> Course prerequisites, project dependencies</p>
                </div>
                
                <div class="pattern-card">
                    <div class="pattern-title">üèóÔ∏è Build Dependencies</div>
                    <p><strong>Problem:</strong> Determine compilation order for dependent modules<br>
                    <strong>Approach:</strong> Use topological sort to find valid build order<br>
                    <strong>Examples:</strong> Make files, package managers, build systems</p>
                </div>
                
                <div class="pattern-card">
                    <div class="pattern-title">üéØ Path Optimization</div>
                    <p><strong>Problem:</strong> Find longest/shortest paths in DAGs<br>
                    <strong>Approach:</strong> Use DP with topological ordering<br>
                    <strong>Examples:</strong> Critical path method, resource allocation</p>
                </div>
            </div>

            <h3>Advanced Applications</h3>

            <div class="applications-box">
                <strong>Industry Applications:</strong><br>
                ‚Ä¢ <strong>Compiler Design:</strong> Instruction scheduling and optimization<br>
                ‚Ä¢ <strong>Project Management:</strong> Critical path method (CPM)<br>
                ‚Ä¢ <strong>Database Systems:</strong> Query optimization and execution plans<br>
                ‚Ä¢ <strong>Version Control:</strong> Git merge strategies and conflict resolution<br>
                ‚Ä¢ <strong>Manufacturing:</strong> Assembly line optimization and workflow design
            </div>

            <h3>Comparison: DFS vs BFS Approaches</h3>

            <div class="topo-visualization">
                <strong>Algorithm Comparison</strong>
                <table style="margin: 20px auto; border-collapse: collapse; font-family: 'Courier New', monospace; font-weight: 700;">
                    <tr style="background: #34495e; color: white;">
                        <td style="padding: 10px; border: 2px solid #34495e;">Aspect</td>
                        <td style="padding: 10px; border: 2px solid #34495e;">DFS Approach</td>
                        <td style="padding: 10px; border: 2px solid #34495e;">BFS (Kahn's)</td>
                    </tr>
                    <tr>
                        <td style="padding: 10px; border: 1px solid #bdc3c7; background: #ecf0f1;"><strong>Complexity</strong></td>
                        <td style="padding: 10px; border: 1px solid #bdc3c7;">O(V + E)</td>
                        <td style="padding: 10px; border: 1px solid #bdc3c7;">O(V + E)</td>
                    </tr>
                    <tr>
                        <td style="padding: 10px; border: 1px solid #bdc3c7; background: #ecf0f1;"><strong>Cycle Detection</strong></td>
                        <td style="padding: 10px; border: 1px solid #bdc3c7;">Requires extra logic</td>
                        <td style="padding: 10px; border: 1px solid #bdc3c7;">Natural (count nodes)</td>
                    </tr>
                    <tr>
                        <td style="padding: 10px; border: 1px solid #bdc3c7; background: #ecf0f1;"><strong>Implementation</strong></td>
                        <td style="padding: 10px; border: 1px solid #bdc3c7;">Recursive (stack)</td>
                        <td style="padding: 10px; border: 1px solid #bdc3c7;">Iterative (queue)</td>
                    </tr>
                    <tr>
                        <td style="padding: 10px; border: 1px solid #bdc3c7; background: #ecf0f1;"><strong>Memory</strong></td>
                        <td style="padding: 10px; border: 1px solid #bdc3c7;">O(V) recursion</td>
                        <td style="padding: 10px; border: 1px solid #bdc3c7;">O(V) queue</td>
                    </tr>
                </table>
            </div>

            <div class="optimization-box">
                <strong>Algorithm Choice:</strong> Use Kahn's algorithm when you need natural cycle detection or prefer iterative implementation. Use DFS when you need to detect specific cycles or when implementing other DFS-based algorithms simultaneously.
            </div>
        </div>

        <div class="section hover-effect">
            <h2>Implementation Tips and Best Practices</h2>

            <h3>Common Implementation Mistakes</h3>

            <div class="warning">
                <strong>Pitfall Prevention:</strong><br>
                ‚Ä¢ Don't forget to reverse the result in DFS-based approach<br>
                ‚Ä¢ Always check if topological sort is possible (count nodes in Kahn's)<br>
                ‚Ä¢ Handle disconnected components properly<br>
                ‚Ä¢ Be careful with 0-indexed vs 1-indexed problems<br>
                ‚Ä¢ Initialize in-degree array correctly in Kahn's algorithm
            </div>

            <h3>Template for Competitive Programming</h3>

            <div class="code-container">
                <div class="code-header">C++ - Topological Sort Template</div>
                <pre class="line-numbers"><code class="language-cpp">// Compact topological sort template
vector&lt;int&gt; topological_sort(vector&lt;vector&lt;int&gt;&gt;&amp; graph) {
    int n = graph.size();
    vector&lt;int&gt; in_degree(n, 0);
    
    // Calculate in-degrees
    for (int i = 0; i &lt; n; i++) {
        for (int j : graph[i]) {
            in_degree[j]++;
        }
    }
    
    // Kahn's algorithm
    queue&lt;int&gt; q;
    for (int i = 0; i &lt; n; i++) {
        if (in_degree[i] == 0) {
            q.push(i);
        }
    }
    
    vector&lt;int&gt; result;
    while (!q.empty()) {
        int curr = q.front();
        q.pop();
        result.push_back(curr);
        
        for (int next : graph[curr]) {
            if (--in_degree[next] == 0) {
                q.push(next);
            }
        }
    }
    
    // Return empty vector if cycle exists
    return result.size() == n ? result : vector&lt;int&gt;();
}</code></pre>
            </div>

            <h3>Debugging Topological Sort</h3>

            <div class="algorithm-box">
                <strong>Debug Strategy:</strong> Print intermediate states like in-degrees, queue contents, and current topological order. This helps identify issues with graph construction or algorithm logic.
            </div>

            <div class="code-container">
                <div class="code-header">C++ - Debug Helper Functions</div>
                <pre class="line-numbers"><code class="language-cpp">// Add these functions for debugging topological sort
void print_graph(const vector&lt;vector&lt;int&gt;&gt;&amp; graph) {
    cout &lt;&lt; "Graph adjacency list:\n";
    for (int i = 0; i &lt; graph.size(); i++) {
        cout &lt;&lt; i &lt;&lt; ": ";
        for (int j : graph[i]) {
            cout &lt;&lt; j &lt;&lt; " ";
        }
        cout &lt;&lt; "\n";
    }
}

void print_in_degrees(const vector&lt;int&gt;&amp; in_degree) {
    cout &lt;&lt; "In-degrees: ";
    for (int i = 0; i &lt; in_degree.size(); i++) {
        cout &lt;&lt; "(" &lt;&lt; i &lt;&lt; ":" &lt;&lt; in_degree[i] &lt;&lt; ") ";
    }
    cout &lt;&lt; "\n";
}</code></pre>
            </div>
        </div>

        <div class="section hover-effect">
            <h2>Summary and Key Takeaways</h2>

            <div class="definition-box">
                Topological sorting is a fundamental algorithm for ordering vertices in a directed acyclic graph such that all dependencies are respected. It forms the backbone of many important algorithms and real-world applications.
            </div>

            <div class="problem-patterns">
                <div class="pattern-card">
                    <div class="pattern-title">What You've Mastered</div>
                    <ul style="padding-left: 20px; list-style: disc;">
                        <li>Understanding of DAGs and their properties</li>
                        <li>Two main topological sorting algorithms</li>
                        <li>Cycle detection in directed graphs</li>
                        <li>Dynamic programming on DAGs</li>
                        <li>Real-world applications and problem patterns</li>
                    </ul>
                </div>
                <div class="pattern-card">
                    <div class="pattern-title">Next Learning Goals</div>
                    <ul style="padding-left: 20px; list-style: disc;">
                        <li>Practice with course scheduling problems</li>
                        <li>Explore strongly connected components</li>
                        <li>Study advanced DP on DAG techniques</li>
                        <li>Learn about parallel algorithms</li>
                        <li>Solve contest problems involving topological sort</li>
                    </ul>
                </div>
            </div>

            <div class="focus-problem">
                <strong>üéØ Practice Challenge:</strong><br>
                Now that you understand topological sorting, try solving "Course Schedule II," "Alien Dictionary," or "Parallel Courses" to practice different applications and build your problem-solving skills!
            </div>

            <div class="dag-benefits-box">
                <strong>Real-World Impact:</strong> Topological sorting algorithms are essential in compilers, build systems, project management software, database query optimizers, and any system dealing with dependencies and ordering constraints.
            </div>

            <div class="dp-applications-box">
                <strong>Key Insight:</strong> Topological sorting transforms dependency problems into linear ordering problems, enabling efficient solutions to complex scheduling and optimization challenges.
            </div>

            <div class="algorithm-box">
                <strong>Performance Guarantee:</strong> Both DFS and BFS approaches provide O(V + E) time complexity, making topological sorting highly efficient even for large graphs with complex dependency structures.
            </div>

            <div class="complexity">
                <strong>Final Reminder:</strong> Topological sorting is often the key insight that transforms complex dependency problems into tractable linear-time solutions. Always consider topological sort when dealing with ordering, scheduling, or prerequisite problems.
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
</body>
</html>