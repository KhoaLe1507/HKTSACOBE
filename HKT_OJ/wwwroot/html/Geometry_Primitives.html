<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Geometry Primitives</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet">
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']]
            }
        };
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-weight: 600;
            line-height: 1.7;
            color: #2c3e50;
            background: white;
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 40px 20px;
            animation: fadeInUp 0.8s ease-out;
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        h1 {
            font-size: 3.5rem;
            font-weight: 800;
            color: #2c3e50;
            text-align: center;
            margin-bottom: 50px;
            position: relative;
            animation: slideInDown 1s ease-out;
        }

        @keyframes slideInDown {
            from {
                opacity: 0;
                transform: translateY(-50px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        h1::after {
            content: '';
            display: block;
            width: 350px;
            height: 4px;
            background: linear-gradient(90deg, #3498db, #2980b9);
            margin: 20px auto;
            border-radius: 2px;
            animation: expandLine 1.2s ease-out 0.5s both;
        }

        @keyframes expandLine {
            from {
                width: 0;
            }
            to {
                width: 350px;
            }
        }

        h2 {
            font-size: 2.4rem;
            font-weight: 700;
            color: #34495e;
            margin-top: 60px;
            margin-bottom: 25px;
            border-left: 5px solid #3498db;
            padding-left: 20px;
            animation: slideInLeft 0.6s ease-out;
        }

        @keyframes slideInLeft {
            from {
                opacity: 0;
                transform: translateX(-30px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        h3 {
            font-size: 1.9rem;
            font-weight: 700;
            color: #2c3e50;
            margin-top: 40px;
            margin-bottom: 20px;
            position: relative;
        }

        h3::before {
            content: 'üìê';
            margin-right: 10px;
            font-size: 0.9em;
        }

        p {
            font-size: 1.15rem;
            font-weight: 600;
            margin-bottom: 25px;
            text-align: justify;
            line-height: 1.8;
        }

        .code-container {
            background: #1e1e1e;
            border-radius: 12px;
            margin: 30px 0;
            overflow: hidden;
            box-shadow: 0 8px 25px rgba(0,0,0,0.15);
            border: 1px solid #333;
            animation: fadeIn 0.8s ease-out;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }

        .code-header {
            background: linear-gradient(90deg, #3498db, #2980b9);
            color: white;
            padding: 12px 20px;
            font-weight: 700;
            font-size: 0.9rem;
            border-bottom: 1px solid #444;
        }

        pre {
            margin: 0 !important;
            background: #1e1e1e !important;
            border-radius: 0 !important;
        }

        code {
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace !important;
            font-size: 0.95rem !important;
            line-height: 1.6 !important;
            font-weight: 500 !important;
        }

        .line-numbers-rows {
            border-right: 1px solid #444 !important;
            padding-right: 10px !important;
            margin-right: 15px !important;
        }

        .complexity {
            background: linear-gradient(135deg, #e8f5e8, #d4edda);
            padding: 20px 25px;
            border-radius: 12px;
            border-left: 4px solid #28a745;
            margin: 25px 0;
            font-weight: 700;
            box-shadow: 0 4px 15px rgba(40, 167, 69, 0.1);
        }

        .section {
            margin-bottom: 50px;
            padding: 35px;
            background: #fafbfc;
            border-radius: 15px;
            border: 1px solid #e1e8ed;
            animation: slideInUp 0.6s ease-out;
        }

        @keyframes slideInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .hover-effect {
            transition: all 0.3s ease;
        }

        .hover-effect:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 35px rgba(0,0,0,0.15);
        }

        .highlight {
            background: linear-gradient(120deg, #3498db 0%, #2980b9 100%);
            color: white;
            padding: 3px 8px;
            border-radius: 6px;
            font-weight: 800;
        }

        .algorithm-box {
            background: linear-gradient(135deg, #e8f5e8, #d4edda);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 4px solid #28a745;
            font-weight: 700;
        }

        .algorithm-box::before {
            content: '‚ö° Key Insight: ';
            font-weight: 800;
            color: #155724;
        }

        .explanation-box {
            background: linear-gradient(135deg, #e3f2fd, #bbdefb);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 4px solid #2196f3;
            font-weight: 700;
        }

        .explanation-box::before {
            content: 'üìö Explanation: ';
            font-weight: 800;
            color: #1976d2;
        }

        .formula-box {
            background: linear-gradient(135deg, #fff3e0, #ffe0b2);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 4px solid #ff9800;
            font-weight: 700;
        }

        .formula-box::before {
            content: 'üßÆ Formula: ';
            font-weight: 800;
            color: #f57c00;
        }

        .focus-problem {
            background: linear-gradient(135deg, #fef9e7, #f9e79f);
            padding: 25px;
            border-radius: 15px;
            margin: 30px 0;
            border: 2px solid #3498db;
            text-align: center;
            font-weight: 700;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% {
                box-shadow: 0 0 0 0 rgba(52, 152, 219, 0.4);
            }
            70% {
                box-shadow: 0 0 0 10px rgba(52, 152, 219, 0);
            }
            100% {
                box-shadow: 0 0 0 0 rgba(52, 152, 219, 0);
            }
        }

        .math-formula {
            background: #f8f9fa;
            padding: 4px 8px;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            font-weight: 700;
            color: #2d3748;
            border: 1px solid #e9ecef;
        }

        .step-list {
            counter-reset: step-counter;
            list-style: none;
            padding: 0;
            margin: 25px 0;
        }

        .step-list li {
            counter-increment: step-counter;
            margin: 20px 0;
            padding: 20px;
            background: #f8fafc;
            border-radius: 10px;
            border-left: 4px solid #3498db;
            position: relative;
            font-weight: 600;
        }

        .step-list li::before {
            content: counter(step-counter);
            position: absolute;
            left: -15px;
            top: 15px;
            background: #3498db;
            color: white;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            font-size: 0.9rem;
        }

        .introduction-box {
            background: linear-gradient(135deg, #fef9e7, #f9e79f);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 4px solid #3498db;
            font-weight: 700;
        }

        .introduction-box::before {
            content: 'üìê Geometry Primitives: ';
            font-weight: 800;
            color: #e67e22;
        }

        .solution-header {
            color: #3498db;
            font-weight: 800;
            border-bottom: 3px solid #3498db;
            padding-bottom: 8px;
            display: inline-block;
            margin-bottom: 20px;
        }

        .subtitle {
            font-size: 1.3rem;
            color: #718096;
            font-weight: 600;
            text-align: center;
            margin-bottom: 20px;
        }

        .collinear-box {
            background: linear-gradient(135df, #f3e5f5, #e1bee7);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 4px solid #9c27b0;
            font-weight: 700;
        }

        .collinear-box::before {
            content: 'üìè Collinearity Test: ';
            font-weight: 800;
            color: #7b1fa2;
        }

        .intersection-box {
            background: linear-gradient(135deg, #ffebee, #ffcdd2);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 4px solid #f44336;
            font-weight: 700;
        }

        .intersection-box::before {
            content: '‚ö° Segment Intersection: ';
            font-weight: 800;
            color: #d32f2f;
        }

        .area-box {
            background: linear-gradient(135deg, #e8f5e8, #d4edda);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 4px solid #28a745;
            font-weight: 700;
        }

        .area-box::before {
            content: 'üìê Area Calculation: ';
            font-weight: 800;
            color: #155724;
        }

        .ray-casting-box {
            background: linear-gradient(135deg, #f0f4f8, #ddd6fe);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 4px solid #8b5cf6;
            font-weight: 700;
        }

        .ray-casting-box::before {
            content: 'üéØ Ray Casting: ';
            font-weight: 800;
            color: #7c3aed;
        }

        .picks-theorem-box {
            background: linear-gradient(135deg, #fff3e0, #ffe0b2);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 4px solid #ff9800;
            font-weight: 700;
        }

        .picks-theorem-box::before {
            content: 'üî¢ Pick\'s Theorem: ';
            font-weight: 800;
            color: #f57c00;
        }

        .implementation-box {
            background: linear-gradient(135deg, #e3f2fd, #bbdefb);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 4px solid #2196f3;
            font-weight: 700;
        }

        .implementation-box::before {
            content: '‚öôÔ∏è Implementation: ';
            font-weight: 800;
            color: #1976d2;
        }

        .shoelace-box {
            background: linear-gradient(135deg, #e8f5e8, #d4edda);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 4px solid #28a745;
            font-weight: 700;
        }

        .shoelace-box::before {
            content: 'üëü Shoelace Formula: ';
            font-weight: 800;
            color: #155724;
        }

        ul {
            margin: 25px 0;
            padding-left: 0;
        }

        li {
            font-size: 1.15rem;
            font-weight: 600;
            margin-bottom: 15px;
            line-height: 1.8;
            list-style: none;
            position: relative;
            padding-left: 30px;
        }

        li::before {
            content: 'üîπ';
            position: absolute;
            left: 0;
            top: 0;
        }

        .applications-box {
            background: linear-gradient(135deg, #f0f4f8, #ddd6fe);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 4px solid #8b5cf6;
            font-weight: 700;
        }

        .applications-box::before {
            content: 'üìñ Applications: ';
            font-weight: 800;
            color: #7c3aed;
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 2.5rem;
            }
            
            .section {
                padding: 25px;
            }
            
            code {
                font-size: 0.85rem !important;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Geometry Primitives</h1>
        <p class="subtitle">Fundamental Computational Geometry Algorithms</p>
        
        <div class="section hover-effect">
            <h2>Introduction</h2>
            
            <div class="introduction-box">
                Computational geometry is a fundamental area in competitive programming that deals with algorithms for solving geometric problems. Geometry primitives are the basic building blocks that enable us to solve complex geometric problems efficiently.
            </div>

            <div class="applications-box">
                <strong>Core Geometry Primitives:</strong><br>
                ‚Ä¢ <strong>Point Location:</strong> Determining position relative to lines and polygons<br>
                ‚Ä¢ <strong>Line Intersection:</strong> Finding where geometric objects intersect<br>
                ‚Ä¢ <strong>Area Calculation:</strong> Computing areas of polygons using mathematical formulas<br>
                ‚Ä¢ <strong>Distance Computation:</strong> Measuring distances between geometric objects<br>
                ‚Ä¢ <strong>Convex Hull:</strong> Finding the smallest convex boundary around points<br>
                ‚Ä¢ <strong>Polygon Operations:</strong> Testing containment, intersection, and other properties
            </div>

            <div class="algorithm-box">
                <strong>Why These Primitives Matter:</strong> These fundamental operations form the foundation for more complex geometric algorithms. Mastering them is essential for solving advanced problems in computational geometry, computer graphics, and robotics.
            </div>
        </div>

        <div class="section hover-effect">
            <h2>Point Location Relative to Line</h2>
            
            <h3 class="solution-header">Explanation</h3>

            <div class="explanation-box">
                To check the <span class="math-formula">P</span> location towards the <span class="math-formula">P_1</span> <span class="math-formula">P_2</span> line we use the following formula: <span class="math-formula">$(P.y - P_1.y) \times (P_2.x - P_1.x) - (P.x - P_1.x) \times (P_2.y - P_1.y)$</span>
            </div>

            <div class="collinear-box">
                <strong>Result Interpretation:</strong><br>
                ‚Ä¢ If the result equals <span class="math-formula">0</span>, it means that <span class="math-formula">P</span>, <span class="math-formula">P_1</span> and <span class="math-formula">P_2</span> are collinear<br>
                ‚Ä¢ If the result is negative, <span class="math-formula">P</span> is under the line (right side)<br>
                ‚Ä¢ If the result is positive, <span class="math-formula">P</span> is above the line (left side)
            </div>

            <div class="algorithm-box">
                <strong>Cross Product Intuition:</strong> This formula computes the cross product of vectors (P‚ÇÅP) and (P‚ÇÅP‚ÇÇ). The sign of the cross product indicates the orientation of these vectors, which corresponds to the relative position of point P with respect to the directed line P‚ÇÅP‚ÇÇ.
            </div>

            <h3 class="solution-header">Demonstration</h3>

            <div class="formula-box">
                <strong>Mathematical Foundation:</strong><br>
                The formula is based on the determinant:<br>
                $$\begin{vmatrix} P.x - P_1.x & P_2.x - P_1.x \\ P.y - P_1.y & P_2.y - P_1.y \end{vmatrix}$$<br>
                This determinant gives us the signed area of the parallelogram formed by the vectors, which indicates orientation.
            </div>

            <h3 class="solution-header">Implementation</h3>

            <div class="complexity">
                <strong>Time Complexity: $\mathcal{O}(1)$ for each test case</strong>
            </div>

            <div class="code-container">
                <div class="code-header">
                    C++ - Point Location Implementation
                </div>
                <pre class="line-numbers"><code class="language-cpp">#include <bits/stdc++.h>
using namespace std;

// Code Snippet: Point Class (Click to expand)
struct Point {
    long long x, y;
    Point() {}
    Point(long long x, long long y) : x(x), y(y) {}
    Point operator-(const Point& p) const { return Point(x - p.x, y - p.y); }
    friend istream& operator>>(istream& is, Point& p) { return is >> p.x >> p.y; }
};

long long collinear(Point p, Point p1, Point p2) {
    return 1LL * (p.y - p1.y) * (p2.x - p1.x) - 1LL * (p.x - p1.x) * (p2.y - p1.y);
}

int main() {
    int test_num;
    cin >> test_num;
    for (int t = 0; t < test_num; t++) {
        Point p1, p2, p3;
        cin >> p1 >> p2 >> p3;

        if (collinear(p1, p2, p3) == 0) {
            cout << "TOUCH" << '\n';
        } else if (collinear(p1, p2, p3) < 0) {
            cout << "RIGHT" << '\n';
        } else {
            cout << "LEFT" << '\n';
        }
    }
}</code></pre>
            </div>
        </div>

        <div class="section hover-effect">
            <h2>Segment Intersection</h2>
            
            <div class="focus-problem">
                <strong>üéØ Line Segment Intersection</strong><br>
                <em>CSES - Medium</em><br>
                Focus Problem ‚Äì try your best to solve this problem before continuing!
            </div>

            <h3 class="solution-header">Explanation</h3>

            <div class="intersection-box">
                We can quickly dismiss the segment intersection by treating them as rectangles having the segments as diagonals which can be easily done. If it turns out the rectangles intersect then we just check if the segment's ends are on different sides of the other segment.
            </div>

            <div class="algorithm-box">
                <strong>Two-Step Approach:</strong><br>
                <strong>1. Quick Rectangle Check:</strong> First, check if the bounding rectangles of the segments intersect<br>
                <strong>2. Orientation Test:</strong> If rectangles intersect, verify that endpoints are on opposite sides of each segment
            </div>

            <ol class="step-list">
                <li>Create axis-aligned bounding rectangles for both segments</li>
                <li>Check if these rectangles intersect (quick rejection test)</li>
                <li>If rectangles don't intersect, segments definitely don't intersect</li>
                <li>If rectangles intersect, perform orientation tests on segment endpoints</li>
                <li>Segments intersect if endpoints are on opposite sides of each other</li>
            </ol>

            <h3 class="solution-header">Implementation</h3>

            <div class="code-container">
                <div class="code-header">
                    C++ - Segment Intersection Implementation
                </div>
                <pre class="line-numbers"><code class="language-cpp">#include <bits/stdc++.h>
using namespace std;

// Code Snippet: Point Class (Click to expand)
struct Point {
    long long x, y;
    Point() {}
    Point(long long x, long long y) : x(x), y(y) {}
    Point operator-(const Point& p) const { return Point(x - p.x, y - p.y); }
    friend istream& operator>>(istream& is, Point& p) { return is >> p.x >> p.y; }
};

int sign(long long num) {
    if (num < 0) {
        return -1;
    } else if (num == 0) {
        return 0;
    } else {
        return 1;
    }
}

long long trigonometric_sense(Point p, Point p1, Point p2) {
    return sign(1LL * (p1.x - p.x) * (p2.y - p.y) - 1LL * (p2.x - p.x) * (p1.y - p.y));
}

// Check if the rectangles with [P1, P2] and [P3, P4] as diagonals intersect
bool quick_check(Point p1, Point p2, Point p3, Point p4) {
    int x1, x2, x3, x4, y1, y2, y3, y4;
    x1 = min(p1.x, p2.x), x2 = max(p1.x, p2.x);
    y1 = min(p1.y, p2.y), y2 = max(p1.y, p2.y);
    x3 = min(p3.x, p4.x), x4 = max(p3.x, p4.x);
    y3 = min(p3.y, p4.y), y4 = max(p3.y, p4.y);
    return x2 < x3 || x4 < x1 || y2 < y3 || y4 < y1;
}

bool check(Point p1, Point p2, Point p3, Point p4) {
    if (trigonometric_sense(p1, p2, p3) * trigonometric_sense(p1, p2, p4) > 0) {
        return false;
    }
    if (trigonometric_sense(p3, p4, p1) * trigonometric_sense(p3, p4, p2) > 0) {
        return false;
    }
    return true;
}

int main() {
    int test_num;
    cin >> test_num;
    for (int t = 0; t < test_num; t++) {
        Point p1, p2, p3, p4;
        cin >> p1 >> p2 >> p3 >> p4;

        if (quick_check(p1, p2, p3, p4)) {
            puts("NO");
        } else if (check(p1, p2, p3, p4)) {
            puts("YES");
        } else {
            puts("NO");
        }
    }
}</code></pre>
            </div>
        </div>

        <div class="section hover-effect">
            <h2>Polygon Area</h2>
            
            <div class="focus-problem">
                <strong>üéØ Polygon Area</strong><br>
                <em>CSES - Medium</em><br>
                Focus Problem ‚Äì try your best to solve this problem before continuing!
            </div>

            <h3 class="solution-header">Explanation</h3>

            <div class="shoelace-box">
                We can use the Shoelace formula (also known as the surveyor's formula) to calculate the area of any simple polygon given the coordinates of its vertices.
            </div>

            <div class="formula-box">
                <strong>Shoelace Formula:</strong><br>
                For a polygon with vertices $(x_1, y_1), (x_2, y_2), \ldots, (x_n, y_n)$:<br>
                $$\text{Area} = \frac{1}{2} \left| \sum_{i=1}^{n} (x_i y_{i+1} - x_{i+1} y_i) \right|$$<br>
                where $(x_{n+1}, y_{n+1}) = (x_1, y_1)$ (the first vertex is repeated)
            </div>

            <div class="algorithm-box">
                <strong>Why It Works:</strong> The Shoelace formula computes the signed area by summing the areas of trapezoids formed between each edge and the x-axis. The absolute value gives the actual area regardless of vertex ordering (clockwise or counterclockwise).
            </div>

            <h3 class="solution-header">Implementation</h3>

            <div class="complexity">
                <strong>Time Complexity: $\mathcal{O}(N)$</strong><br>
                <strong>Space Complexity: $\mathcal{O}(N)$</strong>
            </div>

            <div class="code-container">
                <div class="code-header">
                    C++ - Polygon Area Implementation
                </div>
                <pre class="line-numbers"><code class="language-cpp">#include <bits/stdc++.h>
using namespace std;

// Code Snippet: Point Class (Click to expand)
struct Point {
    long long x, y;
    Point() {}
    Point(long long x, long long y) : x(x), y(y) {}
    Point operator-(const Point& p) const { return Point(x - p.x, y - p.y); }
    friend istream& operator>>(istream& is, Point& p) { return is >> p.x >> p.y; }
};

int main() {
    int n;
    cin >> n;
    vector<Point> points(n);
    for (auto &p : points) { cin >> p; }
    points.push_back(points[0]);

    long long area = 0;
    for (int i = 0; i < n; i++) {
        area += (1LL * points[i].x * points[i + 1].y - 1LL * points[i].y * points[i + 1].x);
    }
    cout << abs(area) << '\n';
}</code></pre>
            </div>
        </div>

        <div class="section hover-effect">
            <h2>Point's Location Relative to Polygon</h2>
            
            <div class="focus-problem">
                <strong>üéØ Point in Polygon</strong><br>
                <em>CSES - Medium</em><br>
                Focus Problem ‚Äì try your best to solve this problem before continuing!
            </div>

            <h3 class="solution-header">Explanation</h3>

            <div class="ray-casting-box">
                We can cast a ray from the point <span class="math-formula">P</span> going in any fixed direction (people usually go to the right). If the point is located on the outside of the polygon the ray will intersect its edges an even number of times. If the point is on the inside of the polygon then it will intersect the edge an odd number of times.
            </div>

            <div class="algorithm-box">
                <strong>Ray Casting Algorithm:</strong> This approach is called ray casting. The fundamental principle is based on the Jordan curve theorem: a point is inside a simple polygon if and only if a ray from the point crosses the polygon boundary an odd number of times.
            </div>

            <ol class="step-list">
                <li>Cast a horizontal ray from point P to the right (towards positive infinity)</li>
                <li>Count the number of intersections with polygon edges</li>
                <li>Handle special cases: ray passing through vertices, point on boundary</li>
                <li>If intersection count is odd, point is inside; if even, point is outside</li>
                <li>If point lies exactly on boundary, report as boundary case</li>
            </ol>

            <h3 class="solution-header">Implementation</h3>

            <div class="code-container">
                <div class="code-header">
                    C++ - Point in Polygon Implementation
                </div>
                <pre class="line-numbers"><code class="language-cpp">#include <bits/stdc++.h>
using namespace std;

// Code Snippet: Point Class (Click to expand)
struct Point {
    long long x, y;
    Point() {}
    Point(long long x, long long y) : x(x), y(y) {}
    Point operator-(const Point& p) const { return Point(x - p.x, y - p.y); }
    friend istream& operator>>(istream& is, Point& p) { return is >> p.x >> p.y; }
};

bool on_segment(const Point &p, const Point &p1, const Point &p2) {
    int a = min(p1.x, p2.x);
    int b = max(p1.x, p2.x);
    int x = min(p1.y, p2.y);
    int y = max(p1.y, p2.y);
    return 1LL * (p.y - p1.y) * (p2.x - p1.x) == 1LL * (p.x - p1.x) * (p2.y - p1.y) &&
           a <= p.x && p.x <= b && x <= p.y && p.y <= y;
}

long long trigonometric_sense(Point p, Point p1, Point p2) {
    return 1LL * (p1.x - p.x) * (p2.y - p.y) - 1LL * (p2.x - p.x) * (p1.y - p.y);
}

int main() {
    int n, m;
    cin >> n >> m;
    vector<Point> poly(n);
    for (Point &p : poly) { cin >> p; }
    for (int j = 0; j < m; j++) {
        Point p;
        cin >> p;
        // Intersection count
        int cnt = 0;
        bool flag = false;
        for (int i = 0; i < n; i++) {
            int j = (i + 1) % n;
            if (on_segment(p, poly[i], poly[j])) {
                flag = true;
                break;
            }
            if (poly[i].y <= p.y && p.y < poly[j].y &&
                trigonometric_sense(p, poly[i], poly[j]) > 0)
                cnt++;
            if (poly[j].y <= p.y && p.y < poly[i].y &&
                trigonometric_sense(p, poly[j], poly[i]) > 0)
                cnt++;
        }
        if (flag) {
            cout << "BOUNDARY" << '\n';
        } else {
            cout << (cnt % 2 ? "INSIDE" : "OUTSIDE") << '\n';
        }
    }
}</code></pre>
            </div>
        </div>

        <div class="section hover-effect">
            <h2>Lattice Points in Polygon</h2>
            
            <div class="focus-problem">
                <strong>üéØ Polygon Lattice Points</strong><br>
                <em>CSES - Medium</em><br>
                Focus Problem ‚Äì try your best to solve this problem before continuing!
            </div>

            <h3 class="solution-header">Explanation</h3>

            <div class="explanation-box">
                Let's first focus on the lattice points on the polygon's boundary. We'll process each edge individually. The number of intersections of a line with lattice points is the greatest common divisor of <span class="math-formula">|P_1.x - P_2.x|</span> and <span class="math-formula">|P_1.y - P_2.y|</span>.
            </div>

            <div class="algorithm-box">
                <strong>Boundary Points:</strong> For a line segment from point (x‚ÇÅ, y‚ÇÅ) to (x‚ÇÇ, y‚ÇÇ), the number of lattice points on the segment (including endpoints) is gcd(|x‚ÇÇ - x‚ÇÅ|, |y‚ÇÇ - y‚ÇÅ|) + 1. However, to avoid double-counting vertices, we use just the GCD value.
            </div>

            <h3 class="solution-header">Demonstration</h3>

            <div class="picks-theorem-box">
                Now that we know the number of lattice points on the boundary we can find the number of lattice points inside the polygon using Pick's theorem. Let's denote <span class="math-formula">A</span> polygon's area, <span class="math-formula">i</span> the number of integer points inside and <span class="math-formula">b</span> the number of integer points on its boundary.
            </div>

            <div class="formula-box">
                <strong>Pick's Theorem:</strong><br>
                $A = i + \frac{b}{2} - 1$<br>
                Rearranging to solve for interior points:<br>
                $i = A - \frac{b}{2} + 1$<br>
                Where <span class="math-formula">A</span> is the area, <span class="math-formula">i</span> is interior points, and <span class="math-formula">b</span> is boundary points.
            </div>

            <div class="algorithm-box">
                <strong>Complete Solution:</strong> We've found <span class="math-formula">b</span> using GCD calculations, and <span class="math-formula">A</span> can be computed using the Shoelace formula from the previous section. Pick's theorem then gives us the interior points directly.
            </div>

            <h3 class="solution-header">Implementation</h3>

            <div class="complexity">
                <strong>Time Complexity: $\mathcal{O}(N \log P)$</strong><br>
                where <span class="math-formula">P</span> is the maximum difference between coordinates of points
            </div>

            <div class="code-container">
                <div class="code-header">
                    C++ - Lattice Points Implementation
                </div>
                <pre class="line-numbers"><code class="language-cpp">#include <bits/stdc++.h>
using namespace std;

// Code Snippet: Point Class (Click to expand)
struct Point {
    long long x, y;
    Point() {}
    Point(long long x, long long y) : x(x), y(y) {}
    Point operator-(const Point& p) const { return Point(x - p.x, y - p.y); }
    friend istream& operator>>(istream& is, Point& p) { return is >> p.x >> p.y; }
};

int main() {
    int n;
    cin >> n;
    vector<Point> points(n);
    for (Point &point : points) { cin >> point; }
    points.push_back(points[0]);
    
    long long area = 0;
    for (int i = 0; i < n; i++) {
        area += (1LL * points[i].x * points[i + 1].y - 1LL * points[i].y * points[i + 1].x);
    }
    area = abs(area);
    
    long long boundary_points = 0;
    for (int i = 0; i < n; i++) {
        Point diff = points[i + 1] - points[i];
        int g = gcd(abs(diff.x), abs(diff.y));
        boundary_points += g;
    }
    
    long long interior_points = (area - boundary_points) / 2 + 1;
    cout << interior_points << ' ' << boundary_points;
}</code></pre>
            </div>
        </div>

        <div class="section hover-effect">
            <h2>Advanced Concepts and Applications</h2>

            <h3 class="solution-header">Computational Geometry Techniques</h3>

            <div class="algorithm-box">
                <strong>Precision and Robustness:</strong> In competitive programming, we often use integer coordinates to avoid floating-point precision issues. The cross product and orientation tests naturally work with integers, making our algorithms robust and reliable.
            </div>

            <div class="implementation-box">
                <strong>Implementation Tips:</strong><br>
                ‚Ä¢ Always use <code>long long</code> for coordinate calculations to prevent overflow<br>
                ‚Ä¢ Be careful with edge cases: collinear points, vertical/horizontal lines<br>
                ‚Ä¢ Test with degenerate cases: single points, line segments, zero-area polygons<br>
                ‚Ä¢ Use consistent orientation (clockwise vs counterclockwise) throughout<br>
                ‚Ä¢ Handle boundary conditions explicitly in ray casting algorithms
            </div>

            <h3 class="solution-header">Extensions and Variations</h3>

            <div class="applications-box">
                <strong>Advanced Applications:</strong><br>
                ‚Ä¢ <strong>Convex Hull:</strong> Finding the smallest convex polygon containing all points<br>
                ‚Ä¢ <strong>Line Sweep:</strong> Processing geometric events in sorted order<br>
                ‚Ä¢ <strong>Closest Pair:</strong> Finding the minimum distance between points<br>
                ‚Ä¢ <strong>Voronoi Diagrams:</strong> Partitioning space based on nearest neighbors<br>
                ‚Ä¢ <strong>Triangulation:</strong> Decomposing polygons into triangles<br>
                ‚Ä¢ <strong>Boolean Operations:</strong> Union, intersection, difference of polygons
            </div>

            <div class="formula-box">
                <strong>Vector Operations:</strong><br>
                ‚Ä¢ <strong>Dot Product:</strong> <span class="math-formula">a ¬∑ b = a.x √ó b.x + a.y √ó b.y</span> (measures angle)<br>
                ‚Ä¢ <strong>Cross Product:</strong> <span class="math-formula">a √ó b = a.x √ó b.y - a.y √ó b.x</span> (measures orientation)<br>
                ‚Ä¢ <strong>Distance:</strong> <span class="math-formula">d = \sqrt{(x_2-x_1)^2 + (y_2-y_1)^2}</span><br>
                ‚Ä¢ <strong>Manhattan Distance:</strong> <span class="math-formula">d = |x_2-x_1| + |y_2-y_1|</span>
            </div>

            <h3 class="solution-header">Common Pitfalls and Solutions</h3>

            <div class="intersection-box">
                <strong>Floating Point Issues:</strong> Avoid floating-point arithmetic when possible. Use integer coordinates and exact arithmetic. When floating-point is necessary, use appropriate epsilon values for comparisons.
            </div>

            <div class="ray-casting-box">
                <strong>Edge Cases in Ray Casting:</strong> Handle rays passing through vertices carefully. Use consistent rules for boundary intersections (e.g., count intersections where ray crosses from bottom to top, but not top to bottom).
            </div>

            <div class="area-box">
                <strong>Orientation Consistency:</strong> Ensure consistent vertex ordering in polygons. Counterclockwise ordering typically gives positive area, while clockwise gives negative area. Use absolute value when only magnitude matters.
            </div>
        </div>

        <div class="section hover-effect">
            <h2>Summary and Key Takeaways</h2>

            <div class="algorithm-box">
                Geometry primitives form the foundation of computational geometry. By mastering these basic operations, you can solve complex geometric problems efficiently and reliably.
            </div>

            <div class="introduction-box">
                <strong>What You've Mastered:</strong><br>
                ‚Ä¢ Point-line orientation tests using cross products<br>
                ‚Ä¢ Segment intersection algorithms with bounding box optimization<br>
                ‚Ä¢ Polygon area calculation using the Shoelace formula<br>
                ‚Ä¢ Point-in-polygon testing with ray casting<br>
                ‚Ä¢ Lattice point counting using Pick's theorem<br>
                ‚Ä¢ Robust integer-based implementations for competitive programming
            </div>

            <div class="focus-problem">
                <strong>üéØ Practice Challenge:</strong><br>
                Try implementing these primitives for different geometric problems: convex hull construction, closest pair of points, and line sweep algorithms. Build a comprehensive geometry library for competitive programming!
            </div>

            <div class="picks-theorem-box">
                <strong>Key Mathematical Tools:</strong><br>
                ‚Ä¢ <strong>Cross Product:</strong> Fundamental for orientation and area calculations<br>
                ‚Ä¢ <strong>Shoelace Formula:</strong> Efficient polygon area computation<br>
                ‚Ä¢ <strong>Pick's Theorem:</strong> Relationship between area, boundary, and interior lattice points<br>
                ‚Ä¢ <strong>Jordan Curve Theorem:</strong> Theoretical foundation for point-in-polygon tests<br>
                ‚Ä¢ <strong>GCD Properties:</strong> Counting lattice points on line segments
            </div>

            <div class="complexity">
                <strong>Performance Summary:</strong><br>
                ‚Ä¢ <strong>Point-Line Test:</strong> <span class="math-formula">$\mathcal{O}(1)$</span><br>
                ‚Ä¢ <strong>Segment Intersection:</strong> <span class="math-formula">$\mathcal{O}(1)$</span><br>
                ‚Ä¢ <strong>Polygon Area:</strong> <span class="math-formula">$\mathcal{O}(N)$</span><br>
                ‚Ä¢ <strong>Point in Polygon:</strong> <span class="math-formula">$\mathcal{O}(N)$</span><br>
                ‚Ä¢ <strong>Lattice Points:</strong> <span class="math-formula">$\mathcal{O}(N \log P)$</span>
            </div>

            <div class="applications-box">
                <strong>Real-World Applications:</strong><br>
                ‚Ä¢ <strong>Computer Graphics:</strong> Rendering, clipping, and collision detection<br>
                ‚Ä¢ <strong>GIS Systems:</strong> Geographic information processing and spatial queries<br>
                ‚Ä¢ <strong>Robotics:</strong> Path planning and obstacle avoidance<br>
                ‚Ä¢ <strong>CAD Software:</strong> Design validation and geometric modeling<br>
                ‚Ä¢ <strong>Game Development:</strong> Physics simulation and spatial partitioning<br>
                ‚Ä¢ <strong>Manufacturing:</strong> CNC machining and quality control
            </div>

            <div class="implementation-box">
                <strong>Final Advice:</strong> Practice implementing these primitives until they become second nature. Focus on correctness first, then optimization. Always test with edge cases and maintain consistent coordinate systems. These fundamentals will serve as building blocks for more advanced geometric algorithms.
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
</body>
</html>