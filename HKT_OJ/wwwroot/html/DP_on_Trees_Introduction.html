<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DP on Trees - Introduction</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet">
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']]
            }
        };
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-weight: 600;
            line-height: 1.7;
            color: #2c3e50;
            background: white;
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 40px 20px;
            animation: fadeInUp 0.8s ease-out;
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        h1 {
            font-size: 3.5rem;
            font-weight: 800;
            color: #2c3e50;
            text-align: center;
            margin-bottom: 50px;
            position: relative;
            animation: slideInDown 1s ease-out;
        }

        @keyframes slideInDown {
            from {
                opacity: 0;
                transform: translateY(-50px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        h1::after {
            content: '';
            display: block;
            width: 320px;
            height: 4px;
            background: linear-gradient(90deg, #e74c3c, #ec7063);
            margin: 20px auto;
            border-radius: 2px;
            animation: expandLine 1.2s ease-out 0.5s both;
        }

        @keyframes expandLine {
            from {
                width: 0;
            }
            to {
                width: 320px;
            }
        }

        h2 {
            font-size: 2.4rem;
            font-weight: 700;
            color: #34495e;
            margin-top: 60px;
            margin-bottom: 25px;
            border-left: 5px solid #e74c3c;
            padding-left: 20px;
            animation: slideInLeft 0.6s ease-out;
        }

        @keyframes slideInLeft {
            from {
                opacity: 0;
                transform: translateX(-30px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        h3 {
            font-size: 1.9rem;
            font-weight: 700;
            color: #2c3e50;
            margin-top: 40px;
            margin-bottom: 20px;
            position: relative;
        }

        h3::before {
            content: 'üß†';
            margin-right: 10px;
            font-size: 0.9em;
        }

        p {
            font-size: 1.15rem;
            font-weight: 600;
            margin-bottom: 25px;
            text-align: justify;
            line-height: 1.8;
        }

        ul {
            margin: 25px 0;
            padding-left: 0;
        }

        li {
            font-size: 1.15rem;
            font-weight: 600;
            margin-bottom: 15px;
            line-height: 1.8;
            list-style: none;
            position: relative;
            padding-left: 30px;
        }

        li::before {
            content: 'üí°';
            position: absolute;
            left: 0;
            top: 0;
        }

        .code-container {
            background: #1e1e1e;
            border-radius: 12px;
            margin: 30px 0;
            overflow: hidden;
            box-shadow: 0 8px 25px rgba(0,0,0,0.15);
            border: 1px solid #333;
            animation: fadeIn 0.8s ease-out;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }

        .code-header {
            background: linear-gradient(90deg, #2c3e50, #34495e);
            color: white;
            padding: 12px 20px;
            font-weight: 700;
            font-size: 0.9rem;
            border-bottom: 1px solid #444;
        }

        pre {
            margin: 0 !important;
            background: #1e1e1e !important;
            border-radius: 0 !important;
        }

        code {
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace !important;
            font-size: 0.95rem !important;
            line-height: 1.6 !important;
            font-weight: 500 !important;
        }

        .line-numbers-rows {
            border-right: 1px solid #444 !important;
            padding-right: 10px !important;
            margin-right: 15px !important;
        }

        .complexity {
            background: linear-gradient(135deg, #fadbd8, #f1948a);
            padding: 20px 25px;
            border-radius: 12px;
            border-left: 4px solid #e74c3c;
            margin: 25px 0;
            font-weight: 700;
            box-shadow: 0 4px 15px rgba(231, 76, 60, 0.1);
        }

        .warning {
            background: linear-gradient(135deg, #fff3cd, #ffeaa7);
            padding: 20px 25px;
            border-radius: 12px;
            border-left: 4px solid #ffc107;
            margin: 25px 0;
            font-weight: 700;
            box-shadow: 0 4px 15px rgba(255, 193, 7, 0.1);
        }

        .warning::before {
            content: '‚ö†Ô∏è ';
            font-size: 1.2em;
        }

        .section {
            margin-bottom: 50px;
            padding: 35px;
            background: #fafbfc;
            border-radius: 15px;
            border: 1px solid #e1e8ed;
            animation: slideInUp 0.6s ease-out;
        }

        @keyframes slideInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .focus-problem {
            background: linear-gradient(135deg, #fadbd8, #f1948a);
            padding: 25px;
            border-radius: 15px;
            margin: 30px 0;
            border: 2px solid #e74c3c;
            text-align: center;
            font-weight: 700;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% {
                box-shadow: 0 0 0 0 rgba(231, 76, 60, 0.4);
            }
            70% {
                box-shadow: 0 0 0 10px rgba(231, 76, 60, 0);
            }
            100% {
                box-shadow: 0 0 0 0 rgba(231, 76, 60, 0);
            }
        }

        .highlight {
            background: linear-gradient(120deg, #f1948a 0%, #74b9ff 100%);
            padding: 3px 8px;
            border-radius: 6px;
            font-weight: 800;
        }

        .hover-effect {
            transition: all 0.3s ease;
        }

        .hover-effect:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 35px rgba(0,0,0,0.15);
        }

        .definition-box {
            background: linear-gradient(135deg, #fadbd8, #f1948a);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 4px solid #e74c3c;
            font-weight: 700;
        }

        .definition-box::before {
            content: 'üìö Definition: ';
            font-weight: 800;
            color: #c0392b;
        }

        .algorithm-box {
            background: linear-gradient(135deg, #e8f5e8, #d4edda);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 4px solid #28a745;
            font-weight: 700;
        }

        .algorithm-box::before {
            content: '‚ö° Key Insight: ';
            font-weight: 800;
            color: #155724;
        }

        .solution-header {
            color: #e74c3c;
            font-weight: 800;
            border-bottom: 3px solid #e74c3c;
            padding-bottom: 8px;
            display: inline-block;
            margin-bottom: 20px;
        }

        .math-display {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            margin: 25px 0;
            text-align: center;
            border: 2px solid #e9ecef;
            font-size: 1.2rem;
        }

        .dp-on-trees-box {
            background: linear-gradient(135deg, #fadbd8, #f1948a);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 4px solid #e74c3c;
            font-weight: 700;
        }

        .dp-on-trees-box::before {
            content: 'üå≤ DP on Trees: ';
            font-weight: 800;
            color: #c0392b;
        }

        .step-by-step {
            background: linear-gradient(135deg, #fef7ff, #f3e8ff);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 4px solid #a855f7;
            font-weight: 700;
        }

        .step-by-step::before {
            content: 'üìù Algorithm Steps: ';
            font-weight: 800;
            color: #7c2d12;
        }

        .optimization-box {
            background: linear-gradient(135deg, #fef3c7, #fbbf24);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 4px solid #f59e0b;
            font-weight: 700;
        }

        .optimization-box::before {
            content: '‚ö° Optimization: ';
            font-weight: 800;
            color: #92400e;
        }

        .dp-visualization {
            background: #f8f9fa;
            padding: 30px;
            border-radius: 12px;
            margin: 30px 0;
            text-align: center;
            border: 2px solid #e9ecef;
        }

        .applications-box {
            background: linear-gradient(135deg, #f0f4f8, #ddd6fe);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 4px solid #8b5cf6;
            font-weight: 700;
        }

        .applications-box::before {
            content: 'üìñ Applications: ';
            font-weight: 800;
            color: #7c3aed;
        }

        .problem-patterns {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 20px;
            margin: 30px 0;
        }

        .pattern-card {
            background: white;
            border-radius: 12px;
            padding: 25px;
            border-left: 4px solid #e74c3c;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            transition: transform 0.3s ease;
        }

        .pattern-card:hover {
            transform: translateY(-5px);
        }

        .pattern-card:nth-child(1) {
            border-left-color: #e74c3c;
        }

        .pattern-card:nth-child(2) {
            border-left-color: #3498db;
        }

        .pattern-card:nth-child(3) {
            border-left-color: #2ecc71;
        }

        .pattern-title {
            font-weight: 800;
            color: #e74c3c;
            margin-bottom: 15px;
            font-size: 1.3rem;
        }

        .pattern-card:nth-child(1) .pattern-title {
            color: #e74c3c;
        }

        .pattern-card:nth-child(2) .pattern-title {
            color: #3498db;
        }

        .pattern-card:nth-child(3) .pattern-title {
            color: #2ecc71;
        }

        .tree-matching-box {
            background: linear-gradient(135deg, #e3f2fd, #bbdefb);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 4px solid #2196f3;
            font-weight: 700;
        }

        .tree-matching-box::before {
            content: 'üîó Tree Matching: ';
            font-weight: 800;
            color: #1976d2;
        }

        .greedy-approach-box {
            background: linear-gradient(135deg, #fff3e0, #ffe0b2);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 4px solid #ff9800;
            font-weight: 700;
        }

        .greedy-approach-box::before {
            content: 'üéØ Greedy Approach: ';
            font-weight: 800;
            color: #f57c00;
        }

        .dp-states-box {
            background: linear-gradient(135deg, #f3e5f5, #e1bee7);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 4px solid #9c27b0;
            font-weight: 700;
        }

        .dp-states-box::before {
            content: 'üé≤ DP States: ';
            font-weight: 800;
            color: #7b1fa2;
        }

        .transitions-box {
            background: linear-gradient(135deg, #e0f2fe, #b3e5fc);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 4px solid #0288d1;
            font-weight: 700;
        }

        .transitions-box::before {
            content: 'üîÑ Transitions: ';
            font-weight: 800;
            color: #01579b;
        }

        .pro-tip-box {
            background: linear-gradient(135deg, #ecfdf5, #d1fae5);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 4px solid #10b981;
            font-weight: 700;
        }

        .pro-tip-box::before {
            content: 'üí° Pro Tip: ';
            font-weight: 800;
            color: #047857;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>DP on Trees - Introduction</h1>
        
        <div class="section hover-effect">
            <h2>Introduction to Dynamic Programming on Trees</h2>
            
            <p><span class="highlight">Dynamic Programming on Trees</span> is a powerful technique that combines the principles of dynamic programming with the hierarchical structure of trees. This approach allows us to solve complex tree problems efficiently by breaking them down into smaller subproblems based on subtrees.</p>

            <div class="definition-box">
                DP on Trees involves defining states for each node that represent optimal solutions for the subtree rooted at that node. We compute these states by combining information from child nodes, typically using a bottom-up approach through DFS traversal.
            </div>

            <div class="dp-on-trees-box">
                <strong>Core Concept:</strong> The tree structure naturally provides optimal substructure - the solution for a subtree can be computed independently of other subtrees, and the global optimal solution can be constructed from these local solutions.
            </div>

            <div class="pro-tip-box">
                Don't just dive into trying to figure out a DP state and transitions -- make some observations if you don't see any obvious DP solution! Also, sometimes a greedy strategy suffices in place of DP.
            </div>

            <div class="applications-box">
                <strong>Common DP on Trees Problems:</strong><br>
                ‚Ä¢ <strong>Tree Matching:</strong> Maximum independent set of edges<br>
                ‚Ä¢ <strong>Tree Distance:</strong> Maximum/minimum path lengths<br>
                ‚Ä¢ <strong>Tree Coloring:</strong> Optimal vertex coloring strategies<br>
                ‚Ä¢ <strong>Subtree Optimization:</strong> Maximum subtree properties<br>
                ‚Ä¢ <strong>Path Queries:</strong> Optimal paths between vertices
            </div>

            <div class="algorithm-box">
                <strong>Why DP on Trees Works:</strong> Trees are acyclic structures where each node has a unique path to the root. This eliminates the overlapping subproblems that make general graph DP complex, allowing for clean recursive solutions with optimal substructure.
            </div>
        </div>

        <div class="section hover-effect">
            <h2>Tree Matching Problem</h2>

            <p>In this problem, we're asked to find the maximum matching of a tree, or the largest set of edges such that no two edges share an endpoint. Let's use DP on trees to solve this classic problem.</p>

            <div class="focus-problem">
                <strong>üéØ Focus Problem:</strong> Tree Matching<br>
                Find the maximum matching in a tree - the largest set of edges with no shared endpoints!
            </div>

            <div class="tree-matching-box">
                <strong>Problem Analysis:</strong> A matching in a tree is a set of edges where no two edges share a common vertex. Our goal is to find the maximum number of such edges. This is equivalent to finding the maximum independent set in the line graph of the tree.
            </div>

            <h3>DP Solution Approach</h3>

            <p>Root the tree at node $1$, allowing us to define the subtree of each node. We'll define two DP states for each vertex that capture different scenarios.</p>

            <div class="dp-states-box">
                <strong>DP State Definition:</strong><br>
                ‚Ä¢ <strong>dp‚ÇÇ[v]:</strong> Maximum matching in subtree of v, taking NO edges from v to its children<br>
                ‚Ä¢ <strong>dp‚ÇÅ[v]:</strong> Maximum matching in subtree of v, taking EXACTLY ONE edge from v to a child<br><br>
                Note: We can't take more than one edge from v to children, as they would share endpoint v.
            </div>

            <h3>Transition 1: Taking No Edges</h3>

            <p>Since we will take no edges to a child of $v$, the children vertices of $v$ can all take an edge to some child, or not. Additionally, observe that the children of $v$ taking an edge to a child will not prevent other children of $v$ from doing the same. In other words, all of the children are independent.</p>

            <div class="math-display">
                $$dp_2[v] = \sum_{u \in child(v)} \max(dp_1[u], dp_2[u])$$
            </div>

            <div class="transitions-box">
                <strong>No Edge Transition Logic:</strong> When we don't use any edge from v to its children, each child u can independently choose its best option - either use one edge to its children (dp‚ÇÅ[u]) or use no edges to its children (dp‚ÇÇ[u]).
            </div>

            <h3>Transition 2: Taking One Edge</h3>

            <p>The case where we take one child edge of $v$ is a bit trickier. Let's assume the edge we take is $v \rightarrow u$, where $u \in child(v)$. Then, to calculate $dp_1[v]$ for the fixed $u$:</p>

            <div class="math-display">
                $$dp_1[v] = dp_2[u] + 1 + dp_2[v] - \max(dp_2[u], dp_1[u])$$
            </div>

            <div class="step-by-step">
                <strong>One Edge Transition Breakdown:</strong><br>
                <strong>1.</strong> We take edge v ‚Üí u, contributing +1 to the matching<br>
                <strong>2.</strong> Since edge v ‚Üí u is used, u cannot take any edges to its children: dp‚ÇÇ[u]<br>
                <strong>3.</strong> Other children w ‚â† u can choose optimally: Œ£ max(dp‚ÇÅ[w], dp‚ÇÇ[w])<br>
                <strong>4.</strong> This sum equals dp‚ÇÇ[v] - max(dp‚ÇÅ[u], dp‚ÇÇ[u]) (already computed)<br>
                <strong>5.</strong> Try all possible children u and take the maximum
            </div>

            <div class="math-display">
                $$dp_1[v] = \max_{u \in child(v)} (dp_2[u] + 1 + dp_2[v] - \max(dp_2[u], dp_1[u]))$$
            </div>

            <div class="warning">
                Loop through the children of v twice to calculate dp‚ÇÅ[v] and dp‚ÇÇ[v] separately! You need to know dp‚ÇÇ[v] to calculate dp‚ÇÅ[v].
            </div>

            <h3 class="solution-header">DP Implementation</h3>

            <div class="code-container">
                <div class="code-header">C++ - Tree Matching DP Solution</div>
                <pre class="line-numbers"><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
using ll = long long;
using vi = vector&lt;int&gt;;
#define pb push_back
#define rsz resize
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
using pi = pair&lt;int, int&gt;;
#define f first
#define s second
#define mp make_pair

void setIO(string name = "") {  // name is nonempty for USACO file I/O
    ios_base::sync_with_stdio(0);
    cin.tie(0);  // see Fast Input &amp; Output
    if (sz(name)) {
        freopen((name + ".in").c_str(), "r", stdin);  // see Input &amp; Output
        freopen((name + ".out").c_str(), "w", stdout);
    }
}

vi adj[200005];
int dp[200005][2];

void dfs(int v, int p) {
    // First pass: calculate dp[v][0] (taking no edges to children)
    for (int to : adj[v]) {
        if (to != p) {
            dfs(to, v);
            dp[v][0] += max(dp[to][0], dp[to][1]);
        }
    }
    
    // Second pass: calculate dp[v][1] (taking one edge to a child)
    for (int to : adj[v]) {
        if (to != p) {
            dp[v][1] = max(dp[v][1], 
                          dp[to][0] + 1 + dp[v][0] - max(dp[to][0], dp[to][1]));
        }
    }
}

int main() {
    setIO();
    int n;
    cin &gt;&gt; n;
    for (int i = 0; i &lt; n - 1; i++) {
        int u, v;
        cin &gt;&gt; u &gt;&gt; v;
        u--, v--;
        adj[u].pb(v), adj[v].pb(u);
    }
    dfs(0, -1);
    cout &lt;&lt; max(dp[0][0], dp[0][1]) &lt;&lt; '\n';
}</code></pre>
            </div>

            <div class="complexity">
                <strong>Time Complexity: $\mathcal{O}(N)$</strong><br>
                We visit each node exactly once during DFS, and for each node, we process its children twice (once for each DP state). This gives us linear time complexity.
            </div>

            <div class="algorithm-box">
                <strong>DP Correctness:</strong> The recurrence relations ensure that we consider all possible ways to form a maximum matching. The base case (leaves) naturally have dp[leaf][0] = 0 and dp[leaf][1] = 0, and we build up the solution bottom-up.
            </div>
        </div>

        <div class="section hover-effect">
            <h2>Alternative: Greedy Solution</h2>

            <p>Interestingly, the tree matching problem can also be solved using a simple greedy approach. This demonstrates that sometimes DP might be overkill, and a simpler strategy suffices.</p>

            <div class="greedy-approach-box">
                <strong>Greedy Strategy:</strong> Just keep matching a leaf with the only vertex adjacent to it while possible. This works because in a tree, there's always at least one leaf, and it's always optimal to match a leaf with its parent if possible.
            </div>

            <div class="step-by-step">
                <strong>Greedy Algorithm Steps:</strong><br>
                <strong>1.</strong> Perform DFS traversal from any root<br>
                <strong>2.</strong> Process nodes in post-order (children before parent)<br>
                <strong>3.</strong> For each node, if neither it nor its parent is already matched, match them<br>
                <strong>4.</strong> This ensures we greedily match leaves with their parents when possible
            </div>

            <h3 class="solution-header">Greedy Implementation</h3>

            <div class="code-container">
                <div class="code-header">C++ - Tree Matching Greedy Solution</div>
                <pre class="line-numbers"><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
using vi = vector&lt;int&gt;;
#define pb push_back

int n;
vi adj[200005];
bool done[200005];
int ans = 0;

void dfs(int pre, int cur) {
    for (int i : adj[cur]) {
        if (i != pre) {
            dfs(cur, i);
            // After processing child i, try to match cur with i
            if (!done[i] &amp;&amp; !done[cur]) {
                done[cur] = done[i] = true;
                ans++;
            }
        }
    }
}

int main() {
    ios_base::sync_with_stdio(0);
    cin.tie(0);
    cin &gt;&gt; n;
    for (int i = 0; i &lt; n - 1; i++) {
        int a, b;
        cin &gt;&gt; a &gt;&gt; b;
        adj[a].pb(b), adj[b].pb(a);
    }
    dfs(0, 1);
    cout &lt;&lt; ans;
}</code></pre>
            </div>

            <div class="algorithm-box">
                <strong>Greedy Correctness:</strong> The greedy approach works because in any optimal matching, we can always rearrange it so that leaves are matched with their parents when possible. This is due to the tree structure - there are no cycles, so local optimal choices lead to global optimality.
            </div>

            <div class="optimization-box">
                <strong>When to Choose Which:</strong> The greedy solution is simpler and more intuitive, but the DP approach generalizes better to related problems like weighted matching, constrained matching, or when we need additional information about the structure of the optimal solution.
            </div>
        </div>

        <div class="section hover-effect">
            <h2>Common DP on Trees Patterns</h2>

            <div class="problem-patterns">
                <div class="pattern-card">
                    <div class="pattern-title">üå≤ Subtree Optimization</div>
                    <p><strong>Pattern:</strong> Optimize some property over all subtrees<br>
                    <strong>States:</strong> dp[v] = optimal value for subtree rooted at v<br>
                    <strong>Examples:</strong> Maximum subtree sum, tree diameter, centroid finding</p>
                </div>
                
                <div class="pattern-card">
                    <div class="pattern-title">üéØ Binary Choice DP</div>
                    <p><strong>Pattern:</strong> Each node has two or more distinct states<br>
                    <strong>States:</strong> dp[v][state] for different node configurations<br>
                    <strong>Examples:</strong> Tree matching, vertex cover, independent set</p>
                </div>
                
                <div class="pattern-card">
                    <div class="pattern-title">üîÑ Re-rooting Technique</div>
                    <p><strong>Pattern:</strong> Compute answer for all possible roots efficiently<br>
                    <strong>States:</strong> Two DFS passes to handle all root cases<br>
                    <strong>Examples:</strong> Tree distances, all-pairs shortest paths in trees</p>
                </div>
            </div>

            <h3>Advanced DP on Trees Techniques</h3>

            <div class="applications-box">
                <strong>Advanced Patterns:</strong><br>
                ‚Ä¢ <strong>Tree DP with Path Constraints:</strong> Optimize paths with specific properties<br>
                ‚Ä¢ <strong>Multi-dimensional States:</strong> DP states with multiple parameters<br>
                ‚Ä¢ <strong>Tree Rerooting:</strong> Efficiently compute answers for all possible roots<br>
                ‚Ä¢ <strong>Heavy-Light Decomposition:</strong> Combining tree DP with path queries<br>
                ‚Ä¢ <strong>Centroid Decomposition:</strong> Divide-and-conquer approach to tree problems
            </div>

            <h3>Tree Diameter using DP</h3>

            <div class="dp-visualization">
                <strong>Classic Example: Tree Diameter</strong>
                <p><strong>Problem:</strong> Find the longest path between any two nodes in the tree</p>
                <p><strong>DP States:</strong></p>
                <p>‚Ä¢ down[v] = longest path starting from v and going down to its subtree</p>
                <p>‚Ä¢ For each node v, diameter through v = max(down[u] + down[w] + 2) for children u, w</p>
                <p><strong>Answer:</strong> Maximum over all nodes of diameter through that node</p>
            </div>

            <div class="code-container">
                <div class="code-header">C++ - Tree Diameter using DP</div>
                <pre class="line-numbers"><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;

vector&lt;vector&lt;int&gt;&gt; adj;
vector&lt;int&gt; down;
int diameter = 0;

void dfs(int v, int parent) {
    vector&lt;int&gt; child_distances;
    
    for (int u : adj[v]) {
        if (u != parent) {
            dfs(u, v);
            down[v] = max(down[v], down[u] + 1);
            child_distances.push_back(down[u] + 1);
        }
    }
    
    // Update diameter: longest path through v
    sort(child_distances.rbegin(), child_distances.rend());
    if (child_distances.size() &gt;= 2) {
        diameter = max(diameter, child_distances[0] + child_distances[1]);
    } else if (child_distances.size() == 1) {
        diameter = max(diameter, child_distances[0]);
    }
}

int main() {
    int n;
    cin &gt;&gt; n;
    adj.resize(n);
    down.resize(n, 0);
    
    for (int i = 0; i &lt; n - 1; i++) {
        int u, v;
        cin &gt;&gt; u &gt;&gt; v;
        adj[u].push_back(v);
        adj[v].push_back(u);
    }
    
    dfs(0, -1);
    cout &lt;&lt; diameter &lt;&lt; endl;
    return 0;
}</code></pre>
            </div>
        </div>

        <div class="section hover-effect">
            <h2>Tree Rerooting Technique</h2>

            <p>Sometimes we need to compute DP values for the tree rooted at each possible vertex. The naive approach would be to run DP from each vertex as root, taking O(N¬≤) time. The <span class="highlight">rerooting technique</span> solves this in O(N) time using two DFS passes.</p>

            <div class="transitions-box">
                <strong>Rerooting Strategy:</strong><br>
                <strong>1. First DFS:</strong> Compute DP values assuming root is at vertex 0<br>
                <strong>2. Second DFS:</strong> Propagate information from parent to children<br>
                <strong>3. Combine:</strong> Merge information from subtree and "upward" direction<br>
                <strong>4. Result:</strong> DP answer for tree rooted at each vertex
            </div>

            <div class="step-by-step">
                <strong>Rerooting Implementation Pattern:</strong><br>
                <strong>1.</strong> Define dp_down[v] = answer considering only subtree of v<br>
                <strong>2.</strong> Define dp_up[v] = answer considering everything except subtree of v<br>
                <strong>3.</strong> First DFS: compute all dp_down[v] values<br>
                <strong>4.</strong> Second DFS: compute all dp_up[v] values using parent information<br>
                <strong>5.</strong> Final answer[v] = combine(dp_down[v], dp_up[v])
            </div>

            <div class="code-container">
                <div class="code-header">C++ - Tree Rerooting Template</div>
                <pre class="line-numbers"><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;

vector&lt;vector&lt;int&gt;&gt; adj;
vector&lt;int&gt; dp_down, dp_up, answer;

// First DFS: compute dp_down (considering only subtree)
void dfs1(int v, int parent) {
    dp_down[v] = 0; // Initialize based on problem
    
    for (int u : adj[v]) {
        if (u != parent) {
            dfs1(u, v);
            // Update dp_down[v] based on dp_down[u]
            dp_down[v] += dp_down[u] + 1; // Example: sum of distances
        }
    }
}

// Second DFS: compute dp_up (considering parent direction)
void dfs2(int v, int parent) {
    // Combine dp_down[v] and dp_up[v] for final answer
    answer[v] = dp_down[v] + dp_up[v];
    
    // Prepare dp_up values for children
    vector&lt;int&gt; prefix, suffix;
    vector&lt;int&gt; children;
    
    for (int u : adj[v]) {
        if (u != parent) {
            children.push_back(u);
        }
    }
    
    int m = children.size();
    prefix.resize(m + 1, 0);
    suffix.resize(m + 1, 0);
    
    // Compute prefix and suffix contributions
    for (int i = 0; i &lt; m; i++) {
        prefix[i + 1] = prefix[i] + dp_down[children[i]] + 1;
    }
    for (int i = m - 1; i &gt;= 0; i--) {
        suffix[i] = suffix[i + 1] + dp_down[children[i]] + 1;
    }
    
    // Recursively compute for children
    for (int i = 0; i &lt; m; i++) {
        int u = children[i];
        dp_up[u] = dp_up[v] + prefix[i] + suffix[i + 1] + 1;
        dfs2(u, v);
    }
}

int main() {
    int n;
    cin &gt;&gt; n;
    adj.resize(n);
    dp_down.resize(n);
    dp_up.resize(n);
    answer.resize(n);
    
    for (int i = 0; i &lt; n - 1; i++) {
        int u, v;
        cin &gt;&gt; u &gt;&gt; v;
        adj[u].push_back(v);
        adj[v].push_back(u);
    }
    
    dfs1(0, -1);
    dp_up[0] = 0; // Root has no parent contribution
    dfs2(0, -1);
    
    for (int i = 0; i &lt; n; i++) {
        cout &lt;&lt; answer[i] &lt;&lt; " ";
    }
    cout &lt;&lt; endl;
    
    return 0;
}</code></pre>
            </div>

            <div class="optimization-box">
                <strong>Rerooting Applications:</strong> This technique is extremely powerful for problems like "sum of distances from each vertex to all other vertices," "tree diameter with all possible roots," or "optimal vertex selection for each possible root."
            </div>
        </div>

        <div class="section hover-effect">
            <h2>Implementation Tips and Best Practices</h2>

            <h3>Common DP on Trees Mistakes</h3>

            <div class="warning">
                <strong>Pitfall Prevention:</strong><br>
                ‚Ä¢ Don't forget to handle the parent parameter in DFS to avoid infinite recursion<br>
                ‚Ä¢ Initialize DP arrays with appropriate base values (often 0 or -infinity)<br>
                ‚Ä¢ Be careful about the order of DP state computation (dependencies matter)<br>
                ‚Ä¢ Remember that trees are connected - handle disconnected graphs separately<br>
                ‚Ä¢ Consider edge weights if the problem involves weighted trees
            </div>

            <h3>DP on Trees Problem-Solving Framework</h3>

            <div class="pro-tip-box">
                <strong>Systematic Approach:</strong><br>
                <strong>1. Identify the Problem Type:</strong> Is it about paths, subtrees, or vertex properties?<br>
                <strong>2. Define States Clearly:</strong> What information do you need to store for each node?<br>
                <strong>3. Establish Base Cases:</strong> What are the values for leaf nodes?<br>
                <strong>4. Write Transitions:</strong> How do parent states depend on child states?<br>
                <strong>5. Consider Direction:</strong> Do you need rerooting or is one root sufficient?
            </div>

            <h3>Template for Basic Tree DP</h3>

            <div class="code-container">
                <div class="code-header">C++ - Generic Tree DP Template</div>
                <pre class="line-numbers"><code class="language-cpp">// Generic Tree DP Template
#include &lt;bits/stdc++.h&gt;
using namespace std;

vector&lt;vector&lt;int&gt;&gt; adj;
vector&lt;vector&lt;int&gt;&gt; dp; // dp[node][state]
int n;

void dfs(int v, int parent) {
    // Initialize base case for this node
    // dp[v][0] = ...; dp[v][1] = ...;
    
    for (int u : adj[v]) {
        if (u != parent) {
            dfs(u, v);
            
            // Update dp[v] based on dp[u]
            // This is where you implement the transitions
            for (int state = 0; state &lt; num_states; state++) {
                // dp[v][state] = combine(dp[v][state], dp[u]);
            }
        }
    }
    
    // Post-process if needed (like in tree matching)
    // Additional computations after processing all children
}

int main() {
    cin &gt;&gt; n;
    adj.resize(n);
    dp.resize(n, vector&lt;int&gt;(num_states, initial_value));
    
    for (int i = 0; i &lt; n - 1; i++) {
        int u, v;
        cin &gt;&gt; u &gt;&gt; v;
        adj[u].push_back(v);
        adj[v].push_back(u);
    }
    
    dfs(0, -1);
    
    // Output the answer (often max over all states of root)
    cout &lt;&lt; *max_element(dp[0].begin(), dp[0].end()) &lt;&lt; endl;
    
    return 0;
}</code></pre>
            </div>

            <h3>Debugging Tree DP</h3>

            <div class="algorithm-box">
                <strong>Debug Strategy:</strong> Print DP values for small test cases, verify base cases for leaves, check that transitions make logical sense, and trace through the recursion manually for small trees.
            </div>

            <div class="code-container">
                <div class="code-header">C++ - Tree DP Debug Helpers</div>
                <pre class="line-numbers"><code class="language-cpp">// Debug functions for Tree DP
void print_tree_structure(int v, int parent, int depth = 0) {
    for (int i = 0; i &lt; depth; i++) cout &lt;&lt; "  ";
    cout &lt;&lt; "Node " &lt;&lt; v &lt;&lt; ": ";
    for (int state = 0; state &lt; num_states; state++) {
        cout &lt;&lt; "dp[" &lt;&lt; state &lt;&lt; "]=" &lt;&lt; dp[v][state] &lt;&lt; " ";
    }
    cout &lt;&lt; endl;
    
    for (int u : adj[v]) {
        if (u != parent) {
            print_tree_structure(u, v, depth + 1);
        }
    }
}

void verify_base_cases() {
    for (int v = 0; v &lt; n; v++) {
        if (adj[v].size() == 1) { // Leaf node (except root)
            cout &lt;&lt; "Leaf " &lt;&lt; v &lt;&lt; ": ";
            for (int state = 0; state &lt; num_states; state++) {
                cout &lt;&lt; "dp[" &lt;&lt; state &lt;&lt; "]=" &lt;&lt; dp[v][state] &lt;&lt; " ";
            }
            cout &lt;&lt; endl;
        }
    }
}</code></pre>
            </div>
        </div>

        <div class="section hover-effect">
            <h2>Summary and Key Takeaways</h2>

            <div class="definition-box">
                DP on Trees is a fundamental technique that leverages the hierarchical structure of trees to solve optimization problems efficiently. By defining appropriate states and transitions, complex tree problems become manageable.
            </div>

            <div class="problem-patterns">
                <div class="pattern-card">
                    <div class="pattern-title">What You've Mastered</div>
                    <ul style="padding-left: 20px; list-style: disc;">
                        <li>Basic DP on trees principles and state definition</li>
                        <li>Tree matching problem with both DP and greedy solutions</li>
                        <li>Tree rerooting technique for all-root problems</li>
                        <li>Common patterns: subtree optimization, binary choice DP</li>
                        <li>Implementation frameworks and debugging strategies</li>
                    </ul>
                </div>
                <div class="pattern-card">
                    <div class="pattern-title">Next Learning Goals</div>
                    <ul style="padding-left: 20px; list-style: disc;">
                        <li>Advanced tree DP: tree diameter, center finding</li>
                        <li>Heavy-Light Decomposition for path queries</li>
                        <li>Centroid Decomposition techniques</li>
                        <li>DP optimization techniques for trees</li>
                        <li>Tree DP with additional constraints and modifications</li>
                    </ul>
                </div>
            </div>

            <div class="focus-problem">
                <strong>üéØ Practice Challenge:</strong><br>
                Now that you understand DP on Trees fundamentals, try solving "Tree Distance," "Maximum Subtree," or "Tree Coloring" problems to practice different DP patterns and build your tree algorithm expertise!
            </div>

            <div class="dp-on-trees-box">
                <strong>Real-World Impact:</strong> DP on Trees techniques are fundamental in compiler optimization, network analysis, biological phylogeny, decision trees in machine learning, and hierarchical data processing in databases.
            </div>

            <div class="algorithm-box">
                <strong>Key Insight:</strong> The power of DP on Trees lies in the natural optimal substructure that trees provide. Each subtree can be optimized independently, and the global solution emerges from combining these local optimizations.
            </div>

            <div class="complexity">
                <strong>Performance Summary:</strong> Most DP on Trees algorithms run in O(N) or O(N log N) time, making them highly efficient. The tree structure eliminates the exponential blowup that can occur in general graph DP problems.
            </div>

            <div class="pro-tip-box">
                <strong>Final Reminder:</strong> Always start by understanding the problem structure and identifying whether a greedy approach might work before jumping to DP. Sometimes the simplest solution is the best solution, but DP on Trees provides the tools to handle the complex cases systematically.
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
</body>
</html>