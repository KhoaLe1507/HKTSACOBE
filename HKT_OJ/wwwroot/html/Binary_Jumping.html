<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Binary Jumping</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet">
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']]
            }
        };
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-weight: 600;
            line-height: 1.7;
            color: #2c3e50;
            background: white;
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 40px 20px;
            animation: fadeInUp 0.8s ease-out;
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        h1 {
            font-size: 3.5rem;
            font-weight: 800;
            color: #2c3e50;
            text-align: center;
            margin-bottom: 50px;
            position: relative;
            animation: slideInDown 1s ease-out;
        }

        @keyframes slideInDown {
            from {
                opacity: 0;
                transform: translateY(-50px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        h1::after {
            content: '';
            display: block;
            width: 280px;
            height: 4px;
            background: linear-gradient(90deg, #27ae60, #2ecc71);
            margin: 20px auto;
            border-radius: 2px;
            animation: expandLine 1.2s ease-out 0.5s both;
        }

        @keyframes expandLine {
            from {
                width: 0;
            }
            to {
                width: 280px;
            }
        }

        h2 {
            font-size: 2.4rem;
            font-weight: 700;
            color: #34495e;
            margin-top: 60px;
            margin-bottom: 25px;
            border-left: 5px solid #27ae60;
            padding-left: 20px;
            animation: slideInLeft 0.6s ease-out;
        }

        @keyframes slideInLeft {
            from {
                opacity: 0;
                transform: translateX(-30px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        h3 {
            font-size: 1.9rem;
            font-weight: 700;
            color: #2c3e50;
            margin-top: 40px;
            margin-bottom: 20px;
            position: relative;
        }

        h3::before {
            content: 'üå≥';
            margin-right: 10px;
            font-size: 0.9em;
        }

        p {
            font-size: 1.15rem;
            font-weight: 600;
            margin-bottom: 25px;
            text-align: justify;
            line-height: 1.8;
        }

        ul {
            margin: 25px 0;
            padding-left: 0;
        }

        li {
            font-size: 1.15rem;
            font-weight: 600;
            margin-bottom: 15px;
            line-height: 1.8;
            list-style: none;
            position: relative;
            padding-left: 30px;
        }

        li::before {
            content: 'üöÄ';
            position: absolute;
            left: 0;
            top: 0;
        }

        .code-container {
            background: #1e1e1e;
            border-radius: 12px;
            margin: 30px 0;
            overflow: hidden;
            box-shadow: 0 8px 25px rgba(0,0,0,0.15);
            border: 1px solid #333;
            animation: fadeIn 0.8s ease-out;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }

        .code-header {
            background: linear-gradient(90deg, #2c3e50, #34495e);
            color: white;
            padding: 12px 20px;
            font-weight: 700;
            font-size: 0.9rem;
            border-bottom: 1px solid #444;
        }

        pre {
            margin: 0 !important;
            background: #1e1e1e !important;
            border-radius: 0 !important;
        }

        code {
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace !important;
            font-size: 0.95rem !important;
            line-height: 1.6 !important;
            font-weight: 500 !important;
        }

        .line-numbers-rows {
            border-right: 1px solid #444 !important;
            padding-right: 10px !important;
            margin-right: 15px !important;
        }

        .complexity {
            background: linear-gradient(135deg, #e8f5e8, #d4edda);
            padding: 20px 25px;
            border-radius: 12px;
            border-left: 4px solid #27ae60;
            margin: 25px 0;
            font-weight: 700;
            box-shadow: 0 4px 15px rgba(39, 174, 96, 0.1);
        }

        .warning {
            background: linear-gradient(135deg, #fff3cd, #ffeaa7);
            padding: 20px 25px;
            border-radius: 12px;
            border-left: 4px solid #ffc107;
            margin: 25px 0;
            font-weight: 700;
            box-shadow: 0 4px 15px rgba(255, 193, 7, 0.1);
        }

        .warning::before {
            content: '‚ö†Ô∏è ';
            font-size: 1.2em;
        }

        .section {
            margin-bottom: 50px;
            padding: 35px;
            background: #fafbfc;
            border-radius: 15px;
            border: 1px solid #e1e8ed;
            animation: slideInUp 0.6s ease-out;
        }

        @keyframes slideInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .focus-problem {
            background: linear-gradient(135deg, #e8f5e8, #d4edda);
            padding: 25px;
            border-radius: 15px;
            margin: 30px 0;
            border: 2px solid #27ae60;
            text-align: center;
            font-weight: 700;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% {
                box-shadow: 0 0 0 0 rgba(39, 174, 96, 0.4);
            }
            70% {
                box-shadow: 0 0 0 10px rgba(39, 174, 96, 0);
            }
            100% {
                box-shadow: 0 0 0 0 rgba(39, 174, 96, 0);
            }
        }

        .highlight {
            background: linear-gradient(120deg, #d4edda 0%, #52c788 100%);
            padding: 3px 8px;
            border-radius: 6px;
            font-weight: 800;
        }

        .hover-effect {
            transition: all 0.3s ease;
        }

        .hover-effect:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 35px rgba(0,0,0,0.15);
        }

        .definition-box {
            background: linear-gradient(135deg, #e8f5e8, #d4edda);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 4px solid #27ae60;
            font-weight: 700;
        }

        .definition-box::before {
            content: 'üìö Definition: ';
            font-weight: 800;
            color: #186a3b;
        }

        .algorithm-box {
            background: linear-gradient(135deg, #e3f2fd, #bbdefb);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 4px solid #2196f3;
            font-weight: 700;
        }

        .algorithm-box::before {
            content: '‚ö° Key Insight: ';
            font-weight: 800;
            color: #1976d2;
        }

        .technique-box {
            background: linear-gradient(135deg, #fff0e6, #ffe4cc);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 4px solid #e67e22;
            font-weight: 700;
        }

        .technique-box::before {
            content: 'üß† Technique: ';
            font-weight: 800;
            color: #c0392b;
        }

        .optimization-box {
            background: linear-gradient(135deg, #fef3c7, #fbbf24);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 4px solid #f59e0b;
            font-weight: 700;
        }

        .optimization-box::before {
            content: '‚ö° Optimization: ';
            font-weight: 800;
            color: #92400e;
        }

        .applications-box {
            background: linear-gradient(135deg, #f0f4f8, #ddd6fe);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 4px solid #8b5cf6;
            font-weight: 700;
        }

        .applications-box::before {
            content: 'üìñ Applications: ';
            font-weight: 800;
            color: #7c3aed;
        }

        .math-display {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            margin: 25px 0;
            text-align: center;
            border: 2px solid #e9ecef;
            font-size: 1.2rem;
        }

        .solution-header {
            color: #27ae60;
            font-weight: 800;
            border-bottom: 3px solid #27ae60;
            padding-bottom: 8px;
            display: inline-block;
            margin-bottom: 20px;
        }

        .problem-patterns {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 20px;
            margin: 30px 0;
        }

        .pattern-card {
            background: white;
            border-radius: 12px;
            padding: 25px;
            border-left: 4px solid #27ae60;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            transition: transform 0.3s ease;
        }

        .pattern-card:hover {
            transform: translateY(-5px);
        }

        .pattern-card:nth-child(1) {
            border-left-color: #e74c3c;
        }

        .pattern-card:nth-child(2) {
            border-left-color: #3498db;
        }

        .pattern-card:nth-child(3) {
            border-left-color: #2ecc71;
        }

        .pattern-title {
            font-weight: 800;
            color: #27ae60;
            margin-bottom: 15px;
            font-size: 1.3rem;
        }

        .pattern-card:nth-child(1) .pattern-title {
            color: #e74c3c;
        }

        .pattern-card:nth-child(2) .pattern-title {
            color: #3498db;
        }

        .pattern-card:nth-child(3) .pattern-title {
            color: #2ecc71;
        }

        .step-by-step {
            background: linear-gradient(135deg, #fef7ff, #f3e8ff);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 4px solid #a855f7;
            font-weight: 700;
        }

        .step-by-step::before {
            content: 'üìù Algorithm Steps: ';
            font-weight: 800;
            color: #7c2d12;
        }

        .binary-lifting-box {
            background: linear-gradient(135deg, #e1f5fe, #b3e5fc);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 4px solid #03a9f4;
            font-weight: 700;
        }

        .binary-lifting-box::before {
            content: 'üèóÔ∏è Binary Lifting: ';
            font-weight: 800;
            color: #0277bd;
        }

        .ancestor-box {
            background: linear-gradient(135deg, #f3e5f5, #e1bee7);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 4px solid #9c27b0;
            font-weight: 700;
        }

        .ancestor-box::before {
            content: 'üë¥ Ancestor Queries: ';
            font-weight: 800;
            color: #6a1b9a;
        }

        .preprocessing-box {
            background: linear-gradient(135deg, #fff3e0, #ffe0b2);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 4px solid #ff9800;
            font-weight: 700;
        }

        .preprocessing-box::before {
            content: '‚öôÔ∏è Preprocessing: ';
            font-weight: 800;
            color: #f57c00;
        }

        .query-box {
            background: linear-gradient(135deg, #ffebee, #ffcdd2);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 4px solid #f44336;
            font-weight: 700;
        }

        .query-box::before {
            content: '‚ùì Query Processing: ';
            font-weight: 800;
            color: #d32f2f;
        }

        .tree-visualization {
            background: linear-gradient(135deg, #f1f8e9, #dcedc8);
            padding: 30px;
            border-radius: 15px;
            margin: 30px 0;
            border: 2px solid #8bc34a;
            text-align: center;
            font-weight: 700;
        }

        .tree-visualization::before {
            content: 'üå≤ Tree Structure: ';
            font-weight: 800;
            color: #689f38;
            display: block;
            margin-bottom: 15px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Binary Jumping</h1>
        
        <div class="section hover-effect">
            <h2>Introduction to Binary Jumping</h2>
            
            <p>Binary Jumping (also known as Binary Lifting) is a powerful technique for efficiently answering ancestor queries in trees. This method allows us to find the k-th ancestor of any node in O(log N) time after O(N log N) preprocessing, making it indispensable for many tree-based algorithms.</p>

            <div class="definition-box">
                Binary Jumping is a preprocessing technique that precomputes the 2^k-th ancestor of each node for all relevant values of k. This enables efficient computation of any k-th ancestor by decomposing k into its binary representation and "jumping" through powers of 2.
            </div>

            <div class="applications-box">
                <strong>Primary Applications:</strong><br>
                ‚Ä¢ <strong>Ancestor Queries:</strong> Find the k-th ancestor of any node efficiently<br>
                ‚Ä¢ <strong>Lowest Common Ancestor (LCA):</strong> Essential component in LCA algorithms<br>
                ‚Ä¢ <strong>Path Queries:</strong> Answer queries about paths between nodes<br>
                ‚Ä¢ <strong>Level Ancestor Problems:</strong> Find ancestors at specific levels<br>
                ‚Ä¢ <strong>Tree Decomposition:</strong> Enable complex tree algorithms and optimizations
            </div>

            <div class="algorithm-box">
                <strong>Core Concept:</strong> Any positive integer k can be represented as a sum of distinct powers of 2 (its binary representation). Instead of taking k individual steps up the tree, we can take logarithmically many "jumps" of sizes that are powers of 2.
            </div>
        </div>

        <div class="section hover-effect">
            <h2>Algorithm Explanation</h2>
            
            <p>Binary lifting consists of calculating the $2^k$-th ancestor of each node for all relevant values of $k$ and storing them in a table. With this table, we can then efficiently answer queries regarding the $k$-th ancestor of all nodes.</p>

            <div class="binary-lifting-box">
                <strong>Key Insight:</strong> Any $k$ can be broken down into a sum of powers of $2$ with its binary representation. This way, instead of directly computing, say, the $13$th ancestor of a node, we can go to the $8$th, then $4$th, then $1$st ancestor of the node.
            </div>

            <h3>Why Binary Representation Works</h3>

            <div class="math-display">
                <strong>Example:</strong> $13 = 8 + 4 + 1 = 2^3 + 2^2 + 2^0$<br>
                <strong>Binary:</strong> $13_{10} = 1101_2$
            </div>

            <div class="ancestor-box">
                <strong>Jumping Strategy:</strong> To find the 13th ancestor, we don't take 13 individual steps. Instead, we jump by 8 (2¬≥), then 4 (2¬≤), then 1 (2‚Å∞), resulting in only 3 operations instead of 13!
            </div>

            <div class="tree-visualization">
                <strong>Visualization Example:</strong><br>
                Node ‚Üí 1st ancestor ‚Üí 2nd ancestor ‚Üí 4th ancestor ‚Üí 8th ancestor<br>
                To reach 13th ancestor: Jump 8 ‚Üí Jump 4 ‚Üí Jump 1<br>
                Total: 3 operations instead of 13 linear steps
            </div>

            <h3>Preprocessing Phase</h3>

            <div class="preprocessing-box">
                <strong>Table Construction:</strong> We build a 2D table where entry [node][k] stores the 2^k-th ancestor of the given node. This table enables us to answer any ancestor query in logarithmic time.
            </div>

            <div class="step-by-step">
                <strong>Preprocessing Steps:</strong><br>
                <strong>1.</strong> Initialize the first column: pow2ends[node][0] = direct parent of node<br>
                <strong>2.</strong> For each power k from 1 to log‚ÇÇ(N):<br>
                <strong>3.</strong> For each node: pow2ends[node][k] = pow2ends[pow2ends[node][k-1]][k-1]<br>
                <strong>4.</strong> This means: 2^k-th ancestor = 2^(k-1)-th ancestor of the 2^(k-1)-th ancestor<br>
                <strong>5.</strong> Continue until 2^k exceeds the tree height
            </div>

            <div class="algorithm-box">
                <strong>Mathematical Foundation:</strong> The key insight is that the 2^k-th ancestor can be computed from two 2^(k-1)-th ancestors. This recursive relationship allows us to build the entire table efficiently.
            </div>

            <h3>Query Processing</h3>

            <div class="query-box">
                <strong>Query Algorithm:</strong> To find the k-th ancestor of node n, we iterate through the binary representation of k. For each bit that is set to 1, we make a jump of the corresponding power of 2.
            </div>

            <div class="step-by-step">
                <strong>Query Steps:</strong><br>
                <strong>1.</strong> Start at the query node<br>
                <strong>2.</strong> For each bit position i in the binary representation of k:<br>
                <strong>3.</strong> If bit i is set (k & (1 << i) != 0):<br>
                <strong>4.</strong> Jump to the 2^i-th ancestor using our precomputed table<br>
                <strong>5.</strong> If we reach a null ancestor (-1), stop and return -1<br>
                <strong>6.</strong> Continue until all bits are processed
            </div>
        </div>

        <div class="section hover-effect">
            <h2>Implementation</h2>

            <div class="complexity">
                <strong>Time Complexity:</strong><br>
                ‚Ä¢ <strong>Preprocessing:</strong> $\mathcal{O}(N \log N)$<br>
                ‚Ä¢ <strong>Query:</strong> $\mathcal{O}(\log N)$<br>
                ‚Ä¢ <strong>Space Complexity:</strong> $\mathcal{O}(N \log N)$
            </div>

            <h3 class="solution-header">Complete Binary Jumping Implementation</h3>

            <div class="code-container">
                <div class="code-header">C++ - Binary Jumping for Ancestor Queries</div>
                <pre class="line-numbers"><code class="language-cpp">#include &lt;cmath&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

using std::cout;
using std::endl;
using std::vector;

class Tree {
  private:
    const int log2dist;
    vector&lt;int&gt; par;
    vector&lt;vector&lt;int&gt;&gt; pow2ends;

  public:
    Tree(const vector&lt;int&gt; &parents)
        : log2dist(std::ceil(std::log2(parents.size() + 1))), 
          par(parents.size() + 1),
          pow2ends(par.size(), vector&lt;int&gt;(log2dist + 1)) {
        
        par[0] = -1;
        for (int i = 0; i &lt; parents.size(); i++) { 
            par[i + 1] = parents[i]; 
        }

        // pow2ends[n][k] contains the 2^kth parent of node n
        // if there is no 2^kth parent, the value is -1
        for (int n = 0; n &lt; par.size(); n++) { 
            pow2ends[n][0] = par[n]; 
        }
        
        for (int p = 1; p &lt;= log2dist; p++) {
            for (int n = 0; n &lt; par.size(); n++) {
                int halfway = pow2ends[n][p - 1];
                if (halfway == -1) {
                    pow2ends[n][p] = -1;
                } else {
                    pow2ends[n][p] = pow2ends[halfway][p - 1];
                }
            }
        }
    }

    /** @return the kth parent of node n */
    int kth_parent(int n, int k) {
        int at = n;
        // break down k into powers of 2 by looping through its bits
        for (int pow = 0; pow &lt;= log2dist; pow++) {
            if ((k & (1 &lt;&lt; pow)) != 0) {
                at = pow2ends[at][pow];
                if (at == -1) {
                    break;  // stop when we're past the root
                }
            }
        }
        return at;
    }
};

int main() {
    int employee_num;
    int query_num;
    std::cin &gt;&gt; employee_num &gt;&gt; query_num;
    
    vector&lt;int&gt; bosses(employee_num - 1);
    for (int &b : bosses) {
        std::cin &gt;&gt; b;
        b--;
    }

    Tree tree(bosses);
    for (int q = 0; q &lt; query_num; q++) {
        int employee;
        int dist;
        std::cin &gt;&gt; employee &gt;&gt; dist;
        int kth_boss = tree.kth_parent(--employee, dist);
        cout &lt;&lt; (kth_boss != -1 ? kth_boss + 1 : -1) &lt;&lt; '\n';
    }
}</code></pre>
            </div>

            <div class="technique-box">
                <strong>Implementation Details:</strong><br>
                ‚Ä¢ <strong>log2dist:</strong> Maximum number of binary lifting levels needed<br>
                ‚Ä¢ <strong>pow2ends[n][k]:</strong> Stores the 2^k-th ancestor of node n<br>
                ‚Ä¢ <strong>Bit manipulation:</strong> Uses (k & (1 << pow)) to check if bit is set<br>
                ‚Ä¢ <strong>Null handling:</strong> Returns -1 when ancestor doesn't exist<br>
                ‚Ä¢ <strong>0-indexed conversion:</strong> Handles input/output index differences
            </div>

            <h3>Alternative Implementation with Better Memory</h3>

            <div class="code-container">
                <div class="code-header">C++ - Space-Optimized Binary Jumping</div>
                <pre class="line-numbers"><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;

const int MAXN = 100005;
const int LOGN = 20;  // log2(MAXN) + 1

int up[MAXN][LOGN];
int depth[MAXN];
vector&lt;int&gt; adj[MAXN];

void dfs(int v, int parent) {
    up[v][0] = parent;
    for (int i = 1; i &lt; LOGN; i++) {
        if (up[v][i-1] != -1) {
            up[v][i] = up[up[v][i-1]][i-1];
        } else {
            up[v][i] = -1;
        }
    }
    
    for (int u : adj[v]) {
        if (u != parent) {
            depth[u] = depth[v] + 1;
            dfs(u, v);
        }
    }
}

int kth_ancestor(int v, int k) {
    for (int i = 0; i &lt; LOGN; i++) {
        if (k & (1 &lt;&lt; i)) {
            v = up[v][i];
            if (v == -1) break;
        }
    }
    return v;
}

int lca(int u, int v) {
    // Make sure u is deeper than v
    if (depth[u] &lt; depth[v]) swap(u, v);
    
    // Bring u to the same level as v
    int diff = depth[u] - depth[v];
    u = kth_ancestor(u, diff);
    
    if (u == v) return u;
    
    // Binary search for LCA
    for (int i = LOGN - 1; i &gt;= 0; i--) {
        if (up[u][i] != up[v][i]) {
            u = up[u][i];
            v = up[v][i];
        }
    }
    
    return up[u][0];
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    
    int n, q;
    cin &gt;&gt; n &gt;&gt; q;
    
    for (int i = 0; i &lt; n - 1; i++) {
        int u, v;
        cin &gt;&gt; u &gt;&gt; v;
        adj[u].push_back(v);
        adj[v].push_back(u);
    }
    
    depth[1] = 0;
    dfs(1, -1);
    
    while (q--) {
        int type;
        cin &gt;&gt; type;
        
        if (type == 1) {
            // Kth ancestor query
            int node, k;
            cin &gt;&gt; node &gt;&gt; k;
            cout &lt;&lt; kth_ancestor(node, k) &lt;&lt; '\n';
        } else {
            // LCA query
            int u, v;
            cin &gt;&gt; u &gt;&gt; v;
            cout &lt;&lt; lca(u, v) &lt;&lt; '\n';
        }
    }
    
    return 0;
}</code></pre>
            </div>

            <div class="optimization-box">
                <strong>Advanced Features:</strong> This implementation includes both k-th ancestor queries and Lowest Common Ancestor (LCA) queries, demonstrating how binary jumping serves as a foundation for more complex tree algorithms.
            </div>
        </div>

        <div class="section hover-effect">
            <h2>Advanced Applications</h2>

            <h3>Lowest Common Ancestor (LCA)</h3>

            <div class="ancestor-box">
                <strong>LCA with Binary Jumping:</strong> One of the most important applications of binary jumping is computing the Lowest Common Ancestor of two nodes. This requires combining depth normalization with binary search techniques.
            </div>

            <div class="step-by-step">
                <strong>LCA Algorithm Steps:</strong><br>
                <strong>1.</strong> Ensure both nodes are at the same depth by moving the deeper node upward<br>
                <strong>2.</strong> If nodes are now equal, one was an ancestor of the other<br>
                <strong>3.</strong> Otherwise, use binary search: jump both nodes upward by decreasing powers of 2<br>
                <strong>4.</strong> Stop when their parents would be the same (but they're not the same)<br>
                <strong>5.</strong> Return the parent of either node as the LCA
            </div>

            <div class="code-container">
                <div class="code-header">C++ - LCA Algorithm Explanation</div>
                <pre class="line-numbers"><code class="language-cpp">int lca(int u, int v) {
    // Step 1: Make sure u is deeper than v
    if (depth[u] < depth[v]) swap(u, v);
    
    // Step 2: Bring u to the same level as v
    int diff = depth[u] - depth[v];
    u = kth_ancestor(u, diff);
    
    // Step 3: If they're now the same, v was an ancestor of u
    if (u == v) return u;
    
    // Step 4: Binary search for LCA
    for (int i = LOGN - 1; i >= 0; i--) {
        // If their 2^i ancestors are different, we can safely jump
        if (up[u][i] != up[v][i]) {
            u = up[u][i];
            v = up[v][i];
        }
    }
    
    // Step 5: Now u and v are children of LCA
    return up[u][0];
}</code></pre>
            </div>

            <h3>Path Queries and Distance</h3>

            <div class="query-box">
                <strong>Tree Distance:</strong> Using LCA, we can compute the distance between any two nodes in the tree. The distance between nodes u and v is depth[u] + depth[v] - 2 √ó depth[LCA(u,v)].
            </div>

            <div class="code-container">
                <div class="code-header">C++ - Tree Distance and Path Queries</div>
                <pre class="line-numbers"><code class="language-cpp">class AdvancedTree {
private:
    vector<vector<int>> up;
    vector<int> depth;
    vector<long long> dist_from_root;
    int n, LOG;

public:
    AdvancedTree(int size) : n(size), LOG(ceil(log2(size)) + 1) {
        up.assign(n, vector<int>(LOG, -1));
        depth.assign(n, 0);
        dist_from_root.assign(n, 0);
    }
    
    void add_edge(int u, int v, int weight = 1) {
        // Build tree and initialize preprocessing
    }
    
    void preprocess(int root = 0) {
        dfs(root, -1, 0, 0);
        
        // Build binary jumping table
        for (int j = 1; j < LOG; j++) {
            for (int i = 0; i < n; i++) {
                if (up[i][j-1] != -1) {
                    up[i][j] = up[up[i][j-1]][j-1];
                }
            }
        }
    }
    
    void dfs(int v, int parent, int d, long long dist) {
        depth[v] = d;
        dist_from_root[v] = dist;
        up[v][0] = parent;
        
        // Process children (implementation depends on graph representation)
    }
    
    int lca(int u, int v) {
        if (depth[u] < depth[v]) swap(u, v);
        
        // Bring to same level
        int diff = depth[u] - depth[v];
        for (int i = 0; i < LOG; i++) {
            if ((diff >> i) & 1) {
                u = up[u][i];
            }
        }
        
        if (u == v) return u;
        
        // Binary search
        for (int i = LOG - 1; i >= 0; i--) {
            if (up[u][i] != up[v][i]) {
                u = up[u][i];
                v = up[v][i];
            }
        }
        
        return up[u][0];
    }
    
    int distance(int u, int v) {
        return depth[u] + depth[v] - 2 * depth[lca(u, v)];
    }
    
    long long path_weight(int u, int v) {
        int l = lca(u, v);
        return dist_from_root[u] + dist_from_root[v] - 2 * dist_from_root[l];
    }
    
    bool is_ancestor(int u, int v) {
        // Check if u is an ancestor of v
        return lca(u, v) == u;
    }
    
    int kth_node_on_path(int u, int v, int k) {
        int l = lca(u, v);
        int dist_u_to_l = depth[u] - depth[l];
        int dist_l_to_v = depth[v] - depth[l];
        
        if (k <= dist_u_to_l) {
            return kth_ancestor(u, k);
        } else {
            return kth_ancestor(v, dist_u_to_l + dist_l_to_v - k);
        }
    }
};</code></pre>
            </div>

            <h3>Heavy-Light Decomposition Integration</h3>

            <div class="technique-box">
                <strong>Combining Techniques:</strong> Binary jumping often works together with Heavy-Light Decomposition for path queries on trees. Binary jumping handles LCA queries while HLD manages path aggregations.
            </div>

            <div class="applications-box">
                <strong>Advanced Tree Applications:</strong><br>
                ‚Ä¢ <strong>Dynamic Trees:</strong> Link-cut trees with binary jumping for connectivity<br>
                ‚Ä¢ <strong>Centroid Decomposition:</strong> LCA queries in decomposed tree structures<br>
                ‚Ä¢ <strong>Tree DP Optimization:</strong> Ancestor queries in dynamic programming<br>
                ‚Ä¢ <strong>Graph Algorithms:</strong> Shortest paths in sparse graphs with tree structure<br>
                ‚Ä¢ <strong>Computational Geometry:</strong> Range trees and segment trees on trees
            </div>
        </div>

        <div class="section hover-effect">
            <h2>Problem Patterns and Recognition</h2>

            <div class="problem-patterns">
                <div class="pattern-card">
                    <div class="pattern-title">üéØ Ancestor Queries</div>
                    <p><strong>Pattern:</strong> Find k-th parent, level ancestor problems<br>
                    <strong>Signals:</strong> "k-th ancestor", "parent at distance k"<br>
                    <strong>Examples:</strong> Company hierarchy, file system navigation, tournament brackets</p>
                </div>
                
                <div class="pattern-card">
                    <div class="pattern-title">üìä LCA Problems</div>
                    <p><strong>Pattern:</strong> Lowest common ancestor, path queries<br>
                    <strong>Signals:</strong> "common ancestor", "path between nodes"<br>
                    <strong>Examples:</strong> Family trees, network routing, phylogenetic analysis</p>
                </div>
                
                <div class="pattern-card">
                    <div class="pattern-title">üîç Tree Distances</div>
                    <p><strong>Pattern:</strong> Distance between nodes, path weights<br>
                    <strong>Signals:</strong> "shortest path", "distance in tree"<br>
                    <strong>Examples:</strong> Social networks, transportation networks, biological networks</p>
                </div>
            </div>

            <h3>Common Problem Types</h3>

            <div class="focus-problem">
                <strong>üéØ Typical Problems:</strong><br>
                Employee Hierarchy ‚Ä¢ Tree Distance Queries ‚Ä¢ LCA with Path Weights<br>
                Kth Ancestor ‚Ä¢ Tree Isomorphism ‚Ä¢ Dynamic Connectivity
            </div>

            <div class="step-by-step">
                <strong>Problem-Solving Strategy:</strong><br>
                <strong>1.</strong> Identify if the problem involves tree structure and ancestor relationships<br>
                <strong>2.</strong> Determine what type of queries are needed (ancestor, LCA, distance)<br>
                <strong>3.</strong> Consider if preprocessing is allowed (usually yes for competitive programming)<br>
                <strong>4.</strong> Implement binary jumping with appropriate query functions<br>
                <strong>5.</strong> Optimize for the specific constraints and query patterns
            </div>

            <h3>Edge Cases and Considerations</h3>

            <div class="warning">
                <strong>Common Pitfalls:</strong><br>
                ‚Ä¢ Handle cases where k exceeds the depth to root<br>
                ‚Ä¢ Be careful with 0-indexed vs 1-indexed node numbering<br>
                ‚Ä¢ Consider degenerate trees (chains, stars)<br>
                ‚Ä¢ Manage memory for large trees (N up to 10^6)<br>
                ‚Ä¢ Validate that the input actually forms a tree
            </div>

            <div class="optimization-box">
                <strong>Performance Optimization:</strong><br>
                ‚Ä¢ Use iterative DFS to avoid stack overflow on deep trees<br>
                ‚Ä¢ Consider cache-friendly memory layout for better performance<br>
                ‚Ä¢ Optimize the logarithm calculation for better constants<br>
                ‚Ä¢ Use bit manipulation tricks for faster power-of-2 operations<br>
                ‚Ä¢ Precompute frequently used values like LOG and powers of 2
            </div>
        </div>

        <div class="section hover-effect">
            <h2>Advanced Optimizations and Variants</h2>

            <h3>Space Optimization</h3>

            <div class="technique-box">
                <strong>Memory Reduction:</strong> For very large trees, we can reduce space complexity by storing only the necessary levels. If maximum query distance is bounded by K, we only need log‚ÇÇ(K) levels instead of log‚ÇÇ(N).
            </div>

            <div class="code-container">
                <div class="code-header">C++ - Space-Optimized Binary Jumping</div>
                <pre class="line-numbers"><code class="language-cpp">class CompactBinaryJumping {
private:
    int n, max_jump, LOG;
    vector<vector<int>> up;
    
public:
    CompactBinaryJumping(int size, int max_k) 
        : n(size), max_jump(max_k), LOG(ceil(log2(max_k)) + 1) {
        up.assign(n, vector<int>(LOG, -1));
    }
    
    void build(const vector<int>& parent) {
        // Initialize first level
        for (int i = 0; i < n; i++) {
            up[i][0] = parent[i];
        }
        
        // Build only necessary levels
        for (int j = 1; j < LOG; j++) {
            for (int i = 0; i < n; i++) {
                if (up[i][j-1] != -1) {
                    up[i][j] = up[up[i][j-1]][j-1];
                }
            }
        }
    }
    
    int query(int node, int k) {
        if (k > max_jump) return -1;
        
        for (int i = 0; i < LOG; i++) {
            if ((k >> i) & 1) {
                node = up[node][i];
                if (node == -1) break;
            }
        }
        return node;
    }
};</code></pre>
            </div>

            <h3>Fractional Binary Jumping</h3>

            <div class="algorithm-box">
                <strong>Advanced Technique:</strong> For problems requiring finding nodes at fractional distances or weighted paths, we can extend binary jumping to handle more complex queries by precomputing additional information.
            </div>

            <h3>Parallel Binary Jumping</h3>

            <div class="optimization-box">
                <strong>Parallelization:</strong> The preprocessing phase can be parallelized effectively. Each level of the binary jumping table can be computed in parallel, and individual node computations within a level are independent.
            </div>

            <h3>Dynamic Trees</h3>

            <div class="technique-box">
                <strong>Link-Cut Trees:</strong> For dynamic tree problems where edges can be added or removed, binary jumping can be combined with Link-Cut Trees to maintain ancestor relationships efficiently even as the tree structure changes.
            </div>
        </div>

        <div class="section hover-effect">
            <h2>Implementation Tips and Best Practices</h2>

            <h3>Debugging and Testing</h3>

            <div class="code-container">
                <div class="code-header">C++ - Binary Jumping Debug Utilities</div>
                <pre class="line-numbers"><code class="language-cpp">class BinaryJumpingDebug {
public:
    static void verify_preprocessing(const vector<vector<int>>& up, 
                                   const vector<int>& parent) {
        int n = up.size();
        int LOG = up[0].size();
        
        cout << "Verifying binary jumping table...\n";
        
        for (int node = 0; node < n; node++) {
            // Check first level
            if (up[node][0] != parent[node]) {
                cout << "Error: up[" << node << "][0] = " << up[node][0] 
                     << ", expected " << parent[node] << "\n";
            }
            
            // Check higher levels
            for (int level = 1; level < LOG; level++) {
                int expected = -1;
                if (up[node][level-1] != -1) {
                    expected = up[up[node][level-1]][level-1];
                }
                
                if (up[node][level] != expected) {
                    cout << "Error: up[" << node << "][" << level << "] = " 
                         << up[node][level] << ", expected " << expected << "\n";
                }
            }
        }
        
        cout << "Verification complete.\n";
    }
    
    static void test_queries(BinaryJumping& bj, int test_cases = 1000) {
        cout << "Testing random queries...\n";
        
        for (int test = 0; test < test_cases; test++) {
            int node = rand() % bj.get_size();
            int k = rand() % 20 + 1;
            
            // Compare with naive implementation
            int result1 = bj.kth_ancestor(node, k);
            int result2 = naive_kth_ancestor(bj, node, k);
            
            if (result1 != result2) {
                cout << "Mismatch: kth_ancestor(" << node << ", " << k 
                     << ") = " << result1 << " vs " << result2 << "\n";
            }
        }
        
        cout << "Testing complete.\n";
    }
    
private:
    static int naive_kth_ancestor(BinaryJumping& bj, int node, int k) {
        for (int i = 0; i < k; i++) {
            node = bj.get_parent(node);
            if (node == -1) break;
        }
        return node;
    }
};</code></pre>
            </div>

            <h3>Performance Benchmarking</h3>

            <div class="optimization-box">
                <strong>Benchmarking Strategy:</strong> Always compare your binary jumping implementation against naive approaches on small inputs to verify correctness, then test performance on large datasets with various query patterns.
            </div>

            <div class="warning">
                <strong>Memory Management:</strong> For very large trees (N > 10^6), consider the memory footprint. The standard implementation uses O(N log N) space, which might not fit in memory constraints. Consider space-time tradeoffs.
            </div>
        </div>

        <div class="section hover-effect">
            <h2>Summary and Key Takeaways</h2>

            <div class="definition-box">
                Binary Jumping is a fundamental technique that transforms linear tree traversal into logarithmic-time queries through clever preprocessing and bit manipulation. It serves as the foundation for many advanced tree algorithms.
            </div>

            <div class="problem-patterns">
                <div class="pattern-card">
                    <div class="pattern-title">What You've Mastered</div>
                    <ul style="padding-left: 20px; list-style: disc;">
                        <li>Binary representation decomposition for efficient jumping</li>
                        <li>O(N log N) preprocessing for O(log N) queries</li>
                        <li>LCA computation using binary jumping techniques</li>
                        <li>Tree distance and path query algorithms</li>
                        <li>Space and time optimization strategies</li>
                    </ul>
                </div>
                <div class="pattern-card">
                    <div class="pattern-title">Advanced Applications</div>
                    <ul style="padding-left: 20px; list-style: disc;">
                        <li>Integration with Heavy-Light Decomposition</li>
                        <li>Dynamic tree algorithms and Link-Cut Trees</li>
                        <li>Centroid decomposition with efficient LCA</li>
                        <li>Range trees and advanced data structures</li>
                        <li>Parallel processing and optimization techniques</li>
                    </ul>
                </div>
            </div>

            <div class="focus-problem">
                <strong>üéØ Practice Challenge:</strong><br>
                Master binary jumping by solving "Company Queries I & II," "Distance Queries," "Kth Ancestor," and "Tree Matching" to see how this technique applies across different tree problems!
            </div>

            <div class="applications-box">
                <strong>Real-World Impact:</strong> Binary jumping is essential in database query optimization, network routing protocols, phylogenetic analysis, file system operations, and any application requiring efficient hierarchical navigation.
            </div>

            <div class="algorithm-box">
                <strong>Key Insight:</strong> The power of binary jumping lies in recognizing that any distance can be broken down into powers of 2. This insight transforms O(N) linear traversals into O(log N) jumps, making complex tree queries practical for large datasets.
            </div>

            <div class="complexity">
                <strong>Final Complexity Summary:</strong><br>
                ‚Ä¢ <strong>Preprocessing:</strong> O(N log N) time and space<br>
                ‚Ä¢ <strong>Ancestor Query:</strong> O(log N) per query<br>
                ‚Ä¢ <strong>LCA Query:</strong> O(log N) per query<br>
                ‚Ä¢ <strong>Total for Q queries:</strong> O(N log N + Q log N)
            </div>

            <div class="binary-lifting-box">
                <strong>Remember:</strong> Binary jumping is more than just an optimization‚Äîit's a way of thinking about hierarchical structures. The ability to decompose distances into binary representations is a fundamental skill that applies to many algorithmic problems beyond trees. Master this technique, and you'll have a powerful tool for solving complex competitive programming challenges!
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
</body>
</html>