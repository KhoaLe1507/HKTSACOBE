<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minimum Spanning Trees</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet">
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']]
            }
        };
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-weight: 600;
            line-height: 1.7;
            color: #2c3e50;
            background: white;
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 40px 20px;
            animation: fadeInUp 0.8s ease-out;
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        h1 {
            font-size: 3.5rem;
            font-weight: 800;
            color: #2c3e50;
            text-align: center;
            margin-bottom: 50px;
            position: relative;
            animation: slideInDown 1s ease-out;
        }

        @keyframes slideInDown {
            from {
                opacity: 0;
                transform: translateY(-50px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        h1::after {
            content: '';
            display: block;
            width: 280px;
            height: 4px;
            background: linear-gradient(90deg, #27ae60, #2ecc71);
            margin: 20px auto;
            border-radius: 2px;
            animation: expandLine 1.2s ease-out 0.5s both;
        }

        @keyframes expandLine {
            from {
                width: 0;
            }
            to {
                width: 280px;
            }
        }

        h2 {
            font-size: 2.4rem;
            font-weight: 700;
            color: #34495e;
            margin-top: 60px;
            margin-bottom: 25px;
            border-left: 5px solid #27ae60;
            padding-left: 20px;
            animation: slideInLeft 0.6s ease-out;
        }

        @keyframes slideInLeft {
            from {
                opacity: 0;
                transform: translateX(-30px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        h3 {
            font-size: 1.9rem;
            font-weight: 700;
            color: #2c3e50;
            margin-top: 40px;
            margin-bottom: 20px;
            position: relative;
        }

        h3::before {
            content: 'üß†';
            margin-right: 10px;
            font-size: 0.9em;
        }

        p {
            font-size: 1.15rem;
            font-weight: 600;
            margin-bottom: 25px;
            text-align: justify;
            line-height: 1.8;
        }

        ul {
            margin: 25px 0;
            padding-left: 0;
        }

        li {
            font-size: 1.15rem;
            font-weight: 600;
            margin-bottom: 15px;
            line-height: 1.8;
            list-style: none;
            position: relative;
            padding-left: 30px;
        }

        li::before {
            content: 'üí°';
            position: absolute;
            left: 0;
            top: 0;
        }

        .code-container {
            background: #1e1e1e;
            border-radius: 12px;
            margin: 30px 0;
            overflow: hidden;
            box-shadow: 0 8px 25px rgba(0,0,0,0.15);
            border: 1px solid #333;
            animation: fadeIn 0.8s ease-out;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }

        .code-header {
            background: linear-gradient(90deg, #2c3e50, #34495e);
            color: white;
            padding: 12px 20px;
            font-weight: 700;
            font-size: 0.9rem;
            border-bottom: 1px solid #444;
        }

        pre {
            margin: 0 !important;
            background: #1e1e1e !important;
            border-radius: 0 !important;
        }

        code {
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace !important;
            font-size: 0.95rem !important;
            line-height: 1.6 !important;
            font-weight: 500 !important;
        }

        .line-numbers-rows {
            border-right: 1px solid #444 !important;
            padding-right: 10px !important;
            margin-right: 15px !important;
        }

        .complexity {
            background: linear-gradient(135deg, #d5f4e6, #a7e7c3);
            padding: 20px 25px;
            border-radius: 12px;
            border-left: 4px solid #27ae60;
            margin: 25px 0;
            font-weight: 700;
            box-shadow: 0 4px 15px rgba(39, 174, 96, 0.1);
        }

        .warning {
            background: linear-gradient(135deg, #fff3cd, #ffeaa7);
            padding: 20px 25px;
            border-radius: 12px;
            border-left: 4px solid #ffc107;
            margin: 25px 0;
            font-weight: 700;
            box-shadow: 0 4px 15px rgba(255, 193, 7, 0.1);
        }

        .warning::before {
            content: '‚ö†Ô∏è ';
            font-size: 1.2em;
        }

        .section {
            margin-bottom: 50px;
            padding: 35px;
            background: #fafbfc;
            border-radius: 15px;
            border: 1px solid #e1e8ed;
            animation: slideInUp 0.6s ease-out;
        }

        @keyframes slideInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .focus-problem {
            background: linear-gradient(135deg, #d5f4e6, #a7e7c3);
            padding: 25px;
            border-radius: 15px;
            margin: 30px 0;
            border: 2px solid #27ae60;
            text-align: center;
            font-weight: 700;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% {
                box-shadow: 0 0 0 0 rgba(39, 174, 96, 0.4);
            }
            70% {
                box-shadow: 0 0 0 10px rgba(39, 174, 96, 0);
            }
            100% {
                box-shadow: 0 0 0 0 rgba(39, 174, 96, 0);
            }
        }

        .highlight {
            background: linear-gradient(120deg, #a7e7c3 0%, #74b9ff 100%);
            padding: 3px 8px;
            border-radius: 6px;
            font-weight: 800;
        }

        .hover-effect {
            transition: all 0.3s ease;
        }

        .hover-effect:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 35px rgba(0,0,0,0.15);
        }

        .definition-box {
            background: linear-gradient(135deg, #e8f5e8, #d4edda);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 4px solid #28a745;
            font-weight: 700;
        }

        .definition-box::before {
            content: 'üìö Definition: ';
            font-weight: 800;
            color: #155724;
        }

        .algorithm-box {
            background: linear-gradient(135deg, #f3e5f5, #e1bee7);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 4px solid #9c27b0;
            font-weight: 700;
        }

        .algorithm-box::before {
            content: '‚ö° Key Insight: ';
            font-weight: 800;
            color: #7b1fa2;
        }

        .solution-header {
            color: #27ae60;
            font-weight: 800;
            border-bottom: 3px solid #27ae60;
            padding-bottom: 8px;
            display: inline-block;
            margin-bottom: 20px;
        }

        .math-display {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            margin: 25px 0;
            text-align: center;
            border: 2px solid #e9ecef;
            font-size: 1.2rem;
        }

        .mst-benefits-box {
            background: linear-gradient(135deg, #e8f5e8, #d4edda);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 4px solid #28a745;
            font-weight: 700;
        }

        .mst-benefits-box::before {
            content: 'üå≥ MST Properties: ';
            font-weight: 800;
            color: #155724;
        }

        .kruskal-box {
            background: linear-gradient(135deg, #fff3e0, #ffe0b2);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 4px solid #ff9800;
            font-weight: 700;
        }

        .kruskal-box::before {
            content: 'üîó Kruskal\'s Algorithm: ';
            font-weight: 800;
            color: #f57c00;
        }

        .prim-box {
            background: linear-gradient(135deg, #e3f2fd, #bbdefb);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 4px solid #2196f3;
            font-weight: 700;
        }

        .prim-box::before {
            content: 'üéØ Prim\'s Algorithm: ';
            font-weight: 800;
            color: #1976d2;
        }

        .step-by-step {
            background: linear-gradient(135deg, #fef7ff, #f3e8ff);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 4px solid #a855f7;
            font-weight: 700;
        }

        .step-by-step::before {
            content: 'üìù Algorithm Steps: ';
            font-weight: 800;
            color: #7c2d12;
        }

        .optimization-box {
            background: linear-gradient(135deg, #fef3c7, #fbbf24);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 4px solid #f59e0b;
            font-weight: 700;
        }

        .optimization-box::before {
            content: '‚ö° Optimization: ';
            font-weight: 800;
            color: #92400e;
        }

        .mst-visualization {
            background: #f8f9fa;
            padding: 30px;
            border-radius: 12px;
            margin: 30px 0;
            text-align: center;
            border: 2px solid #e9ecef;
        }

        .applications-box {
            background: linear-gradient(135deg, #f0f4f8, #ddd6fe);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 4px solid #8b5cf6;
            font-weight: 700;
        }

        .applications-box::before {
            content: 'üìñ Applications: ';
            font-weight: 800;
            color: #7c3aed;
        }

        .problem-patterns {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 20px;
            margin: 30px 0;
        }

        .pattern-card {
            background: white;
            border-radius: 12px;
            padding: 25px;
            border-left: 4px solid #27ae60;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            transition: transform 0.3s ease;
        }

        .pattern-card:hover {
            transform: translateY(-5px);
        }

        .pattern-card:nth-child(1) {
            border-left-color: #e74c3c;
        }

        .pattern-card:nth-child(2) {
            border-left-color: #3498db;
        }

        .pattern-card:nth-child(3) {
            border-left-color: #2ecc71;
        }

        .pattern-title {
            font-weight: 800;
            color: #27ae60;
            margin-bottom: 15px;
            font-size: 1.3rem;
        }

        .pattern-card:nth-child(1) .pattern-title {
            color: #e74c3c;
        }

        .pattern-card:nth-child(2) .pattern-title {
            color: #3498db;
        }

        .pattern-card:nth-child(3) .pattern-title {
            color: #2ecc71;
        }

        .comparison-box {
            background: linear-gradient(135deg, #ecfdf5, #d1fae5);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 4px solid #10b981;
            font-weight: 700;
        }

        .comparison-box::before {
            content: '‚öñÔ∏è Algorithm Comparison: ';
            font-weight: 800;
            color: #047857;
        }

        .greedy-strategy-box {
            background: linear-gradient(135deg, #fff8e1, #ffecb3);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 4px solid #ffc107;
            font-weight: 700;
        }

        .greedy-strategy-box::before {
            content: 'üé≤ Greedy Strategy: ';
            font-weight: 800;
            color: #f57c00;
        }

        .dsu-integration-box {
            background: linear-gradient(135deg, #e0f2fe, #b3e5fc);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 4px solid #0288d1;
            font-weight: 700;
        }

        .dsu-integration-box::before {
            content: 'üîó DSU Integration: ';
            font-weight: 800;
            color: #01579b;
        }

        .priority-queue-box {
            background: linear-gradient(135deg, #f8f4ff, #e4d5f7);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 4px solid #8b5cf6;
            font-weight: 700;
        }

        .priority-queue-box::before {
            content: 'üìä Priority Queue: ';
            font-weight: 800;
            color: #7c3aed;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Minimum Spanning Trees</h1>
        
        <div class="section hover-effect">
            <h2>Introduction to Spanning Trees</h2>
            
            <p>To review a couple of terms that are fundamental to understanding minimum spanning trees:</p>

            <div class="definition-box">
                ‚Ä¢ <strong>An undirected edge</strong> is an edge that goes both ways<br>
                ‚Ä¢ <strong>A connected graph</strong> is a graph of vertices such that each vertex can reach every other vertex using undirected edges<br>
                ‚Ä¢ <strong>A spanning tree</strong> is a set of edges that forms a tree and contains every vertex in the original graph<br>
                ‚Ä¢ <strong>A minimum spanning tree</strong> is a spanning tree such that the sum of edge weights are minimized
            </div>

            <div class="mst-benefits-box">
                <strong>Key Properties of MST:</strong><br>
                ‚Ä¢ <strong>Connectivity:</strong> Connects all vertices with minimum total weight<br>
                ‚Ä¢ <strong>Tree Structure:</strong> Contains exactly n-1 edges for n vertices<br>
                ‚Ä¢ <strong>No Cycles:</strong> Adding any edge creates a cycle<br>
                ‚Ä¢ <strong>Optimality:</strong> No other spanning tree has smaller total weight<br>
                ‚Ä¢ <strong>Uniqueness:</strong> May not be unique if edge weights are not distinct
            </div>

            <h3>Why Minimum Spanning Trees Matter</h3>

            <div class="algorithm-box">
                MSTs solve fundamental connectivity problems with minimal cost. They represent the most efficient way to connect all points in a network while minimizing the total connection cost, making them essential for network design and optimization problems.
            </div>

            <div class="applications-box">
                <strong>Real-World Applications:</strong><br>
                ‚Ä¢ <strong>Network Design:</strong> Designing telecommunication and computer networks<br>
                ‚Ä¢ <strong>Transportation:</strong> Building roads, railways, and airline routes<br>
                ‚Ä¢ <strong>Utilities:</strong> Power grid and water distribution systems<br>
                ‚Ä¢ <strong>Circuit Design:</strong> Connecting components with minimal wire length<br>
                ‚Ä¢ <strong>Clustering:</strong> Data analysis and machine learning applications
            </div>

            <div class="focus-problem">
                <strong>üéØ Focus Problem:</strong> Road Reparation<br>
                Try your best to solve this problem before continuing!
            </div>

            <p>Notice that the road that allows for a "decent route between any two cities," with cost "as small as possible" is the definition of a minimum spanning tree. Thus, we can use our favorite minimum spanning tree algorithm to determine the cost of such a tree by calculating $\sum c$ for all edges included in the tree.</p>
        </div>

        <div class="section hover-effect">
            <h2>Kruskal's Algorithm</h2>
            
            <p><span class="highlight">Kruskal's Algorithm</span> finds the MST by greedily adding edges. For all edges not yet in the MST, we can repeatedly add the edge of minimum weight to the MST except when adding edges that would form a cycle. This can be done by sorting the edges in order of non-decreasing weight.</p>

            <div class="kruskal-box">
                <strong>Kruskal's Strategy:</strong> Sort all edges by weight, then greedily add the smallest edge that doesn't create a cycle. Use Disjoint Set Union (DSU) to efficiently detect cycles in constant time.
            </div>

            <div class="step-by-step">
                <strong>Kruskal's Algorithm Steps:</strong><br>
                <strong>1.</strong> Sort all edges by weight in non-decreasing order<br>
                <strong>2.</strong> Initialize DSU with all vertices as separate components<br>
                <strong>3.</strong> For each edge in sorted order:<br>
                &nbsp;&nbsp;&nbsp;‚Ä¢ Check if endpoints are in different components (no cycle)<br>
                &nbsp;&nbsp;&nbsp;‚Ä¢ If different, add edge to MST and unite components<br>
                <strong>4.</strong> Continue until MST has n-1 edges or all edges processed
            </div>

            <div class="dsu-integration-box">
                <strong>DSU Integration:</strong> Furthermore, we can determine whether adding an edge will create a cycle in constant time using a DSU. The most expensive operation is sorting the edges, giving us the computational complexity.
            </div>

            <div class="complexity">
                <strong>Time Complexity: $\mathcal{O}(E \log E)$</strong><br>
                Note that since the most expensive operation is sorting the edges, the computational complexity of Kruskal's Algorithm is O(E log E), where E is the number of edges.
            </div>

            <h3 class="solution-header">Kruskal's Implementation</h3>

            <div class="code-container">
                <div class="code-header">C++ - Kruskal's Algorithm with DSU</div>
                <pre class="line-numbers"><code class="language-cpp">#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

using std::cout;
using std::endl;
using std::pair;
using std::vector;

// DSU Implementation
class DisjointSets {
private:
    vector&lt;int&gt; parents;
    vector&lt;int&gt; sizes;

public:
    DisjointSets(int size) : parents(size), sizes(size, 1) {
        for (int i = 0; i &lt; size; i++) { 
            parents[i] = i; 
        }
    }

    int find(int x) { 
        return parents[x] == x ? x : (parents[x] = find(parents[x])); 
    }

    bool unite(int x, int y) {
        int x_root = find(x);
        int y_root = find(y);
        if (x_root == y_root) { 
            return false; 
        }

        if (sizes[x_root] &lt; sizes[y_root]) { 
            std::swap(x_root, y_root); 
        }
        sizes[x_root] += sizes[y_root];
        parents[y_root] = x_root;
        return true;
    }
};

int main() {
    int city_num;
    int road_num;
    std::cin &gt;&gt; city_num &gt;&gt; road_num;

    struct Road {
        int c1, c2;
        int cost;
    };
    
    vector&lt;Road&gt; roads(road_num);
    for (Road &amp;r : roads) {
        std::cin &gt;&gt; r.c1 &gt;&gt; r.c2 &gt;&gt; r.cost;
        r.c1--;
        r.c2--;
    }
    
    std::sort(roads.begin(), roads.end(),
              [&amp;](const Road &amp;e1, const Road &amp;e2) { 
                  return e1.cost &lt; e2.cost; 
              });

    DisjointSets cities(city_num);
    long long min_cost = 0;
    int added = 0;
    
    for (Road &amp;r : roads) {
        bool status = cities.unite(r.c1, r.c2);
        min_cost += status * r.cost;
        added += status;
    }

    if (added != city_num - 1) {
        cout &lt;&lt; "IMPOSSIBLE" &lt;&lt; endl;
    } else {
        cout &lt;&lt; min_cost &lt;&lt; endl;
    }
}</code></pre>
            </div>

            <div class="greedy-strategy-box">
                <strong>Greedy Correctness:</strong> Kruskal's algorithm works because it follows the greedy choice property. At each step, adding the minimum weight edge that doesn't create a cycle is always safe and leads to an optimal solution.
            </div>

            <div class="algorithm-box">
                <strong>Cycle Detection:</strong> However, we must also account for the impossible case, which occurs when any nodes cannot be connected to the tree. Recall that the minimum spanning tree must contain a total of n-1 edges, so we can use a variable cnt that is incremented every time we add an edge to the minimum spanning tree.
            </div>

            <div class="mst-visualization">
                <strong>Kruskal's Algorithm Visualization</strong>
                <p><strong>Step 1:</strong> Sort edges: [(1,2,1), (2,3,2), (1,3,3), (3,4,4)]</p>
                <p><strong>Step 2:</strong> Add edge (1,2) with cost 1 ‚Üí Components: {1,2}, {3}, {4}</p>
                <p><strong>Step 3:</strong> Add edge (2,3) with cost 2 ‚Üí Components: {1,2,3}, {4}</p>
                <p><strong>Step 4:</strong> Add edge (3,4) with cost 4 ‚Üí Components: {1,2,3,4}</p>
                <p><strong>Result:</strong> MST with total cost = 1 + 2 + 4 = 7</p>
            </div>
        </div>

        <div class="section hover-effect">
            <h2>Prim's Algorithm</h2>

            <p>Similar to Dijkstra's algorithm, <span class="highlight">Prim's algorithm</span> greedily adds vertices. On each iteration, we add the vertex that is closest to the current MST (instead of closest to the source in Dijkstra's) until all vertices have been added.</p>

            <div class="prim-box">
                <strong>Prim's Strategy:</strong> Start with any vertex and grow the MST by repeatedly adding the minimum weight edge that connects a vertex in the MST to a vertex outside the MST.
            </div>

            <div class="step-by-step">
                <strong>Prim's Algorithm Steps:</strong><br>
                <strong>1.</strong> Start with any vertex (usually vertex 0)<br>
                <strong>2.</strong> Initialize distances to all other vertices as infinity<br>
                <strong>3.</strong> Use priority queue to track minimum edge to each vertex<br>
                <strong>4.</strong> While MST is not complete:<br>
                &nbsp;&nbsp;&nbsp;‚Ä¢ Extract vertex with minimum distance to MST<br>
                &nbsp;&nbsp;&nbsp;‚Ä¢ Add vertex to MST<br>
                &nbsp;&nbsp;&nbsp;‚Ä¢ Update distances to neighbors if shorter path found
            </div>

            <div class="priority-queue-box">
                <strong>Priority Queue Optimization:</strong> The process of finding the closest vertex to the MST can be done efficiently using a priority queue. After removing a vertex, we add all of its neighbors that are not yet in the MST to the priority queue and repeat.
            </div>

            <h3>Complexity Analysis</h3>

            <div class="complexity">
                <strong>Priority Queue Implementation: $\mathcal{O}(E \log E)$</strong><br>
                Our implementation has complexity O(E log E) since in the worst case every edge will be checked and its corresponding vertex will be added to the priority queue.
            </div>

            <div class="optimization-box">
                <strong>Linear Search Alternative:</strong> Alternatively, we may linearly search for the closest vertex instead of using a priority queue. Each linear pass runs in time O(V), and this must be repeated V times. Thus, this version of Prim's algorithm has complexity O(V¬≤). As with Dijkstra, this complexity is preferable for dense graphs (in which E ‚âà V¬≤).
            </div>

            <h3 class="solution-header">Prim's Implementation</h3>

            <div class="code-container">
                <div class="code-header">C++ - Prim's Algorithm with Priority Queue</div>
                <pre class="line-numbers"><code class="language-cpp">#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;limits&gt;
#include &lt;queue&gt;
#include &lt;vector&gt;

using std::cout;
using std::endl;
using std::pair;
using std::vector;

long long prim(const vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; &amp;neighbors) {
    const int n = neighbors.size();  // just a shorthand
    long long min_cost = 0;
    vector&lt;long long&gt; dist(n, std::numeric_limits&lt;long long&gt;().max());
    dist[0] = 0;
    std::priority_queue&lt;pair&lt;long long, int&gt;&gt; q;
    q.push({0, 0});
    vector&lt;bool&gt; visited(n);
    int added = 0;
    
    while (added &lt; n) {
        if (q.empty()) { 
            return -1; 
        }
        
        auto [curr_cost, v] = q.top();
        q.pop();
        curr_cost *= -1;
        
        if (dist[v] &lt; curr_cost) { 
            continue; 
        }

        added++;
        visited[v] = true;
        min_cost += curr_cost;
        
        for (auto &amp;[next, n_cost] : neighbors[v]) {
            if (!visited[next] &amp;&amp; n_cost &lt; dist[next]) {
                dist[next] = n_cost;
                q.push({-n_cost, next});
            }
        }
    }

    return min_cost;
}

int main() {
    int city_num;
    int road_num;
    std::cin &gt;&gt; city_num &gt;&gt; road_num;

    vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; neighbors(city_num);
    for (int r = 0; r &lt; road_num; r++) {
        int a, b;
        int cost;
        std::cin &gt;&gt; a &gt;&gt; b &gt;&gt; cost;
        neighbors[--a].push_back({--b, cost});
        neighbors[b].push_back({a, cost});
    }

    long long min_cost = prim(neighbors);
    if (min_cost == -1) {
        cout &lt;&lt; "IMPOSSIBLE" &lt;&lt; endl;
    } else {
        cout &lt;&lt; min_cost &lt;&lt; endl;
    }
}</code></pre>
            </div>

            <div class="algorithm-box">
                <strong>Prim's Key Insight:</strong> Unlike Kruskal's which considers edges globally, Prim's grows the MST locally by always choosing the minimum edge that expands the current tree. This makes it naturally handle disconnected graphs by detecting when no more vertices can be reached.
            </div>

            <div class="mst-visualization">
                <strong>Prim's Algorithm Visualization</strong>
                <p><strong>Step 1:</strong> Start with vertex 1, MST = {1}</p>
                <p><strong>Step 2:</strong> Add closest vertex 2 with edge cost 1, MST = {1,2}</p>
                <p><strong>Step 3:</strong> Add closest vertex 3 with edge cost 2, MST = {1,2,3}</p>
                <p><strong>Step 4:</strong> Add closest vertex 4 with edge cost 4, MST = {1,2,3,4}</p>
                <p><strong>Result:</strong> Same MST as Kruskal's with total cost = 7</p>
            </div>
        </div>

        <div class="section hover-effect">
            <h2>Algorithm Comparison and Analysis</h2>

            <h3>Kruskal's vs Prim's: When to Use Which?</h3>

            <div class="comparison-box">
                <strong>Algorithm Trade-offs:</strong><br>
                ‚Ä¢ <strong>Kruskal's:</strong> Better for sparse graphs, easier to implement with DSU<br>
                ‚Ä¢ <strong>Prim's:</strong> Better for dense graphs, more intuitive vertex-by-vertex growth<br>
                ‚Ä¢ <strong>Both:</strong> Guarantee optimal MST, same time complexity with priority queue<br>
                ‚Ä¢ <strong>Edge vs Vertex:</strong> Kruskal's focuses on edges, Prim's focuses on vertices
            </div>

            <div class="mst-visualization">
                <strong>Detailed Complexity Comparison</strong>
                <table style="margin: 20px auto; border-collapse: collapse; font-family: 'Courier New', monospace; font-weight: 700;">
                    <tr style="background: #34495e; color: white;">
                        <td style="padding: 12px; border: 2px solid #34495e;">Algorithm</td>
                        <td style="padding: 12px; border: 2px solid #34495e;">Time Complexity</td>
                        <td style="padding: 12px; border: 2px solid #34495e;">Space Complexity</td>
                        <td style="padding: 12px; border: 2px solid #34495e;">Best For</td>
                    </tr>
                    <tr>
                        <td style="padding: 10px; border: 1px solid #bdc3c7; background: #ecf0f1;"><strong>Kruskal's</strong></td>
                        <td style="padding: 10px; border: 1px solid #bdc3c7;">O(E log E)</td>
                        <td style="padding: 10px; border: 1px solid #bdc3c7;">O(E + V)</td>
                        <td style="padding: 10px; border: 1px solid #bdc3c7;">Sparse graphs</td>
                    </tr>
                    <tr>
                        <td style="padding: 10px; border: 1px solid #bdc3c7; background: #ecf0f1;"><strong>Prim's (PQ)</strong></td>
                        <td style="padding: 10px; border: 1px solid #bdc3c7;">O(E log V)</td>
                        <td style="padding: 10px; border: 1px solid #bdc3c7;">O(E + V)</td>
                        <td style="padding: 10px; border: 1px solid #bdc3c7;">Dense graphs</td>
                    </tr>
                    <tr>
                        <td style="padding: 10px; border: 1px solid #bdc3c7; background: #ecf0f1;"><strong>Prim's (Linear)</strong></td>
                        <td style="padding: 10px; border: 1px solid #bdc3c7;">O(V¬≤)</td>
                        <td style="padding: 10px; border: 1px solid #bdc3c7;">O(V)</td>
                        <td style="padding: 10px; border: 1px solid #bdc3c7;">Very dense graphs</td>
                    </tr>
                </table>
            </div>

            <h3>Correctness and Optimality</h3>

            <div class="greedy-strategy-box">
                <strong>Greedy Algorithm Proof:</strong> Both algorithms work because they follow the cut property of MSTs. At each step, they select the minimum weight edge crossing a cut (partition) of vertices, which is guaranteed to be in some MST.
            </div>

            <div class="algorithm-box">
                <strong>Cycle Property:</strong> If we add any edge not in the MST to the MST, it creates exactly one cycle. The heaviest edge in this cycle can be removed to get another spanning tree with equal or lesser weight.
            </div>

            <h3>Advanced Variations and Optimizations</h3>

            <div class="optimization-box">
                <strong>Advanced Techniques:</strong><br>
                ‚Ä¢ <strong>Bor≈Øvka's Algorithm:</strong> Parallel-friendly MST algorithm<br>
                ‚Ä¢ <strong>Fibonacci Heaps:</strong> Can improve Prim's to O(E + V log V)<br>
                ‚Ä¢ <strong>Linear Time MST:</strong> Theoretical O(E) algorithm exists<br>
                ‚Ä¢ <strong>Approximate MST:</strong> For very large graphs, approximation algorithms
            </div>
        </div>

        <div class="section hover-effect">
            <h2>Common MST Problem Patterns</h2>

            <div class="problem-patterns">
                <div class="pattern-card">
                    <div class="pattern-title">üåê Network Design</div>
                    <p><strong>Problem:</strong> Connect all locations with minimum total cost<br>
                    <strong>Approach:</strong> Direct MST application on weighted graph<br>
                    <strong>Examples:</strong> Road networks, telecommunications, power grids</p>
                </div>
                
                <div class="pattern-card">
                    <div class="pattern-title">üîó Clustering Applications</div>
                    <p><strong>Problem:</strong> Group similar data points with minimum separation<br>
                    <strong>Approach:</strong> Build MST, remove heaviest edges to form clusters<br>
                    <strong>Examples:</strong> Data mining, image segmentation, social networks</p>
                </div>
                
                <div class="pattern-card">
                    <div class="pattern-title">üí∞ Optimization Problems</div>
                    <p><strong>Problem:</strong> Minimize cost while maintaining connectivity<br>
                    <strong>Approach:</strong> Model as MST with various constraint modifications<br>
                    <strong>Examples:</strong> Supply chain, facility location, circuit design</p>
                </div>
            </div>

            <h3>Real-World Problem Variations</h3>

            <div class="applications-box">
                <strong>Extended Applications:</strong><br>
                ‚Ä¢ <strong>Steiner Trees:</strong> Connect required vertices, may include additional vertices<br>
                ‚Ä¢ <strong>Degree-Constrained MST:</strong> Limit the degree of vertices in the tree<br>
                ‚Ä¢ <strong>Dynamic MST:</strong> Handle edge insertions and deletions efficiently<br>
                ‚Ä¢ <strong>Distributed MST:</strong> Compute MST in distributed/parallel environments<br>
                ‚Ä¢ <strong>Approximation Algorithms:</strong> TSP approximation using MST
            </div>

            <h3>MST in Competitive Programming</h3>

            <div class="code-container">
                <div class="code-header">C++ - MST Template for Contests</div>
                <pre class="line-numbers"><code class="language-cpp">// Compact MST template using Kruskal's
struct Edge {
    int u, v, w;
    bool operator&lt;(const Edge&amp; other) const {
        return w &lt; other.w;
    }
};

class DSU {
    vector&lt;int&gt; p, sz;
public:
    DSU(int n) : p(n), sz(n, 1) {
        iota(p.begin(), p.end(), 0);
    }
    
    int find(int x) {
        return p[x] == x ? x : p[x] = find(p[x]);
    }
    
    bool unite(int x, int y) {
        x = find(x), y = find(y);
        if (x == y) return false;
        if (sz[x] &lt; sz[y]) swap(x, y);
        p[y] = x, sz[x] += sz[y];
        return true;
    }
};

long long kruskal_mst(int n, vector&lt;Edge&gt;&amp; edges) {
    sort(edges.begin(), edges.end());
    DSU dsu(n);
    long long cost = 0;
    int count = 0;
    
    for (auto&amp; e : edges) {
        if (dsu.unite(e.u, e.v)) {
            cost += e.w;
            if (++count == n - 1) break;
        }
    }
    
    return count == n - 1 ? cost : -1; // -1 if impossible
}</code></pre>
            </div>

            <div class="step-by-step">
                <strong>Contest Strategy:</strong><br>
                <strong>1.</strong> Identify if problem requires MST (connecting all vertices minimally)<br>
                <strong>2.</strong> Choose Kruskal's for most contest problems (simpler with DSU)<br>
                <strong>3.</strong> Handle edge cases: disconnected graph, single vertex<br>
                <strong>4.</strong> Consider if you need the actual tree or just the cost<br>
                <strong>5.</strong> Watch for integer overflow with large weights
            </div>
        </div>

        <div class="section hover-effect">
            <h2>Implementation Tips and Best Practices</h2>

            <h3>Common Implementation Mistakes</h3>

            <div class="warning">
                <strong>Pitfall Prevention:</strong><br>
                ‚Ä¢ Don't forget to check if graph is connected (count edges in result)<br>
                ‚Ä¢ Handle the case where MST is impossible (disconnected components)<br>
                ‚Ä¢ Be careful with integer overflow for large edge weights<br>
                ‚Ä¢ Ensure proper DSU implementation with path compression<br>
                ‚Ä¢ Remember to decrement indices if input is 1-based
            </div>

            <h3>Performance Optimization Tips</h3>

            <div class="optimization-box">
                <strong>Optimization Strategies:</strong><br>
                ‚Ä¢ <strong>Early Termination:</strong> Stop Kruskal's when n-1 edges found<br>
                ‚Ä¢ <strong>DSU Optimizations:</strong> Use union by rank and path compression<br>
                ‚Ä¢ <strong>Memory Management:</strong> Reserve vector space for better cache performance<br>
                ‚Ä¢ <strong>Edge Preprocessing:</strong> Remove obviously unnecessary edges before sorting<br>
                ‚Ä¢ <strong>Algorithm Choice:</strong> Use linear Prim's for very dense graphs
            </div>

            <h3>Debugging MST Algorithms</h3>

            <div class="algorithm-box">
                <strong>Debug Strategy:</strong> Print the edges being added to the MST, track component counts in DSU, and verify that the final tree has exactly n-1 edges and connects all vertices.
            </div>

            <div class="code-container">
                <div class="code-header">C++ - MST Debug Helper</div>
                <pre class="line-numbers"><code class="language-cpp">// Add these functions for debugging MST algorithms
void print_edge(const Edge&amp; e, bool added) {
    cout &lt;&lt; "Edge (" &lt;&lt; e.u &lt;&lt; "," &lt;&lt; e.v &lt;&lt; ") weight=" &lt;&lt; e.w 
         &lt;&lt; (added ? " ADDED" : " SKIPPED") &lt;&lt; "\n";
}

void verify_mst(const vector&lt;Edge&gt;&amp; mst_edges, int n) {
    cout &lt;&lt; "MST Verification:\n";
    cout &lt;&lt; "Edges in MST: " &lt;&lt; mst_edges.size() &lt;&lt; "\n";
    cout &lt;&lt; "Expected edges: " &lt;&lt; n - 1 &lt;&lt; "\n";
    
    long long total_weight = 0;
    for (const auto&amp; e : mst_edges) {
        total_weight += e.w;
        cout &lt;&lt; "(" &lt;&lt; e.u &lt;&lt; "," &lt;&lt; e.v &lt;&lt; ") = " &lt;&lt; e.w &lt;&lt; "\n";
    }
    cout &lt;&lt; "Total weight: " &lt;&lt; total_weight &lt;&lt; "\n";
}</code></pre>
            </div>
        </div>

        <div class="section hover-effect">
            <h2>Summary and Key Takeaways</h2>

            <div class="definition-box">
                Minimum Spanning Trees represent the optimal solution for connecting all vertices in a weighted graph with minimum total cost. Both Kruskal's and Prim's algorithms provide efficient solutions using greedy strategies.
            </div>

            <div class="problem-patterns">
                <div class="pattern-card">
                    <div class="pattern-title">What You've Mastered</div>
                    <ul style="padding-left: 20px; list-style: disc;">
                        <li>Understanding of spanning trees and MST properties</li>
                        <li>Kruskal's algorithm with DSU integration</li>
                        <li>Prim's algorithm with priority queue optimization</li>
                        <li>Algorithm comparison and complexity analysis</li>
                        <li>Real-world applications and problem patterns</li>
                    </ul>
                </div>
                <div class="pattern-card">
                    <div class="pattern-title">Next Learning Goals</div>
                    <ul style="padding-left: 20px; list-style: disc;">
                        <li>Practice with network design problems</li>
                        <li>Explore Steiner tree problems</li>
                        <li>Study approximation algorithms using MST</li>
                        <li>Learn about parallel MST algorithms</li>
                        <li>Solve advanced MST variations in contests</li>
                    </ul>
                </div>
            </div>

            <div class="focus-problem">
                <strong>üéØ Practice Challenge:</strong><br>
                Now that you understand MST algorithms, try solving "Connecting Cities with Minimum Cost," "Min Cost to Connect All Points," or "Find Critical and Pseudo-Critical Edges" to practice different MST applications!
            </div>

            <div class="mst-benefits-box">
                <strong>Real-World Impact:</strong> MST algorithms are fundamental in network design, infrastructure planning, data analysis, and optimization. They provide the foundation for many advanced graph algorithms and practical solutions.
            </div>

            <div class="comparison-box">
                <strong>Key Insight:</strong> Both Kruskal's and Prim's algorithms demonstrate the power of greedy algorithms in graph theory. They transform complex optimization problems into systematic, efficient solutions.
            </div>

            <div class="algorithm-box">
                <strong>Performance Guarantee:</strong> Both algorithms provide O(E log E) or O(E log V) time complexity, making them highly efficient even for large graphs. The choice between them depends on graph density and implementation preferences.
            </div>

            <div class="complexity">
                <strong>Final Reminder:</strong> MST algorithms are often the key to solving connectivity optimization problems. Always consider MST when you need to connect all vertices with minimum cost, whether in network design, clustering, or approximation algorithms.
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
</body>
</html>