<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Meet In The Middle</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet">
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']]
            }
        };
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-weight: 600;
            line-height: 1.7;
            color: #2c3e50;
            background: white;
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 40px 20px;
            animation: fadeInUp 0.8s ease-out;
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        h1 {
            font-size: 3.5rem;
            font-weight: 800;
            color: #2c3e50;
            text-align: center;
            margin-bottom: 50px;
            position: relative;
            animation: slideInDown 1s ease-out;
        }

        @keyframes slideInDown {
            from {
                opacity: 0;
                transform: translateY(-50px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        h1::after {
            content: '';
            display: block;
            width: 280px;
            height: 4px;
            background: linear-gradient(90deg, #16a085, #1abc9c);
            margin: 20px auto;
            border-radius: 2px;
            animation: expandLine 1.2s ease-out 0.5s both;
        }

        @keyframes expandLine {
            from {
                width: 0;
            }
            to {
                width: 280px;
            }
        }

        h2 {
            font-size: 2.4rem;
            font-weight: 700;
            color: #34495e;
            margin-top: 60px;
            margin-bottom: 25px;
            border-left: 5px solid #16a085;
            padding-left: 20px;
            animation: slideInLeft 0.6s ease-out;
        }

        @keyframes slideInLeft {
            from {
                opacity: 0;
                transform: translateX(-30px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        h3 {
            font-size: 1.9rem;
            font-weight: 700;
            color: #2c3e50;
            margin-top: 40px;
            margin-bottom: 20px;
            position: relative;
        }

        h3::before {
            content: 'üß†';
            margin-right: 10px;
            font-size: 0.9em;
        }

        p {
            font-size: 1.15rem;
            font-weight: 600;
            margin-bottom: 25px;
            text-align: justify;
            line-height: 1.8;
        }

        ul {
            margin: 25px 0;
            padding-left: 0;
        }

        li {
            font-size: 1.15rem;
            font-weight: 600;
            margin-bottom: 15px;
            line-height: 1.8;
            list-style: none;
            position: relative;
            padding-left: 30px;
        }

        li::before {
            content: 'üí°';
            position: absolute;
            left: 0;
            top: 0;
        }

        .code-container {
            background: #1e1e1e;
            border-radius: 12px;
            margin: 30px 0;
            overflow: hidden;
            box-shadow: 0 8px 25px rgba(0,0,0,0.15);
            border: 1px solid #333;
            animation: fadeIn 0.8s ease-out;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }

        .code-header {
            background: linear-gradient(90deg, #2c3e50, #34495e);
            color: white;
            padding: 12px 20px;
            font-weight: 700;
            font-size: 0.9rem;
            border-bottom: 1px solid #444;
        }

        pre {
            margin: 0 !important;
            background: #1e1e1e !important;
            border-radius: 0 !important;
        }

        code {
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace !important;
            font-size: 0.95rem !important;
            line-height: 1.6 !important;
            font-weight: 500 !important;
        }

        .line-numbers-rows {
            border-right: 1px solid #444 !important;
            padding-right: 10px !important;
            margin-right: 15px !important;
        }

        .complexity {
            background: linear-gradient(135deg, #d5f4e6, #85e6b3);
            padding: 20px 25px;
            border-radius: 12px;
            border-left: 4px solid #16a085;
            margin: 25px 0;
            font-weight: 700;
            box-shadow: 0 4px 15px rgba(22, 160, 133, 0.1);
        }

        .warning {
            background: linear-gradient(135deg, #fff3cd, #ffeaa7);
            padding: 20px 25px;
            border-radius: 12px;
            border-left: 4px solid #ffc107;
            margin: 25px 0;
            font-weight: 700;
            box-shadow: 0 4px 15px rgba(255, 193, 7, 0.1);
        }

        .warning::before {
            content: '‚ö†Ô∏è ';
            font-size: 1.2em;
        }

        .section {
            margin-bottom: 50px;
            padding: 35px;
            background: #fafbfc;
            border-radius: 15px;
            border: 1px solid #e1e8ed;
            animation: slideInUp 0.6s ease-out;
        }

        @keyframes slideInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .focus-problem {
            background: linear-gradient(135deg, #d5f4e6, #85e6b3);
            padding: 25px;
            border-radius: 15px;
            margin: 30px 0;
            border: 2px solid #16a085;
            text-align: center;
            font-weight: 700;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% {
                box-shadow: 0 0 0 0 rgba(22, 160, 133, 0.4);
            }
            70% {
                box-shadow: 0 0 0 10px rgba(22, 160, 133, 0);
            }
            100% {
                box-shadow: 0 0 0 0 rgba(22, 160, 133, 0);
            }
        }

        .highlight {
            background: linear-gradient(120deg, #85e6b3 0%, #74b9ff 100%);
            padding: 3px 8px;
            border-radius: 6px;
            font-weight: 800;
        }

        .hover-effect {
            transition: all 0.3s ease;
        }

        .hover-effect:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 35px rgba(0,0,0,0.15);
        }

        .definition-box {
            background: linear-gradient(135deg, #d5f4e6, #85e6b3);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 4px solid #16a085;
            font-weight: 700;
        }

        .definition-box::before {
            content: 'üìö Definition: ';
            font-weight: 800;
            color: #0f7864;
        }

        .algorithm-box {
            background: linear-gradient(135deg, #e8f5e8, #d4edda);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 4px solid #28a745;
            font-weight: 700;
        }

        .algorithm-box::before {
            content: '‚ö° Key Insight: ';
            font-weight: 800;
            color: #155724;
        }

        .solution-header {
            color: #16a085;
            font-weight: 800;
            border-bottom: 3px solid #16a085;
            padding-bottom: 8px;
            display: inline-block;
            margin-bottom: 20px;
        }

        .math-display {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            margin: 25px 0;
            text-align: center;
            border: 2px solid #e9ecef;
            font-size: 1.2rem;
        }

        .mitm-box {
            background: linear-gradient(135deg, #d5f4e6, #85e6b3);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 4px solid #16a085;
            font-weight: 700;
        }

        .mitm-box::before {
            content: 'üéØ Meet In The Middle: ';
            font-weight: 800;
            color: #0f7864;
        }

        .step-by-step {
            background: linear-gradient(135deg, #fef7ff, #f3e8ff);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 4px solid #a855f7;
            font-weight: 700;
        }

        .step-by-step::before {
            content: 'üìù Algorithm Steps: ';
            font-weight: 800;
            color: #7c2d12;
        }

        .optimization-box {
            background: linear-gradient(135deg, #fef3c7, #fbbf24);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 4px solid #f59e0b;
            font-weight: 700;
        }

        .optimization-box::before {
            content: '‚ö° Optimization: ';
            font-weight: 800;
            color: #92400e;
        }

        .mitm-visualization {
            background: #f8f9fa;
            padding: 30px;
            border-radius: 12px;
            margin: 30px 0;
            text-align: center;
            border: 2px solid #e9ecef;
        }

        .applications-box {
            background: linear-gradient(135deg, #f0f4f8, #ddd6fe);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 4px solid #8b5cf6;
            font-weight: 700;
        }

        .applications-box::before {
            content: 'üìñ Applications: ';
            font-weight: 800;
            color: #7c3aed;
        }

        .problem-patterns {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 20px;
            margin: 30px 0;
        }

        .pattern-card {
            background: white;
            border-radius: 12px;
            padding: 25px;
            border-left: 4px solid #16a085;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            transition: transform 0.3s ease;
        }

        .pattern-card:hover {
            transform: translateY(-5px);
        }

        .pattern-card:nth-child(1) {
            border-left-color: #e74c3c;
        }

        .pattern-card:nth-child(2) {
            border-left-color: #3498db;
        }

        .pattern-card:nth-child(3) {
            border-left-color: #2ecc71;
        }

        .pattern-title {
            font-weight: 800;
            color: #16a085;
            margin-bottom: 15px;
            font-size: 1.3rem;
        }

        .pattern-card:nth-child(1) .pattern-title {
            color: #e74c3c;
        }

        .pattern-card:nth-child(2) .pattern-title {
            color: #3498db;
        }

        .pattern-card:nth-child(3) .pattern-title {
            color: #2ecc71;
        }

        .naive-solution-box {
            background: linear-gradient(135deg, #ffebee, #ffcdd2);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 4px solid #f44336;
            font-weight: 700;
        }

        .naive-solution-box::before {
            content: '‚ùå Naive Approach: ';
            font-weight: 800;
            color: #d32f2f;
        }

        .divide-conquer-box {
            background: linear-gradient(135deg, #e3f2fd, #bbdefb);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 4px solid #2196f3;
            font-weight: 700;
        }

        .divide-conquer-box::before {
            content: 'üîÑ Divide & Conquer: ';
            font-weight: 800;
            color: #1976d2;
        }

        .binary-search-box {
            background: linear-gradient(135deg, #fff3e0, #ffe0b2);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 4px solid #ff9800;
            font-weight: 700;
        }

        .binary-search-box::before {
            content: 'üîç Binary Search: ';
            font-weight: 800;
            color: #f57c00;
        }

        .subset-sum-box {
            background: linear-gradient(135deg, #f3e5f5, #e1bee7);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 4px solid #9c27b0;
            font-weight: 700;
        }

        .subset-sum-box::before {
            content: 'üé≤ Subset Sum: ';
            font-weight: 800;
            color: #7b1fa2;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Meet In The Middle</h1>
        
        <div class="section hover-effect">
            <h2>Introduction to Meet In The Middle</h2>
            
            <p><span class="highlight">Meet In The Middle</span> is a powerful algorithmic technique that splits a problem into two halves, solves each half independently, and then combines the results. This approach is particularly effective for reducing exponential time complexity when brute force would be too slow.</p>

            <div class="definition-box">
                Meet In The Middle (MITM) is a divide-and-conquer optimization technique that reduces the search space from O(2^n) to O(2^(n/2)) by splitting the problem domain in half, processing each half separately, and then merging the results efficiently.
            </div>

            <div class="mitm-box">
                <strong>Core Concept:</strong> Instead of exploring all 2^n possibilities at once, we explore 2^(n/2) possibilities for each half separately, then combine them intelligently. This transforms an infeasible O(2^n) algorithm into a manageable O(n √ó 2^(n/2)) solution.
            </div>

            <div class="applications-box">
                <strong>Common MITM Applications:</strong><br>
                ‚Ä¢ <strong>Subset Sum Problems:</strong> Find subsets with specific sum properties<br>
                ‚Ä¢ <strong>Knapsack Variants:</strong> Optimize with exponential constraints<br>
                ‚Ä¢ <strong>Cryptographic Attacks:</strong> Breaking encryption with reduced search space<br>
                ‚Ä¢ <strong>Game Theory:</strong> Optimal strategies in two-player games<br>
                ‚Ä¢ <strong>String Matching:</strong> Pattern matching with exponential patterns
            </div>

            <div class="algorithm-box">
                <strong>Why MITM Works:</strong> The technique exploits the mathematical fact that 2^(n/2) + 2^(n/2) = 2 √ó 2^(n/2) << 2^n. For n=40, instead of 2^40 ‚âà 10^12 operations, we need only 2 √ó 2^20 ‚âà 2 √ó 10^6 operations - a reduction of 6 orders of magnitude!
            </div>
        </div>

        <div class="section hover-effect">
            <h2>Problem Analysis: Subset Sum with Target</h2>
            
            <p>Let's examine a classic problem that demonstrates the power of Meet In The Middle: given an array of n elements (where n ‚â§ 40), count how many subsets have a sum equal to target value x.</p>

            <div class="focus-problem">
                <strong>üéØ Focus Problem:</strong> Subset Sum Counting<br>
                Given array of size n ‚â§ 40, count subsets with sum = x
            </div>

            <h3>Naive Solution Analysis</h3>

            <div class="naive-solution-box">
                <strong>Brute Force Approach:</strong> Loop through all subsets in the array and if the sum is equal to x, then increase our answer. Worst case this does about 2^40 operations, which is way too slow.
            </div>

            <div class="math-display">
                <strong>Time Complexity:</strong> O(2^n)<br>
                <strong>For n = 40:</strong> 2^40 ‚âà 1.1 √ó 10^12 operations<br>
                <strong>Estimated Runtime:</strong> Several hours to days
            </div>

            <div class="warning">
                With n = 40, the naive approach requires over a trillion operations, making it completely impractical for competitive programming time limits (typically 1-2 seconds).
            </div>

            <h3>Meet In The Middle Solution</h3>

            <div class="mitm-box">
                <strong>MITM Strategy:</strong> We can divide the given array into two separate arrays. Let's say that the left array runs from indexes 0 to n/2-1, and the right array runs from indexes n/2 to n-1. Both arrays will have at most 20 elements, so we can loop through all subsets of these two arrays in at most 2^21 operations, which is perfectly fine.
            </div>

            <div class="divide-conquer-box">
                <strong>Division Strategy:</strong><br>
                ‚Ä¢ <strong>Left Half:</strong> Indices [0, n/2-1] ‚Üí at most 20 elements<br>
                ‚Ä¢ <strong>Right Half:</strong> Indices [n/2, n-1] ‚Üí at most 20 elements<br>
                ‚Ä¢ <strong>Subset Generation:</strong> 2^20 ‚âà 10^6 subsets per half<br>
                ‚Ä¢ <strong>Total Operations:</strong> 2 √ó 10^6 for generation + merging cost
            </div>

            <div class="step-by-step">
                <strong>Algorithm Steps:</strong><br>
                <strong>1.</strong> Split array into left and right halves<br>
                <strong>2.</strong> Generate all possible subset sums for left half<br>
                <strong>3.</strong> Generate all possible subset sums for right half<br>
                <strong>4.</strong> Sort the right half sums for binary search<br>
                <strong>5.</strong> For each left sum, count right sums that equal (target - left sum)<br>
                <strong>6.</strong> Sum all valid combinations
            </div>

            <div class="binary-search-box">
                <strong>Combination Strategy:</strong> Now that we've got the subset sums of these two separate arrays, we need to recombine them to search for our answer. For every sum in the left, we can simply check how many elements of x - sum there are in right. This can be done using simple binary search.
            </div>

            <div class="complexity">
                <strong>Time Complexity: $\mathcal{O}(N \cdot 2^{N/2})$</strong><br>
                Where the N factor comes from binary search operations and the 2^(N/2) from subset generation.
            </div>
        </div>

        <div class="section hover-effect">
            <h2>Complete Implementation</h2>

            <h3 class="solution-header">Meet In The Middle Solution</h3>

            <div class="code-container">
                <div class="code-header">C++ - Meet In The Middle Implementation</div>
                <pre class="line-numbers"><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
using ll = long long;

int main() {
    int n, x;
    cin &gt;&gt; n &gt;&gt; x;
    vector&lt;int&gt; a(n);
    for (int i = 0; i &lt; n; i++) { 
        cin &gt;&gt; a[i]; 
    }

    // stores all possible subset sums in the interval [l, r]
    auto get_subset_sums = [&amp;](int l, int r) -&gt; vector&lt;ll&gt; {
        int len = r - l + 1;
        vector&lt;ll&gt; res;

        // loop through all subsets
        for (int i = 0; i &lt; (1 &lt;&lt; len); i++) {
            ll sum = 0;
            for (int j = 0; j &lt; len; j++) {
                if (i &amp; (1 &lt;&lt; j)) { 
                    sum += a[l + j]; 
                }
            }
            res.push_back(sum);
        }

        return res;
    };

    vector&lt;ll&gt; left = get_subset_sums(0, n / 2 - 1);
    vector&lt;ll&gt; right = get_subset_sums(n / 2, n - 1);
    sort(left.begin(), left.end());
    sort(right.begin(), right.end());

    ll ans = 0;
    for (ll i : left) {
        auto low_iterator = lower_bound(right.begin(), right.end(), x - i);
        auto high_iterator = upper_bound(right.begin(), right.end(), x - i);
        ans += high_iterator - low_iterator;
    }

    cout &lt;&lt; ans &lt;&lt; endl;
}</code></pre>
            </div>

            <div class="algorithm-box">
                <strong>Implementation Details:</strong> The get_subset_sums lambda function generates all possible subset sums for a given range using bit manipulation. For each subset (represented by bitmask i), we check each bit to determine which elements to include in the current subset.
            </div>

            <div class="optimization-box">
                <strong>Binary Search Optimization:</strong> We use lower_bound and upper_bound to efficiently count occurrences of (x - i) in the right array. This avoids linear scanning and maintains the O(log n) search complexity.
            </div>

            <div class="mitm-visualization">
                <strong>Algorithm Visualization</strong>
                <p><strong>Example:</strong> Array = [1, 2, 3, 4], Target = 5</p>
                <p><strong>Left Half:</strong> [1, 2] ‚Üí Sums: {0, 1, 2, 3}</p>
                <p><strong>Right Half:</strong> [3, 4] ‚Üí Sums: {0, 3, 4, 7}</p>
                <p><strong>Combinations:</strong></p>
                <p>‚Ä¢ Left sum = 2, need 3 from right ‚Üí found 1 occurrence</p>
                <p>‚Ä¢ Left sum = 1, need 4 from right ‚Üí found 1 occurrence</p>
                <p><strong>Total:</strong> 2 subsets with sum = 5</p>
            </div>

            <div class="subset-sum-box">
                <strong>Space Optimization:</strong> The algorithm uses O(2^(n/2)) extra space to store subset sums, which is significantly better than storing all 2^n subsets. For n=40, this means ~2MB instead of ~8TB!
            </div>
        </div>

        <div class="section hover-effect">
            <h2>Advanced MITM Techniques</h2>

            <h3>Bidirectional Search</h3>

            <div class="divide-conquer-box">
                <strong>Bidirectional BFS:</strong> In graph problems, we can start BFS from both the source and target simultaneously, meeting in the middle. This reduces the search depth from d to d/2, significantly improving performance.
            </div>

            <div class="code-container">
                <div class="code-header">C++ - Bidirectional BFS Template</div>
                <pre class="line-numbers"><code class="language-cpp">// Bidirectional BFS for shortest path
int bidirectional_bfs(int start, int target) {
    if (start == target) return 0;
    
    unordered_set&lt;int&gt; visited_start, visited_target;
    queue&lt;int&gt; q_start, q_target;
    
    q_start.push(start);
    q_target.push(target);
    visited_start.insert(start);
    visited_target.insert(target);
    
    int depth = 0;
    
    while (!q_start.empty() || !q_target.empty()) {
        depth++;
        
        // Expand from the smaller frontier
        if (q_start.size() &lt;= q_target.size()) {
            int size = q_start.size();
            for (int i = 0; i &lt; size; i++) {
                int curr = q_start.front();
                q_start.pop();
                
                for (int next : get_neighbors(curr)) {
                    if (visited_target.count(next)) {
                        return depth;
                    }
                    if (!visited_start.count(next)) {
                        visited_start.insert(next);
                        q_start.push(next);
                    }
                }
            }
        } else {
            // Similar expansion for target side
            int size = q_target.size();
            for (int i = 0; i &lt; size; i++) {
                int curr = q_target.front();
                q_target.pop();
                
                for (int next : get_neighbors(curr)) {
                    if (visited_start.count(next)) {
                        return depth;
                    }
                    if (!visited_target.count(next)) {
                        visited_target.insert(next);
                        q_target.push(next);
                    }
                }
            }
        }
    }
    
    return -1; // No path found
}</code></pre>
            </div>

            <h3>MITM in Cryptography</h3>

            <div class="applications-box">
                <strong>Cryptographic Applications:</strong><br>
                ‚Ä¢ <strong>Baby-step Giant-step:</strong> Discrete logarithm computation<br>
                ‚Ä¢ <strong>Birthday Attack:</strong> Hash function collision finding<br>
                ‚Ä¢ <strong>Block Cipher Attacks:</strong> Key recovery in encryption systems<br>
                ‚Ä¢ <strong>Password Cracking:</strong> Dictionary attacks with space-time tradeoff<br>
                ‚Ä¢ <strong>Preimage Attacks:</strong> Finding inputs that produce specific hash outputs
            </div>

            <h3>Knapsack with MITM</h3>

            <div class="optimization-box">
                <strong>Knapsack Optimization:</strong> For knapsack problems with small item counts but large values, MITM can find optimal solutions by splitting items into two groups, finding all possible (weight, value) pairs for each group, and combining optimally.
            </div>

            <div class="problem-patterns">
                <div class="pattern-card">
                    <div class="pattern-title">üéØ Subset Problems</div>
                    <p><strong>Pattern:</strong> Find subsets with specific properties<br>
                    <strong>Technique:</strong> Split into halves, generate all combinations<br>
                    <strong>Examples:</strong> Subset sum, subset XOR, closest sum</p>
                </div>
                
                <div class="pattern-card">
                    <div class="pattern-title">üîç Search Optimization</div>
                    <p><strong>Pattern:</strong> Reduce exponential search space<br>
                    <strong>Technique:</strong> Bidirectional exploration from both ends<br>
                    <strong>Examples:</strong> Shortest path, state space search, puzzle solving</p>
                </div>
                
                <div class="pattern-card">
                    <div class="pattern-title">üîê Cryptographic Attacks</div>
                    <p><strong>Pattern:</strong> Time-memory tradeoff in security analysis<br>
                    <strong>Technique:</strong> Precompute partial results, combine efficiently<br>
                    <strong>Examples:</strong> Hash collisions, discrete log, key recovery</p>
                </div>
            </div>
        </div>

        <div class="section hover-effect">
            <h2>Alternative MITM Problems</h2>

            <h3>Closest Subset Sum</h3>

            <div class="subset-sum-box">
                <strong>Problem Variation:</strong> Instead of finding exact matches, find the subset sum closest to a target value. This requires slight modifications to handle approximate matching instead of exact equality.
            </div>

            <div class="code-container">
                <div class="code-header">C++ - Closest Subset Sum with MITM</div>
                <pre class="line-numbers"><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
using ll = long long;

int main() {
    int n, target;
    cin &gt;&gt; n &gt;&gt; target;
    vector&lt;int&gt; a(n);
    for (int i = 0; i &lt; n; i++) { 
        cin &gt;&gt; a[i]; 
    }

    auto get_subset_sums = [&amp;](int l, int r) -&gt; vector&lt;ll&gt; {
        int len = r - l + 1;
        vector&lt;ll&gt; res;
        for (int i = 0; i &lt; (1 &lt;&lt; len); i++) {
            ll sum = 0;
            for (int j = 0; j &lt; len; j++) {
                if (i &amp; (1 &lt;&lt; j)) { 
                    sum += a[l + j]; 
                }
            }
            res.push_back(sum);
        }
        return res;
    };

    vector&lt;ll&gt; left = get_subset_sums(0, n / 2 - 1);
    vector&lt;ll&gt; right = get_subset_sums(n / 2, n - 1);
    sort(right.begin(), right.end());

    ll best_diff = LLONG_MAX;
    
    for (ll left_sum : left) {
        ll needed = target - left_sum;
        
        // Find closest value in right array
        auto it = lower_bound(right.begin(), right.end(), needed);
        
        // Check the closest candidates
        if (it != right.end()) {
            best_diff = min(best_diff, abs(target - (left_sum + *it)));
        }
        if (it != right.begin()) {
            --it;
            best_diff = min(best_diff, abs(target - (left_sum + *it)));
        }
    }

    cout &lt;&lt; best_diff &lt;&lt; endl;
}</code></pre>
            </div>

            <h3>4Sum Problem with MITM</h3>

            <div class="binary-search-box">
                <strong>4Sum Optimization:</strong> The classic 4Sum problem (find quadruplets with specific sum) can be solved efficiently using MITM by considering all pairs as single entities and applying the two-halves technique.
            </div>

            <div class="code-container">
                <div class="code-header">C++ - 4Sum with Meet In The Middle</div>
                <pre class="line-numbers"><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;

bool fourSum(vector&lt;int&gt;&amp; nums, int target) {
    int n = nums.size();
    if (n &lt; 4) return false;
    
    // Generate all possible pair sums
    unordered_map&lt;int, vector&lt;pair&lt;int, int&gt;&gt;&gt; pair_sums;
    
    for (int i = 0; i &lt; n; i++) {
        for (int j = i + 1; j &lt; n; j++) {
            int sum = nums[i] + nums[j];
            pair_sums[sum].push_back({i, j});
        }
    }
    
    // For each pair sum, check if complement exists
    for (auto&amp; [sum, pairs] : pair_sums) {
        int complement = target - sum;
        if (pair_sums.count(complement)) {
            // Check if we can form a valid quadruplet
            for (auto&amp; p1 : pairs) {
                for (auto&amp; p2 : pair_sums[complement]) {
                    // Ensure no index overlap
                    if (p1.first != p2.first &amp;&amp; p1.first != p2.second &amp;&amp;
                        p1.second != p2.first &amp;&amp; p1.second != p2.second) {
                        return true;
                    }
                }
            }
        }
    }
    
    return false;
}</code></pre>
            </div>

            <div class="algorithm-box">
                <strong>4Sum Complexity:</strong> The MITM approach reduces 4Sum from O(n^4) naive solution to O(n^2) time and space complexity by treating pairs as atomic units and using hash table lookups.
            </div>
        </div>

        <div class="section hover-effect">
            <h2>Advanced Optimization Techniques</h2>

            <h3>Memory Optimization</h3>

            <div class="optimization-box">
                <strong>Space-Time Tradeoffs:</strong> When memory is limited, we can use iterative deepening or process subsets in chunks rather than storing all combinations simultaneously. This trades some time efficiency for significant memory savings.
            </div>

            <h3>Pruning Strategies</h3>

            <div class="algorithm-box">
                <strong>Early Termination:</strong> In many MITM applications, we can prune the search space by establishing bounds. For example, in subset sum problems, if the current partial sum already exceeds the target, we can skip exploring further extensions.
            </div>

            <div class="code-container">
                <div class="code-header">C++ - Optimized MITM with Pruning</div>
                <pre class="line-numbers"><code class="language-cpp">// Optimized subset generation with pruning
vector&lt;ll&gt; get_subset_sums_optimized(const vector&lt;int&gt;&amp; arr, int l, int r, ll max_sum) {
    int len = r - l + 1;
    vector&lt;ll&gt; res;
    
    function&lt;void(int, ll)&gt; generate = [&amp;](int pos, ll current_sum) {
        if (pos == len) {
            if (current_sum &lt;= max_sum) {
                res.push_back(current_sum);
            }
            return;
        }
        
        // Don't include current element
        generate(pos + 1, current_sum);
        
        // Include current element (with pruning)
        if (current_sum + arr[l + pos] &lt;= max_sum) {
            generate(pos + 1, current_sum + arr[l + pos]);
        }
    };
    
    generate(0, 0);
    return res;
}</code></pre>
            </div>

            <h3>Parallel MITM</h3>

            <div class="optimization-box">
                <strong>Parallelization:</strong> MITM is naturally parallelizable since the two halves can be processed independently. Modern implementations can leverage multiple cores to process both halves simultaneously.
            </div>

            <div class="applications-box">
                <strong>Parallel Implementation Benefits:</strong><br>
                ‚Ä¢ <strong>Independent Processing:</strong> Each half can run on separate threads<br>
                ‚Ä¢ <strong>Load Balancing:</strong> Distribute subset generation across multiple cores<br>
                ‚Ä¢ <strong>Memory Locality:</strong> Each thread works on contiguous memory regions<br>
                ‚Ä¢ <strong>Scalability:</strong> Performance scales with available cores<br>
                ‚Ä¢ <strong>GPU Acceleration:</strong> Subset generation is highly parallelizable on GPUs
            </div>
        </div>

        <div class="section hover-effect">
            <h2>Implementation Tips and Best Practices</h2>

            <h3>Common MITM Mistakes</h3>

            <div class="warning">
                <strong>Pitfall Prevention:</strong><br>
                ‚Ä¢ Don't forget to handle empty subsets (sum = 0) correctly<br>
                ‚Ä¢ Be careful with integer overflow for large sums<br>
                ‚Ä¢ Ensure proper array splitting - handle odd n carefully<br>
                ‚Ä¢ Remember to sort arrays before binary search<br>
                ‚Ä¢ Consider duplicate elements and their impact on counting
            </div>

            <h3>When to Use MITM</h3>

            <div class="mitm-box">
                <strong>MITM Decision Criteria:</strong><br>
                ‚Ä¢ <strong>Exponential Search Space:</strong> Original problem has O(2^n) complexity<br>
                ‚Ä¢ <strong>Divisible Problem:</strong> Can be split into independent subproblems<br>
                ‚Ä¢ <strong>Efficient Combination:</strong> Results can be merged in polynomial time<br>
                ‚Ä¢ <strong>Memory Available:</strong> Can store O(2^(n/2)) intermediate results<br>
                ‚Ä¢ <strong>Time Constraints:</strong> Need better than exponential performance
            </div>

            <h3>Template for MITM Problems</h3>

            <div class="code-container">
                <div class="code-header">C++ - Generic MITM Template</div>
                <pre class="line-numbers"><code class="language-cpp">// Generic Meet In The Middle template
template&lt;typename T&gt;
class MeetInTheMiddle {
private:
    vector&lt;T&gt; data;
    int n;
    
public:
    MeetInTheMiddle(const vector&lt;T&gt;&amp; input) : data(input), n(input.size()) {}
    
    // Generate all possible combinations for a range
    vector&lt;T&gt; generate_combinations(int left, int right, function&lt;T(const vector&lt;T&gt;&amp;, int)&gt; combine_func) {
        int len = right - left + 1;
        vector&lt;T&gt; results;
        
        for (int mask = 0; mask &lt; (1 &lt;&lt; len); mask++) {
            results.push_back(combine_func(data, mask &lt;&lt; left));
        }
        
        return results;
    }
    
    // Main MITM solving function
    template&lt;typename Result&gt;
    Result solve(function&lt;Result(const vector&lt;T&gt;&amp;, const vector&lt;T&gt;&amp;)&gt; merge_func) {
        auto left_results = generate_combinations(0, n/2 - 1, combine_function);
        auto right_results = generate_combinations(n/2, n - 1, combine_function);
        
        return merge_func(left_results, right_results);
    }
};</code></pre>
            </div>

            <h3>Debugging MITM Algorithms</h3>

            <div class="algorithm-box">
                <strong>Debug Strategy:</strong> Test with small inputs first, verify that splitting produces correct subsets, check binary search bounds carefully, and validate that the combination logic handles all edge cases properly.
            </div>

            <div class="code-container">
                <div class="code-header">C++ - MITM Debug Helpers</div>
                <pre class="line-numbers"><code class="language-cpp">// Debug functions for MITM
void debug_subset_generation(const vector&lt;int&gt;&amp; arr, int l, int r) {
    cout &lt;&lt; "Generating subsets for range [" &lt;&lt; l &lt;&lt; ", " &lt;&lt; r &lt;&lt; "]:\n";
    int len = r - l + 1;
    
    for (int mask = 0; mask &lt; (1 &lt;&lt; len); mask++) {
        cout &lt;&lt; "Subset " &lt;&lt; mask &lt;&lt; ": {";
        ll sum = 0;
        bool first = true;
        
        for (int j = 0; j &lt; len; j++) {
            if (mask &amp; (1 &lt;&lt; j)) {
                if (!first) cout &lt;&lt; ", ";
                cout &lt;&lt; arr[l + j];
                sum += arr[l + j];
                first = false;
            }
        }
        cout &lt;&lt; "} sum = " &lt;&lt; sum &lt;&lt; "\n";
    }
}

void verify_mitm_correctness(const vector&lt;int&gt;&amp; arr, int target) {
    int n = arr.size();
    
    // Brute force for small inputs
    if (n &lt;= 20) {
        int brute_count = 0;
        for (int mask = 0; mask &lt; (1 &lt;&lt; n); mask++) {
            ll sum = 0;
            for (int j = 0; j &lt; n; j++) {
                if (mask &amp; (1 &lt;&lt; j)) {
                    sum += arr[j];
                }
            }
            if (sum == target) brute_count++;
        }
        
        // Compare with MITM result
        // ... implement MITM and compare counts
        cout &lt;&lt; "Brute force count: " &lt;&lt; brute_count &lt;&lt; "\n";
    }
}</code></pre>
            </div>
        </div>

        <div class="section hover-effect">
            <h2>Summary and Key Takeaways</h2>

            <div class="definition-box">
                Meet In The Middle is a powerful optimization technique that transforms intractable exponential problems into manageable polynomial-time algorithms by intelligently splitting the search space and combining results efficiently.
            </div>

            <div class="problem-patterns">
                <div class="pattern-card">
                    <div class="pattern-title">What You've Mastered</div>
                    <ul style="padding-left: 20px; list-style: disc;">
                        <li>Core MITM principle and exponential optimization</li>
                        <li>Subset sum problems with efficient counting</li>
                        <li>Binary search integration for fast lookups</li>
                        <li>Advanced applications: bidirectional search, 4Sum</li>
                        <li>Optimization techniques: pruning, parallelization</li>
                    </ul>
                </div>
                <div class="pattern-card">
                    <div class="pattern-title">Next Learning Goals</div>
                    <ul style="padding-left: 20px; list-style: disc;">
                        <li>Advanced MITM: baby-step giant-step algorithm</li>
                        <li>Cryptographic applications and security analysis</li>
                        <li>Time-memory tradeoffs in algorithm design</li>
                        <li>Parallel and distributed MITM implementations</li>
                        <li>MITM in competitive programming contests</li>
                    </ul>
                </div>
            </div>

            <div class="focus-problem">
                <strong>üéØ Practice Challenge:</strong><br>
                Now that you understand Meet In The Middle, try solving "Subset Sum Closest," "4Sum II," or "Palindrome Pairs" to practice different MITM applications and build your optimization skills!
            </div>

            <div class="mitm-box">
                <strong>Real-World Impact:</strong> MITM techniques are crucial in cryptography, artificial intelligence search algorithms, database query optimization, computational biology, and any domain requiring efficient exploration of exponential search spaces.
            </div>

            <div class="algorithm-box">
                <strong>Key Insight:</strong> The power of MITM lies in recognizing when a problem can be split into independent halves and combined efficiently. This simple insight can transform impossible problems into practical solutions.
            </div>

            <div class="complexity">
                <strong>Performance Summary:</strong> MITM reduces exponential O(2^n) problems to O(n √ó 2^(n/2)) solutions, enabling practical algorithms for problems with n up to 40-45. The technique trades memory for time while maintaining polynomial combination costs.
            </div>

            <div class="optimization-box">
                <strong>Final Reminder:</strong> Always consider whether your exponential problem can benefit from MITM optimization. Look for problems where you can split the input, process halves independently, and merge results efficiently. MITM is often the difference between a time limit exceeded and an accepted solution!
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
</body>
</html>