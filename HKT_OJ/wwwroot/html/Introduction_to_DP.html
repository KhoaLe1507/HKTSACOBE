<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Introduction to Dynamic Programming</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet">
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']]
            }
        };
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-weight: 600;
            line-height: 1.7;
            color: #2c3e50;
            background: white;
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 40px 20px;
            animation: fadeInUp 0.8s ease-out;
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        h1 {
            font-size: 3.5rem;
            font-weight: 800;
            color: #2c3e50;
            text-align: center;
            margin-bottom: 50px;
            position: relative;
            animation: slideInDown 1s ease-out;
        }

        @keyframes slideInDown {
            from {
                opacity: 0;
                transform: translateY(-50px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        h1::after {
            content: '';
            display: block;
            width: 250px;
            height: 4px;
            background: linear-gradient(90deg, #f39c12, #e67e22);
            margin: 20px auto;
            border-radius: 2px;
            animation: expandLine 1.2s ease-out 0.5s both;
        }

        @keyframes expandLine {
            from {
                width: 0;
            }
            to {
                width: 250px;
            }
        }

        h2 {
            font-size: 2.4rem;
            font-weight: 700;
            color: #34495e;
            margin-top: 60px;
            margin-bottom: 25px;
            border-left: 5px solid #f39c12;
            padding-left: 20px;
            animation: slideInLeft 0.6s ease-out;
        }

        @keyframes slideInLeft {
            from {
                opacity: 0;
                transform: translateX(-30px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        h3 {
            font-size: 1.9rem;
            font-weight: 700;
            color: #2c3e50;
            margin-top: 40px;
            margin-bottom: 20px;
            position: relative;
        }

        h3::before {
            content: 'üß†';
            margin-right: 10px;
            font-size: 0.9em;
        }

        p {
            font-size: 1.15rem;
            font-weight: 600;
            margin-bottom: 25px;
            text-align: justify;
            line-height: 1.8;
        }

        ul {
            margin: 25px 0;
            padding-left: 0;
        }

        li {
            font-size: 1.15rem;
            font-weight: 600;
            margin-bottom: 15px;
            line-height: 1.8;
            list-style: none;
            position: relative;
            padding-left: 30px;
        }

        li::before {
            content: 'üí°';
            position: absolute;
            left: 0;
            top: 0;
        }

        .code-container {
            background: #1e1e1e;
            border-radius: 12px;
            margin: 30px 0;
            overflow: hidden;
            box-shadow: 0 8px 25px rgba(0,0,0,0.15);
            border: 1px solid #333;
            animation: fadeIn 0.8s ease-out;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }

        .code-header {
            background: linear-gradient(90deg, #2c3e50, #34495e);
            color: white;
            padding: 12px 20px;
            font-weight: 700;
            font-size: 0.9rem;
            border-bottom: 1px solid #444;
        }

        pre {
            margin: 0 !important;
            background: #1e1e1e !important;
            border-radius: 0 !important;
        }

        code {
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace !important;
            font-size: 0.95rem !important;
            line-height: 1.6 !important;
            font-weight: 500 !important;
        }

        .line-numbers-rows {
            border-right: 1px solid #444 !important;
            padding-right: 10px !important;
            margin-right: 15px !important;
        }

        .complexity {
            background: linear-gradient(135deg, #fff8e1, #ffecb3);
            padding: 20px 25px;
            border-radius: 12px;
            border-left: 4px solid #f39c12;
            margin: 25px 0;
            font-weight: 700;
            box-shadow: 0 4px 15px rgba(243, 156, 18, 0.1);
        }

        .warning {
            background: linear-gradient(135deg, #fff3cd, #ffeaa7);
            padding: 20px 25px;
            border-radius: 12px;
            border-left: 4px solid #ffc107;
            margin: 25px 0;
            font-weight: 700;
            box-shadow: 0 4px 15px rgba(255, 193, 7, 0.1);
        }

        .warning::before {
            content: '‚ö†Ô∏è ';
            font-size: 1.2em;
        }

        .section {
            margin-bottom: 50px;
            padding: 35px;
            background: #fafbfc;
            border-radius: 15px;
            border: 1px solid #e1e8ed;
            animation: slideInUp 0.6s ease-out;
        }

        @keyframes slideInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .focus-problem {
            background: linear-gradient(135deg, #fff8e1, #ffecb3);
            padding: 25px;
            border-radius: 15px;
            margin: 30px 0;
            border: 2px solid #f39c12;
            text-align: center;
            font-weight: 700;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% {
                box-shadow: 0 0 0 0 rgba(243, 156, 18, 0.4);
            }
            70% {
                box-shadow: 0 0 0 10px rgba(243, 156, 18, 0);
            }
            100% {
                box-shadow: 0 0 0 0 rgba(243, 156, 18, 0);
            }
        }

        .highlight {
            background: linear-gradient(120deg, #ffeaa7 0%, #fab1a0 100%);
            padding: 3px 8px;
            border-radius: 6px;
            font-weight: 800;
        }

        .hover-effect {
            transition: all 0.3s ease;
        }

        .hover-effect:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 35px rgba(0,0,0,0.15);
        }

        .dp-comparison {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 25px;
            margin: 30px 0;
        }

        .approach-card {
            background: white;
            border-radius: 12px;
            padding: 25px;
            border-left: 4px solid #f39c12;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            transition: transform 0.3s ease;
        }

        .approach-card:hover {
            transform: translateY(-5px);
        }

        .approach-title {
            font-weight: 800;
            color: #f39c12;
            margin-bottom: 15px;
            font-size: 1.3rem;
        }

        .push-dp {
            border-left-color: #e74c3c;
        }

        .push-dp .approach-title {
            color: #e74c3c;
        }

        .pull-dp {
            border-left-color: #3498db;
        }

        .pull-dp .approach-title {
            color: #3498db;
        }

        .definition-box {
            background: linear-gradient(135deg, #e3f2fd, #bbdefb);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 4px solid #2196f3;
            font-weight: 700;
        }

        .definition-box::before {
            content: 'üìö Definition: ';
            font-weight: 800;
            color: #1976d2;
        }

        .algorithm-box {
            background: linear-gradient(135deg, #f3e5f5, #e1bee7);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 4px solid #9c27b0;
            font-weight: 700;
        }

        .algorithm-box::before {
            content: '‚ö° Key Insight: ';
            font-weight: 800;
            color: #7b1fa2;
        }

        .solution-header {
            color: #f39c12;
            font-weight: 800;
            border-bottom: 3px solid #f39c12;
            padding-bottom: 8px;
            display: inline-block;
            margin-bottom: 20px;
        }

        .math-display {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            margin: 25px 0;
            text-align: center;
            border: 2px solid #e9ecef;
            font-size: 1.2rem;
        }

        .brute-force-box {
            background: linear-gradient(135deg, #ffebee, #ffcdd2);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 4px solid #f44336;
            font-weight: 700;
        }

        .brute-force-box::before {
            content: 'üêå Brute Force: ';
            font-weight: 800;
            color: #c62828;
        }

        .dp-benefits-box {
            background: linear-gradient(135deg, #e8f5e8, #d4edda);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 4px solid #28a745;
            font-weight: 700;
        }

        .dp-benefits-box::before {
            content: 'üöÄ DP Benefits: ';
            font-weight: 800;
            color: #155724;
        }

        .transition-formula {
            background: linear-gradient(135deg, #f8f9fa, #e9ecef);
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            border-left: 4px solid #6c757d;
            font-weight: 700;
        }

        .transition-formula::before {
            content: 'üîÑ Transition: ';
            font-weight: 800;
            color: #495057;
        }

        .base-case-box {
            background: linear-gradient(135deg, #fff3e0, #ffe0b2);
            padding: 15px 20px;
            border-radius: 8px;
            margin: 15px 0;
            border-left: 3px solid #ff9800;
            font-weight: 600;
            font-size: 1rem;
        }

        .base-case-box::before {
            content: 'üéØ Base Case: ';
            font-weight: 800;
            color: #f57c00;
        }

        .classical-problems-box {
            background: linear-gradient(135deg, #f0f4f8, #ddd6fe);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 4px solid #8b5cf6;
            font-weight: 700;
        }

        .classical-problems-box::before {
            content: 'üìñ Classical Problems: ';
            font-weight: 800;
            color: #7c3aed;
        }

        .dp-steps {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin: 25px 0;
        }

        .step {
            background: white;
            border-radius: 8px;
            padding: 15px 20px;
            border-left: 4px solid #f39c12;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .step-number {
            font-weight: 800;
            color: #f39c12;
            margin-right: 10px;
        }

        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            margin: 25px 0;
            background: white;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }

        .comparison-table th, .comparison-table td {
            padding: 15px;
            text-align: left;
            font-weight: 700;
            border: 1px solid #e1e8ed;
        }

        .comparison-table th {
            background: linear-gradient(90deg, #f39c12, #e67e22);
            color: white;
            font-size: 1.1rem;
        }

        .comparison-table td {
            background: #f8f9fa;
            font-size: 1.05rem;
        }

        .optimization-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 30px 0;
        }

        .optimization-card {
            background: white;
            border-radius: 10px;
            padding: 20px;
            border-left: 4px solid #f39c12;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            transition: transform 0.3s ease;
        }

        .optimization-card:hover {
            transform: translateY(-3px);
        }

        .optimization-title {
            font-weight: 800;
            color: #f39c12;
            margin-bottom: 10px;
            font-size: 1.1rem;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Introduction to Dynamic Programming</h1>
        
        <div class="section hover-effect">
            <h2>What is Dynamic Programming?</h2>
            
            <p><span class="highlight">Dynamic Programming (DP)</span> is an important algorithmic technique in Competitive Programming from the gold division to competitions like the International Olympiad of Informatics. By breaking down the full task into sub-problems, DP avoids the redundant computations of brute force solutions.</p>

            <div class="definition-box">
                Dynamic Programming is an algorithmic paradigm that solves complex problems by breaking them down into simpler subproblems. It stores the results of subproblems to avoid computing the same results again.
            </div>

            <p>Although it is not too difficult to grasp the general ideas behind DP, the technique can be used in a diverse range of problems and is a must-know idea for competitors in the USACO Gold division.</p>

            <div class="algorithm-box">
                The key insight of DP is <strong>optimal substructure</strong> and <strong>overlapping subproblems</strong>. If a problem can be broken down into subproblems which are reused several times, DP can be applied.
            </div>

            <h3>Core Principles of Dynamic Programming</h3>
            <div class="dp-steps">
                <div class="step">
                    <span class="step-number">1.</span>
                    <strong>Optimal Substructure:</strong> An optimal solution can be constructed from optimal solutions of its subproblems
                </div>
                <div class="step">
                    <span class="step-number">2.</span>
                    <strong>Overlapping Subproblems:</strong> The same subproblems are solved multiple times in a naive recursive approach
                </div>
                <div class="step">
                    <span class="step-number">3.</span>
                    <strong>Memoization:</strong> Store results of subproblems to avoid redundant calculations
                </div>
                <div class="step">
                    <span class="step-number">4.</span>
                    <strong>Bottom-Up Construction:</strong> Build solutions incrementally from smaller to larger problems
                </div>
            </div>
        </div>

        <div class="section hover-effect">
            <h2>Example Problem: Frog 1</h2>
            
            <div class="focus-problem">
                <strong>üéØ Focus Problem:</strong> Frog 1 (AC - Easy)<br>
                Try your best to solve this problem before continuing!
            </div>

            <h3>Problem Statement</h3>
            <p>The problem asks us to compute the minimum total cost it takes for a frog to travel from stone 1 to stone $N$ (where $N \leq 10^5$) given that the frog can only jump a distance of one or two. The cost to travel between any two stones $i$ and $j$ is given by $|h_i - h_j|$, where $h_i$ represents the height of stone $i$.</p>

            <div class="brute-force-box">
                <strong>Time Complexity: $\mathcal{O}(2^N)$</strong><br><br>
                Since there are only two options, we can use recursion to compute what would happen if we jumped either 1 stone, or 2 stones. There are two possibilities, so recursively computing would require computing both a left and right subtree. Therefore, for every additional jump, each branch splits into two, which results in an exponential time complexity.
            </div>

            <p>However, this can be sped up with dynamic programming by keeping track of "optimal states" in order to avoid calculating states multiple times. For example, recursively calculating jumps of length 1,2,1 and 2,1,2 reuses the state of stone 3. Dynamic programming provides the mechanism to cache such states.</p>

            <div class="dp-benefits-box">
                <strong>Time Complexity: $\mathcal{O}(N)$</strong><br><br>
                DP reduces the exponential complexity to linear by storing and reusing computed results. Each state is computed exactly once.
            </div>

            <h3>DP Approaches</h3>
            <p>There are two main DP approaches:</p>

            <div class="dp-comparison">
                <div class="approach-card push-dp">
                    <div class="approach-title">Push DP</div>
                    <p>We update future states based on the current state. Starting from the current position, we "push" updates to all reachable future positions.</p>
                </div>
                <div class="approach-card pull-dp">
                    <div class="approach-title">Pull DP</div>
                    <p>We calculate the current state based on past states. For each position, we "pull" the best results from all positions that can reach it.</p>
                </div>
            </div>

            <p>We present both approaches below.</p>
        </div>

        <div class="section hover-effect">
            <h2>Push DP Approach</h2>
            
            <p>There are only two options: jumping once, or jumping twice. Define $\texttt{dp}[i]$ as the minimum cost to reach stone $i$. Then, our transitions are as follows:</p>

            <div class="transition-formula">
                <strong>Jump one stone:</strong> incurring a cost of $|\text{height}_i - \text{height}_{i+1}|$
                <div class="math-display">
                    $$\texttt{dp}[i + 1] = \min(\texttt{dp}[i + 1], \texttt{dp}[i] + |\text{height}_i - \text{height}_{i + 1}|)$$
                </div>
            </div>

            <div class="transition-formula">
                <strong>Jump two stones:</strong> incurring a cost of $|\text{height}_i - \text{height}_{i + 2}|$
                <div class="math-display">
                    $$\texttt{dp}[i + 2] = \min(\texttt{dp}[i + 2], \texttt{dp}[i] + |\text{height}_i - \text{height}_{i + 2}|)$$
                </div>
            </div>

            <div class="base-case-box">
                We start with $\texttt{dp}[0] = 0$, since the frog is already on that square, and proceed to calculate $\texttt{dp}[1], \texttt{dp}[2], \ldots \texttt{dp}[N - 1]$.
            </div>

            <h3 class="solution-header">Push DP Implementation</h3>

            <div class="code-container">
                <div class="code-header">C++ - Push DP Solution</div>
                <pre class="line-numbers"><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;

int main() {
    int N;
    cin &gt;&gt; N;
    vector&lt;int&gt; height(N);
    for (int i = 0; i &lt; N; i++) { 
        cin &gt;&gt; height[i]; 
    }
    
    // dp[N] is the minimum cost to get to the Nth stone
    vector&lt;int&gt; dp(N, INT_MAX);
    
    // dp[0] = 0 is our base case since we're already at the first stone
    dp[0] = 0;
    
    // for each state, calculate the states it leads to
    for (int i = 0; i &lt; N - 1; i++) {
        // jump one stone
        dp[i + 1] = min(dp[i + 1], dp[i] + abs(height[i] - height[i + 1]));
        
        // jump two stones
        if (i + 2 &lt; N) {
            dp[i + 2] = min(dp[i + 2], dp[i] + abs(height[i] - height[i + 2]));
        }
    }
    
    cout &lt;&lt; dp[N - 1] &lt;&lt; endl;
    return 0;
}</code></pre>
            </div>

            <div class="algorithm-box">
                <strong>Push DP Logic:</strong> For each stone, we compute the minimum cost to reach all stones we can jump to from the current stone. We "push" our current minimum cost forward to future states.
            </div>
        </div>

        <div class="section hover-effect">
            <h2>Pull DP Approach</h2>
            
            <p>There are two ways to get to stone $i$: from stone $i - 1$ and stone $i - 2$.</p>

            <div class="transition-formula">
                <strong>Jump from stone $i - 1$:</strong> incurring a cost of $|\text{height}_i - \text{height}_{i-1}|$
                <div class="math-display">
                    $$\texttt{dp}[i] = \min(\texttt{dp}[i], \texttt{dp}[i - 1] + |\text{height}_i - \text{height}_{i - 1}|)$$
                </div>
            </div>

            <div class="transition-formula">
                <strong>Jump from stone $i - 2$:</strong> incurring a cost of $|\text{height}_i - \text{height}_{i - 2}|$
                <div class="math-display">
                    $$\texttt{dp}[i] = \min(\texttt{dp}[i], \texttt{dp}[i - 2] + |\text{height}_i - \text{height}_{i - 2}|)$$
                </div>
            </div>

            <div class="base-case-box">
                We start with $\texttt{dp}[0] = 0$, since the frog is already on that square, and proceed to calculate $\texttt{dp}[1], \texttt{dp}[2], \ldots \texttt{dp}[N - 1]$.
            </div>

            <h3 class="solution-header">Pull DP Implementation</h3>

            <div class="code-container">
                <div class="code-header">C++ - Pull DP Solution</div>
                <pre class="line-numbers"><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;

int main() {
    int N;
    cin &gt;&gt; N;
    vector&lt;int&gt; height(N);
    for (int i = 0; i &lt; N; i++) { 
        cin &gt;&gt; height[i]; 
    }
    
    // dp[N] is the minimum cost to get to the Nth stone
    vector&lt;int&gt; dp(N, INT_MAX);
    
    // dp[0] = 0 is our base case since we're already at the first stone
    dp[0] = 0;
    
    // for each state, process the states that lead to it
    for (int i = 1; i &lt; N; i++) {
        // jump from one stone back
        if (i - 1 &gt;= 0) {
            dp[i] = min(dp[i], dp[i - 1] + abs(height[i] - height[i - 1]));
        }
        
        // jump from two stones back
        if (i - 2 &gt;= 0) {
            dp[i] = min(dp[i], dp[i - 2] + abs(height[i] - height[i - 2]));
        }
    }
    
    cout &lt;&lt; dp[N - 1] &lt;&lt; endl;
    return 0;
}</code></pre>
            </div>

            <div class="algorithm-box">
                <strong>Pull DP Logic:</strong> For each stone, we compute the minimum cost to reach it by considering all stones that can jump to the current stone. We "pull" the best costs from previous states.
            </div>
        </div>

        <div class="section hover-effect">
            <h2>Comparison: Push vs Pull DP</h2>

            <table class="comparison-table">
                <tr>
                    <th>Aspect</th>
                    <th>Push DP</th>
                    <th>Pull DP</th>
                </tr>
                <tr>
                    <td><strong>Direction</strong></td>
                    <td>Forward: current ‚Üí future</td>
                    <td>Backward: past ‚Üí current</td>
                </tr>
                <tr>
                    <td><strong>Mindset</strong></td>
                    <td>"Where can I go from here?"</td>
                    <td>"How can I get here?"</td>
                </tr>
                <tr>
                    <td><strong>Loop Order</strong></td>
                    <td>Process states, update future states</td>
                    <td>For each state, check previous states</td>
                </tr>
                <tr>
                    <td><strong>Implementation</strong></td>
                    <td>Update dp[i+1], dp[i+2] from dp[i]</td>
                    <td>Update dp[i] from dp[i-1], dp[i-2]</td>
                </tr>
                <tr>
                    <td><strong>Boundary Checks</strong></td>
                    <td>Check if i+k &lt; N</td>
                    <td>Check if i-k ‚â• 0</td>
                </tr>
                <tr>
                    <td><strong>Use Case</strong></td>
                    <td>When transitions are simple</td>
                    <td>More intuitive for most problems</td>
                </tr>
            </table>

            <div class="complexity">
                <strong>Both approaches have the same time complexity: $\mathcal{O}(N)$</strong><br>
                The choice between push and pull DP often depends on personal preference and the specific problem structure. Pull DP is generally more intuitive for beginners.
            </div>
        </div>

        <div class="section hover-effect">
            <h2>Classical Problems</h2>

            <div class="classical-problems-box">
                The next few modules provide examples of some classical problems: Dynamic Programming problems which are well known. However, classical doesn't necessarily mean common. Since so many competitors know about these problems, problemsetters rarely set direct applications of them.
            </div>

            <div class="optimization-grid">
                <div class="optimization-card">
                    <div class="optimization-title">Fibonacci Numbers</div>
                    <p>The classic example of overlapping subproblems. Computing F(n) = F(n-1) + F(n-2) efficiently using memoization.</p>
                </div>
                <div class="optimization-card">
                    <div class="optimization-title">Longest Increasing Subsequence</div>
                    <p>Find the length of the longest subsequence where elements are in increasing order. Classic DP with O(n¬≤) and O(n log n) solutions.</p>
                </div>
                <div class="optimization-card">
                    <div class="optimization-title">0/1 Knapsack</div>
                    <p>Select items with maximum value while staying within weight limit. Foundation for many optimization problems.</p>
                </div>
                <div class="optimization-card">
                    <div class="optimization-title">Edit Distance</div>
                    <p>Minimum operations to transform one string into another. Used in spell checkers and DNA sequence analysis.</p>
                </div>
                <div class="optimization-card">
                    <div class="optimization-title">Coin Change</div>
                    <p>Find minimum coins needed to make a target amount. Demonstrates unbounded knapsack variation.</p>
                </div>
                <div class="optimization-card">
                    <div class="optimization-title">Maximum Subarray Sum</div>
                    <p>Kadane's algorithm for finding contiguous subarray with maximum sum. Linear time DP solution.</p>
                </div>
            </div>

            <div class="warning">
                <strong>Important Note:</strong> While these problems are fundamental for learning DP concepts, modern competitive programming problems usually require combining these basic patterns or applying DP to more complex scenarios.
            </div>
        </div>

        <div class="section hover-effect">
            <h2>General DP Problem-Solving Strategy</h2>

            <div class="dp-steps">
                <div class="step">
                    <span class="step-number">1.</span>
                    <strong>Identify the Problem Structure:</strong> Look for optimal substructure and overlapping subproblems
                </div>
                <div class="step">
                    <span class="step-number">2.</span>
                    <strong>Define the State:</strong> What information do you need to represent a subproblem?
                </div>
                <div class="step">
                    <span class="step-number">3.</span>
                    <strong>State Transition:</strong> How do you compute a state from previously computed states?
                </div>
                <div class="step">
                    <span class="step-number">4.</span>
                    <strong>Base Cases:</strong> What are the simplest subproblems you can solve directly?
                </div>
                <div class="step">
                    <span class="step-number">5.</span>
                    <strong>Order of Computation:</strong> In what order should you compute the states?
                </div>
                <div class="step">
                    <span class="step-number">6.</span>
                    <strong>Final Answer:</strong> Which state(s) contain the answer to the original problem?
                </div>
            </div>

            <div class="algorithm-box">
                <strong>Key Questions to Ask:</strong><br>
                ‚Ä¢ Can I break this problem into smaller, similar subproblems?<br>
                ‚Ä¢ Will I need to solve the same subproblems multiple times?<br>
                ‚Ä¢ What's the minimum information needed to represent a state?<br>
                ‚Ä¢ How do the subproblems relate to each other?
            </div>
        </div>

        <div class="section hover-effect">
            <h2>DP Optimization Techniques</h2>

            <div class="optimization-grid">
                <div class="optimization-card">
                    <div class="optimization-title">Space Optimization</div>
                    <p>Reduce space complexity by keeping only necessary previous states. Often can reduce from O(n¬≤) to O(n) space.</p>
                </div>
                <div class="optimization-card">
                    <div class="optimization-title">Rolling Array</div>
                    <p>Use modular arithmetic to reuse array space when only recent states are needed for transitions.</p>
                </div>
                <div class="optimization-card">
                    <div class="optimization-title">State Compression</div>
                    <p>Use bitmasks or other techniques to represent multiple pieces of information in a single state.</p>
                </div>
                <div class="optimization-card">
                    <div class="optimization-title">Monotonic Queue/Stack</div>
                    <p>Optimize range minimum/maximum queries in DP transitions using monotonic data structures.</p>
                </div>
                <div class="optimization-card">
                    <div class="optimization-title">Convex Hull Trick</div>
                    <p>Optimize DP with linear functions using convex hull to reduce complexity from O(n¬≤) to O(n log n).</p>
                </div>
                <div class="optimization-card">
                    <div class="optimization-title">Divide and Conquer DP</div>
                    <p>When DP satisfies certain properties, use divide and conquer to optimize from O(n¬≤) to O(n log n).</p>
                </div>
            </div>

            <div class="complexity">
                <strong>When to Use Optimizations:</strong><br>
                ‚Ä¢ Basic DP solution exceeds time/memory limits<br>
                ‚Ä¢ Pattern recognition of optimization opportunities<br>
                ‚Ä¢ Advanced competitive programming problems<br>
                ‚Ä¢ Problems with large constraints requiring sub-quadratic solutions
            </div>
        </div>

        <div class="section hover-effect">
            <h2>Common DP Patterns</h2>

            <table class="comparison-table">
                <tr>
                    <th>Pattern</th>
                    <th>Description</th>
                    <th>Example Problems</th>
                    <th>Time Complexity</th>
                </tr>
                <tr>
                    <td><strong>Linear DP</strong></td>
                    <td>States form a sequence, each depends on previous states</td>
                    <td>Fibonacci, House Robber, Climbing Stairs</td>
                    <td>O(n)</td>
                </tr>
                <tr>
                    <td><strong>Grid DP</strong></td>
                    <td>States arranged in 2D grid, transitions between adjacent cells</td>
                    <td>Unique Paths, Minimum Path Sum</td>
                    <td>O(nm)</td>
                </tr>
                <tr>
                    <td><strong>Interval DP</strong></td>
                    <td>States represent intervals, merge smaller intervals to larger ones</td>
                    <td>Matrix Chain Multiplication, Palindrome Partitioning</td>
                    <td>O(n¬≥)</td>
                </tr>
                <tr>
                    <td><strong>Tree DP</strong></td>
                    <td>States on tree nodes, combine child states to parent state</td>
                    <td>Tree Diameter, House Robber III</td>
                    <td>O(n)</td>
                </tr>
                <tr>
                    <td><strong>Subset DP</strong></td>
                    <td>States represent subsets, often using bitmasks</td>
                    <td>Traveling Salesman, Assignment Problem</td>
                    <td>O(2‚Åø √ó n)</td>
                </tr>
                <tr>
                    <td><strong>String DP</strong></td>
                    <td>States on string positions or substring ranges</td>
                    <td>Edit Distance, Longest Common Subsequence</td>
                    <td>O(nm)</td>
                </tr>
            </table>

            <div class="algorithm-box">
                <strong>Pattern Recognition Tips:</strong><br>
                ‚Ä¢ Look at the problem constraints to guess the expected complexity<br>
                ‚Ä¢ Identify what makes subproblems distinct<br>
                ‚Ä¢ Consider what information must be tracked in the state<br>
                ‚Ä¢ Think about the natural order of solving subproblems
            </div>
        </div>

        <div class="section hover-effect">
            <h2>Tips for DP Mastery</h2>

            <div class="optimization-grid">
                <div class="optimization-card">
                    <div class="optimization-title">Start Simple</div>
                    <p>Begin with the naive recursive solution, then add memoization. This helps identify the state space and transitions clearly.</p>
                </div>
                <div class="optimization-card">
                    <div class="optimization-title">Practice State Design</div>
                    <p>The hardest part of DP is often defining the right state. Practice identifying what information is truly necessary.</p>
                </div>
                <div class="optimization-card">
                    <div class="optimization-title">Verify with Examples</div>
                    <p>Always trace through your DP solution with small examples to ensure correctness before implementing.</p>
                </div>
                <div class="optimization-card">
                    <div class="optimization-title">Watch for Edge Cases</div>
                    <p>Pay special attention to boundary conditions, empty inputs, and base cases in your DP solutions.</p>
                </div>
                <div class="optimization-card">
                    <div class="optimization-title">Optimize Gradually</div>
                    <p>Get the basic DP working first, then apply optimizations if needed. Don't prematurely optimize.</p>
                </div>
                <div class="optimization-card">
                    <div class="optimization-title">Learn from Solutions</div>
                    <p>Study editorial solutions to see different state definitions and transition approaches for the same problem.</p>
                </div>
            </div>

            <div class="dp-benefits-box">
                <strong>Building DP Intuition:</strong> The key to mastering DP is recognizing patterns and developing intuition for state design. This comes through extensive practice and exposure to diverse problem types.
            </div>

            <div class="warning">
                <strong>Common Mistakes to Avoid:</strong><br>
                ‚Ä¢ Forgetting to handle base cases properly<br>
                ‚Ä¢ Using too much information in state definition<br>
                ‚Ä¢ Incorrect order of state computation<br>
                ‚Ä¢ Not considering all possible transitions<br>
                ‚Ä¢ Overlooking space optimization opportunities
            </div>
        </div>

        <div class="section hover-effect">
            <h2>Summary and Next Steps</h2>

            <div class="definition-box">
                Dynamic Programming is a powerful technique that transforms exponential brute force solutions into polynomial time algorithms by caching results of overlapping subproblems.
            </div>

            <div class="dp-comparison">
                <div class="approach-card">
                    <div class="approach-title">What You've Learned</div>
                    <ul style="padding-left: 20px;">
                        <li>Core DP principles and concepts</li>
                        <li>Push vs Pull DP approaches</li>
                        <li>Problem-solving methodology</li>
                        <li>Common patterns and optimizations</li>
                        <li>Implementation best practices</li>
                    </ul>
                </div>
                <div class="approach-card">
                    <div class="approach-title">Next Steps</div>
                    <ul style="padding-left: 20px;">
                        <li>Practice classical DP problems</li>
                        <li>Learn specific DP patterns deeply</li>
                        <li>Study optimization techniques</li>
                        <li>Solve contest problems</li>
                        <li>Analyze editorial solutions</li>
                    </ul>
                </div>
            </div>

            <div class="focus-problem">
                <strong>üéØ Challenge:</strong><br>
                Now that you understand DP fundamentals, try solving problems like "Frog 2," "Vacation," or "Grid 1" to practice different DP patterns and build your intuition!
            </div>

            <div class="complexity">
                <strong>Remember:</strong> DP is as much about problem recognition as it is about implementation. The more problems you solve, the better you'll become at identifying when and how to apply DP techniques effectively.
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
</body>
</html>