<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Euler Tour Technique</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet">
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']]
            }
        };
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-weight: 600;
            line-height: 1.7;
            color: #2c3e50;
            background: white;
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 40px 20px;
            animation: fadeInUp 0.8s ease-out;
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        h1 {
            font-size: 3.5rem;
            font-weight: 800;
            color: #2c3e50;
            text-align: center;
            margin-bottom: 50px;
            position: relative;
            animation: slideInDown 1s ease-out;
        }

        @keyframes slideInDown {
            from {
                opacity: 0;
                transform: translateY(-50px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        h1::after {
            content: '';
            display: block;
            width: 300px;
            height: 4px;
            background: linear-gradient(90deg, #8e44ad, #9b59b6);
            margin: 20px auto;
            border-radius: 2px;
            animation: expandLine 1.2s ease-out 0.5s both;
        }

        @keyframes expandLine {
            from {
                width: 0;
            }
            to {
                width: 300px;
            }
        }

        h2 {
            font-size: 2.4rem;
            font-weight: 700;
            color: #34495e;
            margin-top: 60px;
            margin-bottom: 25px;
            border-left: 5px solid #8e44ad;
            padding-left: 20px;
            animation: slideInLeft 0.6s ease-out;
        }

        @keyframes slideInLeft {
            from {
                opacity: 0;
                transform: translateX(-30px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        h3 {
            font-size: 1.9rem;
            font-weight: 700;
            color: #2c3e50;
            margin-top: 40px;
            margin-bottom: 20px;
            position: relative;
        }

        h3::before {
            content: 'üß†';
            margin-right: 10px;
            font-size: 0.9em;
        }

        p {
            font-size: 1.15rem;
            font-weight: 600;
            margin-bottom: 25px;
            text-align: justify;
            line-height: 1.8;
        }

        ul {
            margin: 25px 0;
            padding-left: 0;
        }

        li {
            font-size: 1.15rem;
            font-weight: 600;
            margin-bottom: 15px;
            line-height: 1.8;
            list-style: none;
            position: relative;
            padding-left: 30px;
        }

        li::before {
            content: 'üí°';
            position: absolute;
            left: 0;
            top: 0;
        }

        .code-container {
            background: #1e1e1e;
            border-radius: 12px;
            margin: 30px 0;
            overflow: hidden;
            box-shadow: 0 8px 25px rgba(0,0,0,0.15);
            border: 1px solid #333;
            animation: fadeIn 0.8s ease-out;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }

        .code-header {
            background: linear-gradient(90deg, #2c3e50, #34495e);
            color: white;
            padding: 12px 20px;
            font-weight: 700;
            font-size: 0.9rem;
            border-bottom: 1px solid #444;
        }

        pre {
            margin: 0 !important;
            background: #1e1e1e !important;
            border-radius: 0 !important;
        }

        code {
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace !important;
            font-size: 0.95rem !important;
            line-height: 1.6 !important;
            font-weight: 500 !important;
        }

        .line-numbers-rows {
            border-right: 1px solid #444 !important;
            padding-right: 10px !important;
            margin-right: 15px !important;
        }

        .complexity {
            background: linear-gradient(135deg, #f3e5f5, #e1bee7);
            padding: 20px 25px;
            border-radius: 12px;
            border-left: 4px solid #8e44ad;
            margin: 25px 0;
            font-weight: 700;
            box-shadow: 0 4px 15px rgba(142, 68, 173, 0.1);
        }

        .warning {
            background: linear-gradient(135deg, #fff3cd, #ffeaa7);
            padding: 20px 25px;
            border-radius: 12px;
            border-left: 4px solid #ffc107;
            margin: 25px 0;
            font-weight: 700;
            box-shadow: 0 4px 15px rgba(255, 193, 7, 0.1);
        }

        .warning::before {
            content: '‚ö†Ô∏è ';
            font-size: 1.2em;
        }

        .section {
            margin-bottom: 50px;
            padding: 35px;
            background: #fafbfc;
            border-radius: 15px;
            border: 1px solid #e1e8ed;
            animation: slideInUp 0.6s ease-out;
        }

        @keyframes slideInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .focus-problem {
            background: linear-gradient(135deg, #f3e5f5, #e1bee7);
            padding: 25px;
            border-radius: 15px;
            margin: 30px 0;
            border: 2px solid #8e44ad;
            text-align: center;
            font-weight: 700;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% {
                box-shadow: 0 0 0 0 rgba(142, 68, 173, 0.4);
            }
            70% {
                box-shadow: 0 0 0 10px rgba(142, 68, 173, 0);
            }
            100% {
                box-shadow: 0 0 0 0 rgba(142, 68, 173, 0);
            }
        }

        .highlight {
            background: linear-gradient(120deg, #e1bee7 0%, #74b9ff 100%);
            padding: 3px 8px;
            border-radius: 6px;
            font-weight: 800;
        }

        .hover-effect {
            transition: all 0.3s ease;
        }

        .hover-effect:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 35px rgba(0,0,0,0.15);
        }

        .definition-box {
            background: linear-gradient(135deg, #f3e5f5, #e1bee7);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 4px solid #9c27b0;
            font-weight: 700;
        }

        .definition-box::before {
            content: 'üìö Definition: ';
            font-weight: 800;
            color: #7b1fa2;
        }

        .algorithm-box {
            background: linear-gradient(135deg, #e8f5e8, #d4edda);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 4px solid #28a745;
            font-weight: 700;
        }

        .algorithm-box::before {
            content: '‚ö° Key Insight: ';
            font-weight: 800;
            color: #155724;
        }

        .solution-header {
            color: #8e44ad;
            font-weight: 800;
            border-bottom: 3px solid #8e44ad;
            padding-bottom: 8px;
            display: inline-block;
            margin-bottom: 20px;
        }

        .math-display {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            margin: 25px 0;
            text-align: center;
            border: 2px solid #e9ecef;
            font-size: 1.2rem;
        }

        .euler-tour-box {
            background: linear-gradient(135deg, #f3e5f5, #e1bee7);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 4px solid #9c27b0;
            font-weight: 700;
        }

        .euler-tour-box::before {
            content: 'üîÑ Euler Tour: ';
            font-weight: 800;
            color: #7b1fa2;
        }

        .step-by-step {
            background: linear-gradient(135deg, #fef7ff, #f3e8ff);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 4px solid #a855f7;
            font-weight: 700;
        }

        .step-by-step::before {
            content: 'üìù Algorithm Steps: ';
            font-weight: 800;
            color: #7c2d12;
        }

        .optimization-box {
            background: linear-gradient(135deg, #fef3c7, #fbbf24);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 4px solid #f59e0b;
            font-weight: 700;
        }

        .optimization-box::before {
            content: '‚ö° Optimization: ';
            font-weight: 800;
            color: #92400e;
        }

        .tour-visualization {
            background: #f8f9fa;
            padding: 30px;
            border-radius: 12px;
            margin: 30px 0;
            text-align: center;
            border: 2px solid #e9ecef;
        }

        .applications-box {
            background: linear-gradient(135deg, #f0f4f8, #ddd6fe);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 4px solid #8b5cf6;
            font-weight: 700;
        }

        .applications-box::before {
            content: 'üìñ Applications: ';
            font-weight: 800;
            color: #7c3aed;
        }

        .problem-patterns {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 20px;
            margin: 30px 0;
        }

        .pattern-card {
            background: white;
            border-radius: 12px;
            padding: 25px;
            border-left: 4px solid #8e44ad;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            transition: transform 0.3s ease;
        }

        .pattern-card:hover {
            transform: translateY(-5px);
        }

        .pattern-card:nth-child(1) {
            border-left-color: #e74c3c;
        }

        .pattern-card:nth-child(2) {
            border-left-color: #3498db;
        }

        .pattern-card:nth-child(3) {
            border-left-color: #2ecc71;
        }

        .pattern-title {
            font-weight: 800;
            color: #8e44ad;
            margin-bottom: 15px;
            font-size: 1.3rem;
        }

        .pattern-card:nth-child(1) .pattern-title {
            color: #e74c3c;
        }

        .pattern-card:nth-child(2) .pattern-title {
            color: #3498db;
        }

        .pattern-card:nth-child(3) .pattern-title {
            color: #2ecc71;
        }

        .walkthrough-table {
            margin: 20px auto;
            border-collapse: collapse;
            font-family: 'Courier New', monospace;
            font-weight: 700;
            font-size: 1rem;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }

        .walkthrough-table td, .walkthrough-table th {
            padding: 12px 15px;
            border: 2px solid #34495e;
            text-align: center;
            background: white;
        }

        .walkthrough-table th {
            background: #8e44ad;
            color: white;
            font-weight: 800;
        }

        .walkthrough-table .header-row {
            background: #f8f9fa;
            font-weight: 800;
        }

        .lca-box {
            background: linear-gradient(135deg, #e3f2fd, #bbdefb);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 4px solid #2196f3;
            font-weight: 700;
        }

        .lca-box::before {
            content: 'üå≤ LCA Technique: ';
            font-weight: 800;
            color: #1976d2;
        }

        .sparse-table-box {
            background: linear-gradient(135deg, #fff3e0, #ffe0b2);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 4px solid #ff9800;
            font-weight: 700;
        }

        .sparse-table-box::before {
            content: 'üìä Sparse Table: ';
            font-weight: 800;
            color: #f57c00;
        }

        .range-query-box {
            background: linear-gradient(135deg, #e0f2fe, #b3e5fc);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 4px solid #0288d1;
            font-weight: 700;
        }

        .range-query-box::before {
            content: 'üîç Range Queries: ';
            font-weight: 800;
            color: #01579b;
        }

        .implementation-box {
            background: linear-gradient(135deg, #ecfdf5, #d1fae5);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 4px solid #10b981;
            font-weight: 700;
        }

        .implementation-box::before {
            content: 'üõ†Ô∏è Implementation: ';
            font-weight: 800;
            color: #047857;
        }

        .subtree-queries-box {
            background: linear-gradient(135deg, #fef7ff, #f3e8ff);
            padding: 25px;
            border-radius: 12px;
            margin: 25px 0;
            border-left: 4px solid #a855f7;
            font-weight: 700;
        }

        .subtree-queries-box::before {
            content: 'üåø Subtree Queries: ';
            font-weight: 800;
            color: #7c3aed;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Euler Tour Technique</h1>
        
        <div class="section hover-effect">
            <h2>Introduction to Euler Tour Technique</h2>
            
            <p>The <span class="highlight">Euler Tour Technique</span> is a powerful method for converting tree problems into array problems. If we can preprocess a rooted tree such that every subtree corresponds to a contiguous range on an array, we can do updates and range queries on it!</p>

            <div class="focus-problem">
                <strong>üéØ Focus Problem:</strong> Subtree Queries<br>
                Try your best to solve this problem before continuing!
            </div>

            <div class="definition-box">
                The Euler Tour Technique transforms a tree into a linear sequence by performing a modified DFS traversal. Each node gets two timestamps: start time (when first visited) and end time (when we finish processing its subtree).
            </div>

            <div class="euler-tour-box">
                <strong>Core Concept:</strong> By flattening the tree structure into an array using DFS timestamps, we transform complex tree operations into simpler array range operations. This enables efficient subtree queries and updates using standard data structures.
            </div>

            <div class="applications-box">
                <strong>Key Applications:</strong><br>
                ‚Ä¢ <strong>Subtree Queries:</strong> Sum, minimum, maximum over all nodes in a subtree<br>
                ‚Ä¢ <strong>Subtree Updates:</strong> Add/multiply values to all nodes in a subtree<br>
                ‚Ä¢ <strong>LCA Queries:</strong> Lowest Common Ancestor using RMQ techniques<br>
                ‚Ä¢ <strong>Tree DP:</strong> Converting tree DP to array-based computations<br>
                ‚Ä¢ <strong>Path Queries:</strong> Combined with other techniques for path operations
            </div>

            <div class="algorithm-box">
                <strong>Time Complexity Benefits:</strong> The Euler Tour reduces tree problems from potentially O(n) per operation to O(log n) per operation by leveraging efficient data structures like segment trees, Fenwick trees, and sparse tables.
            </div>
        </div>

        <div class="section hover-effect">
            <h2>Understanding the Tour Process</h2>

            <p>Let's use the below graph for a quick demo of the technique. Here's the code we're going to use to perform a Euler Tour on the graph. Notice that it follows the same general structure as a normal depth-first search. It's just that in this algorithm, we're keeping a few auxiliary variables we're going to use later on.</p>

            <div class="implementation-box">
                <strong>Basic Implementation Strategy:</strong> We maintain two arrays - start[] and end[] - that record when we enter and exit each node during DFS. The key insight is that all nodes in a subtree will have timestamps between the start and end times of the root of that subtree.
            </div>

            <div class="code-container">
                <div class="code-header">C++ - Basic Euler Tour Implementation</div>
                <pre class="line-numbers"><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;

using std::vector;

// The graph represented as an adjacency list (0-indexed)
vector&lt;vector&lt;int&gt;&gt; neighbors{{1, 2}, {0}, {0, 3, 4}, {2}, {2}};
vector&lt;int&gt; start(neighbors.size());
vector&lt;int&gt; end(neighbors.size());
int timer = 0;

void euler_tour(int at, int prev) {
    start[at] = timer++;
    for (int n : neighbors[at]) {
        if (n != prev) { 
            euler_tour(n, at); 
        }
    }
    end[at] = timer;
}</code></pre>
            </div>

            <div class="step-by-step">
                <strong>Algorithm Breakdown:</strong><br>
                <strong>1.</strong> Initialize timer to 0 and start DFS from root<br>
                <strong>2.</strong> When entering a node, record start[node] = timer++<br>
                <strong>3.</strong> Recursively visit all children (excluding parent)<br>
                <strong>4.</strong> When leaving a node, record end[node] = timer<br>
                <strong>5.</strong> The range [start[node], end[node]] contains the entire subtree
            </div>

            <h3>Tour Walkthrough</h3>

            <p>Before the tour, our $\texttt{start}$ and $\texttt{end}$ arrays are initialized with zeros. In this visualization, the first row represents the node indices, the second row represents $\texttt{start}$, and the third represents $\texttt{end}$.</p>

            <div class="tour-visualization">
                <strong>Step-by-Step Tour Execution</strong>
                
                <p><strong>Initial State (Timer = 0):</strong></p>
                <table class="walkthrough-table">
                    <tr class="header-row">
                        <td><strong>Node Index</strong></td>
                        <td>1</td>
                        <td>2</td>
                        <td>3</td>
                        <td>4</td>
                        <td>5</td>
                    </tr>
                    <tr>
                        <td class="header-row"><strong>start</strong></td>
                        <td>0</td>
                        <td>0</td>
                        <td>0</td>
                        <td>0</td>
                        <td>0</td>
                    </tr>
                    <tr>
                        <td class="header-row"><strong>end</strong></td>
                        <td>0</td>
                        <td>0</td>
                        <td>0</td>
                        <td>0</td>
                        <td>0</td>
                    </tr>
                </table>

                <p><strong>After Processing Node 2 (Timer = 2):</strong></p>
                <table class="walkthrough-table">
                    <tr class="header-row">
                        <td><strong>Node Index</strong></td>
                        <td>1</td>
                        <td>2</td>
                        <td>3</td>
                        <td>4</td>
                        <td>5</td>
                    </tr>
                    <tr>
                        <td class="header-row"><strong>start</strong></td>
                        <td>0</td>
                        <td>1</td>
                        <td>0</td>
                        <td>0</td>
                        <td>0</td>
                    </tr>
                    <tr>
                        <td class="header-row"><strong>end</strong></td>
                        <td>0</td>
                        <td>2</td>
                        <td>0</td>
                        <td>0</td>
                        <td>0</td>
                    </tr>
                </table>

                <p><strong>Final State (Timer = 5):</strong></p>
                <table class="walkthrough-table">
                    <tr class="header-row">
                        <td><strong>Node Index</strong></td>
                        <td>1</td>
                        <td>2</td>
                        <td>3</td>
                        <td>4</td>
                        <td>5</td>
                    </tr>
                    <tr>
                        <td class="header-row"><strong>start</strong></td>
                        <td>0</td>
                        <td>1</td>
                        <td>2</td>
                        <td>3</td>
                        <td>4</td>
                    </tr>
                    <tr>
                        <td class="header-row"><strong>end</strong></td>
                        <td>5</td>
                        <td>2</td>
                        <td>5</td>
                        <td>4</td>
                        <td>5</td>
                    </tr>
                </table>
            </div>

            <div class="algorithm-box">
                <strong>Key Observation:</strong> Notice that after running DFS, each range [start[i], end[i]] contains all ranges [start[j], end[j]] for each j in the subtree of i. Also, end[i] - start[i] is equal to the subtree size of i.
            </div>

            <div class="subtree-queries-box">
                <strong>Subtree Property:</strong> For any node i, all nodes in its subtree have start times in the range [start[i], end[i]-1]. This property enables efficient subtree operations using range-based data structures.
            </div>
        </div>

        <div class="section hover-effect">
            <h2>Subtree Queries Implementation</h2>

            <p>Now we can solve the classic subtree queries problem using our Euler Tour technique combined with a Binary Indexed Tree (Fenwick Tree) for efficient range sum queries and point updates.</p>

            <div class="range-query-box">
                <strong>Range Query Strategy:</strong> After flattening the tree, subtree queries become range queries on the flattened array. We can use any range query data structure (BIT, Segment Tree, etc.) to efficiently answer these queries.
            </div>

            <h3 class="solution-header">Complete Subtree Queries Solution</h3>

            <div class="code-container">
                <div class="code-header">C++ - Subtree Queries with BIT</div>
                <pre class="line-numbers"><code class="language-cpp">#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

using std::cout;
using std::endl;
using std::vector;

// Binary Indexed Tree implementation
template &lt;class T&gt; class BIT {
private:
    vector&lt;T&gt; tree;
    int n;

public:
    BIT(int n) : n(n), tree(n + 1, 0) {}

    void update(int idx, T val) {
        for (++idx; idx &lt;= n; idx += idx &amp; -idx) {
            tree[idx] += val;
        }
    }

    void set(int idx, T val) {
        update(idx, val - query(idx, idx));
    }

    T query(int idx) {
        T sum = 0;
        for (++idx; idx &gt; 0; idx -= idx &amp; -idx) {
            sum += tree[idx];
        }
        return sum;
    }

    T query(int l, int r) {
        return query(r) - (l == 0 ? 0 : query(l - 1));
    }
};

vector&lt;vector&lt;int&gt;&gt; neighbors;
vector&lt;int&gt; start;
vector&lt;int&gt; end;
int timer = 0;

void euler_tour(int at, int prev) {
    start[at] = timer++;
    for (int n : neighbors[at]) {
        if (n != prev) { 
            euler_tour(n, at); 
        }
    }
    end[at] = timer;
}

int main() {
    int node_num;
    int query_num;
    std::cin &gt;&gt; node_num &gt;&gt; query_num;

    vector&lt;int&gt; vals(node_num);
    for (int &amp;v : vals) { 
        std::cin &gt;&gt; v; 
    }

    neighbors.resize(node_num);
    for (int e = 0; e &lt; node_num - 1; e++) {
        int n1, n2;
        std::cin &gt;&gt; n1 &gt;&gt; n2;
        neighbors[--n1].push_back(--n2);
        neighbors[n2].push_back(n1);
    }

    start.resize(node_num);
    end.resize(node_num);
    euler_tour(0, -1);

    BIT&lt;long long&gt; bit(node_num);
    for (int i = 0; i &lt; node_num; i++) { 
        bit.set(start[i], vals[i]); 
    }
    
    for (int q = 0; q &lt; query_num; q++) {
        int type;
        std::cin &gt;&gt; type;
        if (type == 1) {
            int node, val;
            std::cin &gt;&gt; node &gt;&gt; val;
            bit.set(start[--node], val);
        } else if (type == 2) {
            int node;
            std::cin &gt;&gt; node;
            --node;
            long long result = bit.query(start[node], end[node] - 1);
            cout &lt;&lt; result &lt;&lt; '\n';
        }
    }
}</code></pre>
            </div>

            <div class="step-by-step">
                <strong>Solution Strategy:</strong><br>
                <strong>1.</strong> Build the tree from input and perform Euler Tour<br>
                <strong>2.</strong> Initialize BIT with node values at their start positions<br>
                <strong>3.</strong> For update queries: update the BIT at start[node]<br>
                <strong>4.</strong> For subtree sum queries: query BIT range [start[node], end[node]-1]<br>
                <strong>5.</strong> The range corresponds exactly to the subtree of the node
            </div>

            <div class="complexity">
                <strong>Time Complexity: $\mathcal{O}(N + Q \log N)$</strong><br>
                Where N is the number of nodes and Q is the number of queries. The Euler Tour takes O(N) time, and each BIT operation takes O(log N) time.
            </div>

            <div class="implementation-box">
                <strong>Key Implementation Details:</strong> Notice how we map each node's value to its start position in the flattened array. This ensures that when we query the range [start[node], end[node]-1], we get the sum of all values in the subtree rooted at that node.
            </div>
        </div>

        <div class="section hover-effect">
            <h2>Lowest Common Ancestor (LCA) using Euler Tour</h2>

            <p>Another powerful application of Euler Tour is solving <span class="highlight">Lowest Common Ancestor (LCA)</span> queries efficiently. We can reduce the LCA problem to a Range Minimum Query (RMQ) problem using a modified Euler Tour.</p>

            <div class="focus-problem">
                <strong>üéØ Focus Problems:</strong> Company Queries II & Distance Queries<br>
                Try your best to solve these problems before continuing!
            </div>

            <div class="lca-box">
                <strong>LCA Strategy:</strong> Perform an Euler Tour that records every node visit (including returns from children). The LCA of two nodes is the node with minimum depth in the tour between their first occurrences.
            </div>

            <div class="step-by-step">
                <strong>LCA Algorithm Steps:</strong><br>
                <strong>1.</strong> Perform modified Euler Tour recording all visits<br>
                <strong>2.</strong> For each node, record its first occurrence time (tin)<br>
                <strong>3.</strong> Build RMQ structure on the tour array with depths<br>
                <strong>4.</strong> LCA(u, v) = node with minimum depth in range [tin[u], tin[v]]<br>
                <strong>5.</strong> Use segment tree or sparse table for efficient RMQ
            </div>

            <h3 class="solution-header">LCA with Segment Tree Implementation</h3>

            <div class="code-container">
                <div class="code-header">C++ - LCA using Euler Tour and Segment Tree</div>
                <pre class="line-numbers"><code class="language-cpp">int n;  // The number of nodes in the graph
vector&lt;int&gt; graph[100000];
int timer = 0, tin[100000], euler_tour[200000];
int segtree[800000];  // Segment tree for RMQ

void dfs(int node = 0, int parent = -1) {
    tin[node] = timer;  // The time when we first visit a node
    euler_tour[timer++] = node;
    for (int i : graph[node]) {
        if (i != parent) {
            dfs(i, node);
            euler_tour[timer++] = node;  // Record return to this node
        }
    }
}

int mn_tin(int x, int y) {
    if (x == -1) return y;
    if (y == -1) return x;
    return (tin[x] &lt; tin[y] ? x : y);
}

// Build the segment tree: run `build()` after running dfs
void build(int node = 1, int l = 0, int r = timer - 1) {
    if (l == r) {
        segtree[node] = euler_tour[l];
    } else {
        int mid = (l + r) / 2;
        build(node * 2, l, mid);
        build(node * 2 + 1, mid + 1, r);
        segtree[node] = mn_tin(segtree[node * 2], segtree[node * 2 + 1]);
    }
}

int query(int a, int b, int node = 1, int l = 0, int r = timer - 1) {
    if (l &gt; b || r &lt; a) return -1;
    if (l &gt;= a &amp;&amp; r &lt;= b) return segtree[node];
    int mid = (l + r) / 2;
    return mn_tin(query(a, b, node * 2, l, mid), 
                  query(a, b, node * 2 + 1, mid + 1, r));
}

// Make sure you run dfs() and build() before you run this
int lca(int a, int b) {
    if (tin[a] &gt; tin[b]) swap(a, b);
    return query(tin[a], tin[b]);
}</code></pre>
            </div>

            <div class="algorithm-box">
                <strong>LCA Correctness:</strong> The modified Euler Tour ensures that between the first occurrences of nodes u and v, we visit their LCA and potentially many other nodes. The LCA is guaranteed to be the node with the smallest tin value (earliest first visit) in this range.
            </div>

            <div class="complexity">
                <strong>LCA Complexity: $\mathcal{O}(N)$ preprocessing, $\mathcal{O}(\log N)$ per query</strong><br>
                The above code does O(N) time preprocessing and allows LCA queries in O(log N) time using a segment tree for RMQ.
            </div>

            <h3>Sparse Table Optimization</h3>

            <div class="sparse-table-box">
                <strong>Sparse Table Enhancement:</strong> If we replace the segment tree that computes minimums with a sparse table, then we do O(N log N) time preprocessing and query in O(1) time. This trade-off is beneficial when we have many LCA queries.
            </div>

            <div class="focus-problem">
                <strong>üéØ Focus Problem:</strong> Static RMQ<br>
                Try your best to solve this problem before continuing!
            </div>

            <h3 class="solution-header">LCA with Sparse Table Implementation</h3>

            <div class="code-container">
                <div class="code-header">C++ - LCA with Sparse Table (O(1) queries)</div>
                <pre class="line-numbers"><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;

template &lt;typename T&gt; 
class SparseTable {
private:
    int n, log2dist;
    vector&lt;vector&lt;T&gt;&gt; st;

public:
    SparseTable(const vector&lt;T&gt; &amp;v) {
        n = (int)v.size();
        log2dist = 1 + (int)log2(n);
        st.resize(log2dist);
        st[0] = v;
        for (int i = 1; i &lt; log2dist; i++) {
            st[i].resize(n - (1 &lt;&lt; i) + 1);
            for (int j = 0; j + (1 &lt;&lt; i) &lt;= n; j++) {
                st[i][j] = min(st[i - 1][j], st[i - 1][j + (1 &lt;&lt; (i - 1))]);
            }
        }
    }

    /** @return minimum on the range [l, r] */
    T query(int l, int r) {
        int i = (int)log2(r - l + 1);
        return min(st[i][l], st[i][r - (1 &lt;&lt; i) + 1]);
    }
};

class LCA {
private:
    const int n;
    const vector&lt;vector&lt;int&gt;&gt; &amp;adj;
    SparseTable&lt;pair&lt;int, int&gt;&gt; rmq;
    vector&lt;int&gt; tin, et, dep;
    int timer = 0;

    /** prepares tin, et, dep arrays */
    void dfs(int u, int p) {
        tin[u] = timer;
        et[timer++] = u;
        for (int v : adj[u]) {
            if (v == p) { continue; }
            dep[v] = dep[u] + 1;
            dfs(v, u);
            et[timer++] = u;
        }
    }

public:
    // make sure the adjacency list is 0 indexed
    LCA(vector&lt;vector&lt;int&gt;&gt; &amp;_adj)
        : n((int)_adj.size()), adj(_adj), tin(n), et(2 * n), dep(n),
          rmq(vector&lt;pair&lt;int, int&gt;&gt;(1)) {
        dfs(0, -1);
        vector&lt;pair&lt;int, int&gt;&gt; arr(2 * n);
        for (int i = 0; i &lt; 2 * n; i++) { 
            arr[i] = {dep[et[i]], et[i]}; 
        }
        rmq = SparseTable&lt;pair&lt;int, int&gt;&gt;(arr);
    }

    /** @return LCA of nodes a and b */
    int query(int a, int b) {
        if (tin[a] &gt; tin[b]) { swap(a, b); }
        return rmq.query(tin[a], tin[b]).second;
    }
};</code></pre>
            </div>

            <div class="optimization-box">
                <strong>Sparse Table Trade-off:</strong> The sparse table approach uses O(N log N) space and preprocessing time but provides O(1) query time. This is ideal for applications with many LCA queries and sufficient memory.
            </div>

            <div class="complexity">
                <strong>Sparse Table Complexity: $\mathcal{O}(N \log N)$ preprocessing, $\mathcal{O}(1)$ per query</strong><br>
                Build time is O(N log N), and queries are O(1), making it optimal for scenarios with many LCA queries.
            </div>
        </div>

        <div class="section hover-effect">
            <h2>Advanced Applications and Extensions</h2>

            <h3>Heavy-Light Decomposition Integration</h3>

            <div class="optimization-box">
                <strong>Path Queries:</strong> Euler Tour can be combined with Heavy-Light Decomposition to solve path queries efficiently. While Euler Tour handles subtree queries naturally, HLD extends this to arbitrary path queries in O(log¬≤ N) time.
            </div>

            <h3>Dynamic Tree Algorithms</h3>

            <div class="applications-box">
                <strong>Extended Applications:</strong><br>
                ‚Ä¢ <strong>Link-Cut Trees:</strong> Dynamic connectivity in changing trees<br>
                ‚Ä¢ <strong>Centroid Decomposition:</strong> Path queries with different decomposition<br>
                ‚Ä¢ <strong>Tree DP Optimization:</strong> Converting recursive DP to iterative<br>
                ‚Ä¢ <strong>Parallel Algorithms:</strong> Tree algorithms on parallel architectures<br>
                ‚Ä¢ <strong>Tree Isomorphism:</strong> Canonical representation of trees
            </div>

            <div class="problem-patterns">
                <div class="pattern-card">
                    <div class="pattern-title">üåø Subtree Operations</div>
                    <p><strong>Problem:</strong> Update/query all nodes in a subtree<br>
                    <strong>Approach:</strong> Direct Euler Tour with range data structures<br>
                    <strong>Examples:</strong> Subtree sum, subtree maximum, lazy propagation</p>
                </div>
                
                <div class="pattern-card">
                    <div class="pattern-title">üå≤ Tree Traversal</div>
                    <p><strong>Problem:</strong> Convert recursive tree algorithms to iterative<br>
                    <strong>Approach:</strong> Use Euler Tour ordering for processing<br>
                    <strong>Examples:</strong> Tree DP, tree coloring, tree matching</p>
                </div>
                
                <div class="pattern-card">
                    <div class="pattern-title">üîç Ancestry Queries</div>
                    <p><strong>Problem:</strong> LCA, distance queries, path properties<br>
                    <strong>Approach:</strong> Euler Tour + RMQ or binary lifting<br>
                    <strong>Examples:</strong> Path sum, LCA, k-th ancestor</p>
                </div>
            </div>

            <h3>Memory and Cache Optimization</h3>

            <div class="implementation-box">
                <strong>Performance Tips:</strong><br>
                ‚Ä¢ <strong>Memory Layout:</strong> Store tour array contiguously for better cache performance<br>
                ‚Ä¢ <strong>Integer Types:</strong> Use appropriate integer sizes based on tree size<br>
                ‚Ä¢ <strong>Preprocessing:</strong> Combine multiple preprocessing steps in single DFS<br>
                ‚Ä¢ <strong>Query Optimization:</strong> Batch queries when possible for better locality
            </div>
        </div>

        <div class="section hover-effect">
            <h2>Implementation Tips and Best Practices</h2>

            <h3>Common Implementation Mistakes</h3>

            <div class="warning">
                <strong>Pitfall Prevention:</strong><br>
                ‚Ä¢ Don't forget to handle the parent parameter in DFS to avoid cycles<br>
                ‚Ä¢ Ensure timer is properly incremented at each step<br>
                ‚Ä¢ Remember that end[node] is exclusive (use end[node]-1 for queries)<br>
                ‚Ä¢ Handle 0-indexed vs 1-indexed input carefully<br>
                ‚Ä¢ Initialize data structures with correct sizes (2*N for full tour)
            </div>

            <h3>Template for Competitive Programming</h3>

            <div class="code-container">
                <div class="code-header">C++ - Euler Tour Template</div>
                <pre class="line-numbers"><code class="language-cpp">// Compact Euler Tour template for contests
class EulerTour {
    vector&lt;vector&lt;int&gt;&gt; adj;
    vector&lt;int&gt; start_time, end_time;
    int timer;
    
public:
    EulerTour(int n) : adj(n), start_time(n), end_time(n), timer(0) {}
    
    void add_edge(int u, int v) {
        adj[u].push_back(v);
        adj[v].push_back(u);
    }
    
    void dfs(int u, int p = -1) {
        start_time[u] = timer++;
        for (int v : adj[u]) {
            if (v != p) {
                dfs(v, u);
            }
        }
        end_time[u] = timer;
    }
    
    // Check if u is ancestor of v
    bool is_ancestor(int u, int v) {
        return start_time[u] &lt;= start_time[v] &amp;&amp; end_time[v] &lt;= end_time[u];
    }
    
    // Get subtree range for node u
    pair&lt;int, int&gt; subtree_range(int u) {
        return {start_time[u], end_time[u] - 1};
    }
};</code></pre>
            </div>

            <h3>Debugging Euler Tour</h3>

            <div class="algorithm-box">
                <strong>Debug Strategy:</strong> Print the start and end times for all nodes, verify that subtree ranges are properly nested, and check that the timer reaches 2*N-1 for full tour (or N for simple tour).
            </div>

            <div class="code-container">
                <div class="code-header">C++ - Debug Helper Functions</div>
                <pre class="line-numbers"><code class="language-cpp">// Add these functions for debugging Euler Tour
void print_tour_info(const vector&lt;int&gt;&amp; start, const vector&lt;int&gt;&amp; end) {
    cout &lt;&lt; "Euler Tour Results:\n";
    for (int i = 0; i &lt; start.size(); i++) {
        cout &lt;&lt; "Node " &lt;&lt; i &lt;&lt; ": start=" &lt;&lt; start[i] 
             &lt;&lt; ", end=" &lt;&lt; end[i] 
             &lt;&lt; ", subtree_size=" &lt;&lt; end[i] - start[i] &lt;&lt; "\n";
    }
}

void verify_subtree_property(int u, int v, const vector&lt;int&gt;&amp; start, 
                             const vector&lt;int&gt;&amp; end) {
    bool u_contains_v = (start[u] &lt;= start[v] &amp;&amp; end[v] &lt;= end[u]);
    bool v_contains_u = (start[v] &lt;= start[u] &amp;&amp; end[u] &lt;= end[v]);
    bool disjoint = (end[u] &lt;= start[v] || end[v] &lt;= start[u]);
    
    cout &lt;&lt; "Nodes " &lt;&lt; u &lt;&lt; " and " &lt;&lt; v &lt;&lt; ": ";
    if (u_contains_v) cout &lt;&lt; u &lt;&lt; " contains " &lt;&lt; v;
    else if (v_contains_u) cout &lt;&lt; v &lt;&lt; " contains " &lt;&lt; u;
    else if (disjoint) cout &lt;&lt; "disjoint subtrees";
    else cout &lt;&lt; "ERROR: invalid relationship";
    cout &lt;&lt; "\n";
}</code></pre>
            </div>
        </div>

        <div class="section hover-effect">
            <h2>Summary and Key Takeaways</h2>

            <div class="definition-box">
                The Euler Tour Technique is a fundamental algorithm that transforms tree problems into array problems, enabling efficient subtree operations and LCA queries through the power of range-based data structures.
            </div>

            <div class="problem-patterns">
                <div class="pattern-card">
                    <div class="pattern-title">What You've Mastered</div>
                    <ul style="padding-left: 20px; list-style: disc;">
                        <li>Basic Euler Tour technique and implementation</li>
                        <li>Subtree queries using range data structures</li>
                        <li>LCA queries via RMQ reduction</li>
                        <li>Sparse table optimization for O(1) queries</li>
                        <li>Tree flattening and timestamp techniques</li>
                    </ul>
                </div>
                <div class="pattern-card">
                    <div class="pattern-title">Next Learning Goals</div>
                    <ul style="padding-left: 20px; list-style: disc;">
                        <li>Heavy-Light Decomposition for path queries</li>
                        <li>Centroid Decomposition techniques</li>
                        <li>Link-Cut Trees for dynamic connectivity</li>
                        <li>Tree DP optimization using tours</li>
                        <li>Advanced tree algorithms and data structures</li>
                    </ul>
                </div>
            </div>

            <div class="focus-problem">
                <strong>üéØ Practice Challenge:</strong><br>
                Now that you understand Euler Tour Technique, try solving "Tree Queries," "Path Queries," or "Subtree Updates" to practice different applications and build your tree algorithm skills!
            </div>

            <div class="euler-tour-box">
                <strong>Real-World Impact:</strong> Euler Tour techniques are fundamental in compiler optimization, database query processing, XML/HTML parsing, file system operations, and any application requiring efficient tree traversal and querying.
            </div>

            <div class="algorithm-box">
                <strong>Key Insight:</strong> The power of Euler Tour lies in its ability to transform complex tree relationships into simple array intervals, enabling the use of powerful range query data structures and algorithms.
            </div>

            <div class="complexity">
                <strong>Performance Summary:</strong> Euler Tour provides O(N) preprocessing with O(log N) subtree queries using segment trees, or O(N log N) preprocessing with O(1) LCA queries using sparse tables, making it highly efficient for most tree algorithms.
            </div>

            <div class="implementation-box">
                <strong>Final Reminder:</strong> Euler Tour is often the key technique that transforms intractable tree problems into efficient array-based solutions. Always consider flattening the tree when dealing with subtree operations, ancestor queries, or tree DP optimizations.
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
</body>
</html>